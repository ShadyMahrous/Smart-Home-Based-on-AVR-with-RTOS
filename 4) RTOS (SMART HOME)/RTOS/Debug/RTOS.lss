
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000063a6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000178  00800060  000063a6  0000643a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000581  008001d8  008001d8  000065b2  2**0
                  ALLOC
  3 .stab         00007c5c  00000000  00000000  000065b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003bec  00000000  00000000  0000e210  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001c0  00000000  00000000  00011dfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000210  00000000  00000000  00011fbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000268a  00000000  00000000  000121cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000014e0  00000000  00000000  00014856  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000012a9  00000000  00000000  00015d36  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001e0  00000000  00000000  00016fe0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002fe  00000000  00000000  000171c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000009aa  00000000  00000000  000174be  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00017e68  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9e 1e 	jmp	0x3d3c	; 0x3d3c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 ec 07 	jmp	0xfd8	; 0xfd8 <__vector_10>
      2c:	0c 94 bf 07 	jmp	0xf7e	; 0xf7e <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 ce 0c 	jmp	0x199c	; 0x199c <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 ea       	ldi	r30, 0xA6	; 166
      68:	f3 e6       	ldi	r31, 0x63	; 99
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 3d       	cpi	r26, 0xD8	; 216
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 ed       	ldi	r26, 0xD8	; 216
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 35       	cpi	r26, 0x59	; 89
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 16 2c 	call	0x582c	; 0x582c <main>
      8a:	0c 94 d1 31 	jmp	0x63a2	; 0x63a2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 85 04 	call	0x90a	; 0x90a <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 85 04 	call	0x90a	; 0x90a <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 09 31 	jmp	0x6212	; 0x6212 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	aa eb       	ldi	r26, 0xBA	; 186
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 25 31 	jmp	0x624a	; 0x624a <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 15 31 	jmp	0x622a	; 0x622a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a1 05 	call	0xb42	; 0xb42 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 31 31 	jmp	0x6262	; 0x6262 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 15 31 	jmp	0x622a	; 0x622a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a1 05 	call	0xb42	; 0xb42 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 31 31 	jmp	0x6262	; 0x6262 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 09 31 	jmp	0x6212	; 0x6212 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8a eb       	ldi	r24, 0xBA	; 186
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a1 05 	call	0xb42	; 0xb42 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 25 31 	jmp	0x624a	; 0x624a <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 11 31 	jmp	0x6222	; 0x6222 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6a eb       	ldi	r22, 0xBA	; 186
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a1 05 	call	0xb42	; 0xb42 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 2d 31 	jmp	0x625a	; 0x625a <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 15 31 	jmp	0x622a	; 0x622a <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 ee 06 	call	0xddc	; 0xddc <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 31 31 	jmp	0x6262	; 0x6262 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 15 31 	jmp	0x622a	; 0x622a <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 ee 06 	call	0xddc	; 0xddc <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 31 31 	jmp	0x6262	; 0x6262 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 15 31 	jmp	0x622a	; 0x622a <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 ee 06 	call	0xddc	; 0xddc <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 31 31 	jmp	0x6262	; 0x6262 <__epilogue_restores__+0x18>

000008aa <__lesf2>:
     8aa:	a8 e1       	ldi	r26, 0x18	; 24
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 15 31 	jmp	0x622a	; 0x622a <__prologue_saves__+0x18>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	2d 83       	std	Y+5, r18	; 0x05
     8c0:	3e 83       	std	Y+6, r19	; 0x06
     8c2:	4f 83       	std	Y+7, r20	; 0x07
     8c4:	58 87       	std	Y+8, r21	; 0x08
     8c6:	89 e0       	ldi	r24, 0x09	; 9
     8c8:	e8 2e       	mov	r14, r24
     8ca:	f1 2c       	mov	r15, r1
     8cc:	ec 0e       	add	r14, r28
     8ce:	fd 1e       	adc	r15, r29
     8d0:	ce 01       	movw	r24, r28
     8d2:	01 96       	adiw	r24, 0x01	; 1
     8d4:	b7 01       	movw	r22, r14
     8d6:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     8da:	8e 01       	movw	r16, r28
     8dc:	0f 5e       	subi	r16, 0xEF	; 239
     8de:	1f 4f       	sbci	r17, 0xFF	; 255
     8e0:	ce 01       	movw	r24, r28
     8e2:	05 96       	adiw	r24, 0x05	; 5
     8e4:	b8 01       	movw	r22, r16
     8e6:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     8ea:	89 85       	ldd	r24, Y+9	; 0x09
     8ec:	82 30       	cpi	r24, 0x02	; 2
     8ee:	40 f0       	brcs	.+16     	; 0x900 <__lesf2+0x56>
     8f0:	89 89       	ldd	r24, Y+17	; 0x11
     8f2:	82 30       	cpi	r24, 0x02	; 2
     8f4:	28 f0       	brcs	.+10     	; 0x900 <__lesf2+0x56>
     8f6:	c7 01       	movw	r24, r14
     8f8:	b8 01       	movw	r22, r16
     8fa:	0e 94 ee 06 	call	0xddc	; 0xddc <__fpcmp_parts_f>
     8fe:	01 c0       	rjmp	.+2      	; 0x902 <__lesf2+0x58>
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	68 96       	adiw	r28, 0x18	; 24
     904:	e6 e0       	ldi	r30, 0x06	; 6
     906:	0c 94 31 31 	jmp	0x6262	; 0x6262 <__epilogue_restores__+0x18>

0000090a <__fixsfsi>:
     90a:	ac e0       	ldi	r26, 0x0C	; 12
     90c:	b0 e0       	ldi	r27, 0x00	; 0
     90e:	eb e8       	ldi	r30, 0x8B	; 139
     910:	f4 e0       	ldi	r31, 0x04	; 4
     912:	0c 94 19 31 	jmp	0x6232	; 0x6232 <__prologue_saves__+0x20>
     916:	69 83       	std	Y+1, r22	; 0x01
     918:	7a 83       	std	Y+2, r23	; 0x02
     91a:	8b 83       	std	Y+3, r24	; 0x03
     91c:	9c 83       	std	Y+4, r25	; 0x04
     91e:	ce 01       	movw	r24, r28
     920:	01 96       	adiw	r24, 0x01	; 1
     922:	be 01       	movw	r22, r28
     924:	6b 5f       	subi	r22, 0xFB	; 251
     926:	7f 4f       	sbci	r23, 0xFF	; 255
     928:	0e 94 76 06 	call	0xcec	; 0xcec <__unpack_f>
     92c:	8d 81       	ldd	r24, Y+5	; 0x05
     92e:	82 30       	cpi	r24, 0x02	; 2
     930:	61 f1       	breq	.+88     	; 0x98a <__fixsfsi+0x80>
     932:	82 30       	cpi	r24, 0x02	; 2
     934:	50 f1       	brcs	.+84     	; 0x98a <__fixsfsi+0x80>
     936:	84 30       	cpi	r24, 0x04	; 4
     938:	21 f4       	brne	.+8      	; 0x942 <__fixsfsi+0x38>
     93a:	8e 81       	ldd	r24, Y+6	; 0x06
     93c:	88 23       	and	r24, r24
     93e:	51 f1       	breq	.+84     	; 0x994 <__fixsfsi+0x8a>
     940:	2e c0       	rjmp	.+92     	; 0x99e <__fixsfsi+0x94>
     942:	2f 81       	ldd	r18, Y+7	; 0x07
     944:	38 85       	ldd	r19, Y+8	; 0x08
     946:	37 fd       	sbrc	r19, 7
     948:	20 c0       	rjmp	.+64     	; 0x98a <__fixsfsi+0x80>
     94a:	6e 81       	ldd	r22, Y+6	; 0x06
     94c:	2f 31       	cpi	r18, 0x1F	; 31
     94e:	31 05       	cpc	r19, r1
     950:	1c f0       	brlt	.+6      	; 0x958 <__fixsfsi+0x4e>
     952:	66 23       	and	r22, r22
     954:	f9 f0       	breq	.+62     	; 0x994 <__fixsfsi+0x8a>
     956:	23 c0       	rjmp	.+70     	; 0x99e <__fixsfsi+0x94>
     958:	8e e1       	ldi	r24, 0x1E	; 30
     95a:	90 e0       	ldi	r25, 0x00	; 0
     95c:	82 1b       	sub	r24, r18
     95e:	93 0b       	sbc	r25, r19
     960:	29 85       	ldd	r18, Y+9	; 0x09
     962:	3a 85       	ldd	r19, Y+10	; 0x0a
     964:	4b 85       	ldd	r20, Y+11	; 0x0b
     966:	5c 85       	ldd	r21, Y+12	; 0x0c
     968:	04 c0       	rjmp	.+8      	; 0x972 <__fixsfsi+0x68>
     96a:	56 95       	lsr	r21
     96c:	47 95       	ror	r20
     96e:	37 95       	ror	r19
     970:	27 95       	ror	r18
     972:	8a 95       	dec	r24
     974:	d2 f7       	brpl	.-12     	; 0x96a <__fixsfsi+0x60>
     976:	66 23       	and	r22, r22
     978:	b1 f0       	breq	.+44     	; 0x9a6 <__fixsfsi+0x9c>
     97a:	50 95       	com	r21
     97c:	40 95       	com	r20
     97e:	30 95       	com	r19
     980:	21 95       	neg	r18
     982:	3f 4f       	sbci	r19, 0xFF	; 255
     984:	4f 4f       	sbci	r20, 0xFF	; 255
     986:	5f 4f       	sbci	r21, 0xFF	; 255
     988:	0e c0       	rjmp	.+28     	; 0x9a6 <__fixsfsi+0x9c>
     98a:	20 e0       	ldi	r18, 0x00	; 0
     98c:	30 e0       	ldi	r19, 0x00	; 0
     98e:	40 e0       	ldi	r20, 0x00	; 0
     990:	50 e0       	ldi	r21, 0x00	; 0
     992:	09 c0       	rjmp	.+18     	; 0x9a6 <__fixsfsi+0x9c>
     994:	2f ef       	ldi	r18, 0xFF	; 255
     996:	3f ef       	ldi	r19, 0xFF	; 255
     998:	4f ef       	ldi	r20, 0xFF	; 255
     99a:	5f e7       	ldi	r21, 0x7F	; 127
     99c:	04 c0       	rjmp	.+8      	; 0x9a6 <__fixsfsi+0x9c>
     99e:	20 e0       	ldi	r18, 0x00	; 0
     9a0:	30 e0       	ldi	r19, 0x00	; 0
     9a2:	40 e0       	ldi	r20, 0x00	; 0
     9a4:	50 e8       	ldi	r21, 0x80	; 128
     9a6:	b9 01       	movw	r22, r18
     9a8:	ca 01       	movw	r24, r20
     9aa:	2c 96       	adiw	r28, 0x0c	; 12
     9ac:	e2 e0       	ldi	r30, 0x02	; 2
     9ae:	0c 94 35 31 	jmp	0x626a	; 0x626a <__epilogue_restores__+0x20>

000009b2 <__floatunsisf>:
     9b2:	a8 e0       	ldi	r26, 0x08	; 8
     9b4:	b0 e0       	ldi	r27, 0x00	; 0
     9b6:	ef ed       	ldi	r30, 0xDF	; 223
     9b8:	f4 e0       	ldi	r31, 0x04	; 4
     9ba:	0c 94 11 31 	jmp	0x6222	; 0x6222 <__prologue_saves__+0x10>
     9be:	7b 01       	movw	r14, r22
     9c0:	8c 01       	movw	r16, r24
     9c2:	61 15       	cp	r22, r1
     9c4:	71 05       	cpc	r23, r1
     9c6:	81 05       	cpc	r24, r1
     9c8:	91 05       	cpc	r25, r1
     9ca:	19 f4       	brne	.+6      	; 0x9d2 <__floatunsisf+0x20>
     9cc:	82 e0       	ldi	r24, 0x02	; 2
     9ce:	89 83       	std	Y+1, r24	; 0x01
     9d0:	60 c0       	rjmp	.+192    	; 0xa92 <__floatunsisf+0xe0>
     9d2:	83 e0       	ldi	r24, 0x03	; 3
     9d4:	89 83       	std	Y+1, r24	; 0x01
     9d6:	8e e1       	ldi	r24, 0x1E	; 30
     9d8:	c8 2e       	mov	r12, r24
     9da:	d1 2c       	mov	r13, r1
     9dc:	dc 82       	std	Y+4, r13	; 0x04
     9de:	cb 82       	std	Y+3, r12	; 0x03
     9e0:	ed 82       	std	Y+5, r14	; 0x05
     9e2:	fe 82       	std	Y+6, r15	; 0x06
     9e4:	0f 83       	std	Y+7, r16	; 0x07
     9e6:	18 87       	std	Y+8, r17	; 0x08
     9e8:	c8 01       	movw	r24, r16
     9ea:	b7 01       	movw	r22, r14
     9ec:	0e 94 52 05 	call	0xaa4	; 0xaa4 <__clzsi2>
     9f0:	fc 01       	movw	r30, r24
     9f2:	31 97       	sbiw	r30, 0x01	; 1
     9f4:	f7 ff       	sbrs	r31, 7
     9f6:	3b c0       	rjmp	.+118    	; 0xa6e <__floatunsisf+0xbc>
     9f8:	22 27       	eor	r18, r18
     9fa:	33 27       	eor	r19, r19
     9fc:	2e 1b       	sub	r18, r30
     9fe:	3f 0b       	sbc	r19, r31
     a00:	57 01       	movw	r10, r14
     a02:	68 01       	movw	r12, r16
     a04:	02 2e       	mov	r0, r18
     a06:	04 c0       	rjmp	.+8      	; 0xa10 <__floatunsisf+0x5e>
     a08:	d6 94       	lsr	r13
     a0a:	c7 94       	ror	r12
     a0c:	b7 94       	ror	r11
     a0e:	a7 94       	ror	r10
     a10:	0a 94       	dec	r0
     a12:	d2 f7       	brpl	.-12     	; 0xa08 <__floatunsisf+0x56>
     a14:	40 e0       	ldi	r20, 0x00	; 0
     a16:	50 e0       	ldi	r21, 0x00	; 0
     a18:	60 e0       	ldi	r22, 0x00	; 0
     a1a:	70 e0       	ldi	r23, 0x00	; 0
     a1c:	81 e0       	ldi	r24, 0x01	; 1
     a1e:	90 e0       	ldi	r25, 0x00	; 0
     a20:	a0 e0       	ldi	r26, 0x00	; 0
     a22:	b0 e0       	ldi	r27, 0x00	; 0
     a24:	04 c0       	rjmp	.+8      	; 0xa2e <__floatunsisf+0x7c>
     a26:	88 0f       	add	r24, r24
     a28:	99 1f       	adc	r25, r25
     a2a:	aa 1f       	adc	r26, r26
     a2c:	bb 1f       	adc	r27, r27
     a2e:	2a 95       	dec	r18
     a30:	d2 f7       	brpl	.-12     	; 0xa26 <__floatunsisf+0x74>
     a32:	01 97       	sbiw	r24, 0x01	; 1
     a34:	a1 09       	sbc	r26, r1
     a36:	b1 09       	sbc	r27, r1
     a38:	8e 21       	and	r24, r14
     a3a:	9f 21       	and	r25, r15
     a3c:	a0 23       	and	r26, r16
     a3e:	b1 23       	and	r27, r17
     a40:	00 97       	sbiw	r24, 0x00	; 0
     a42:	a1 05       	cpc	r26, r1
     a44:	b1 05       	cpc	r27, r1
     a46:	21 f0       	breq	.+8      	; 0xa50 <__floatunsisf+0x9e>
     a48:	41 e0       	ldi	r20, 0x01	; 1
     a4a:	50 e0       	ldi	r21, 0x00	; 0
     a4c:	60 e0       	ldi	r22, 0x00	; 0
     a4e:	70 e0       	ldi	r23, 0x00	; 0
     a50:	4a 29       	or	r20, r10
     a52:	5b 29       	or	r21, r11
     a54:	6c 29       	or	r22, r12
     a56:	7d 29       	or	r23, r13
     a58:	4d 83       	std	Y+5, r20	; 0x05
     a5a:	5e 83       	std	Y+6, r21	; 0x06
     a5c:	6f 83       	std	Y+7, r22	; 0x07
     a5e:	78 87       	std	Y+8, r23	; 0x08
     a60:	8e e1       	ldi	r24, 0x1E	; 30
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	8e 1b       	sub	r24, r30
     a66:	9f 0b       	sbc	r25, r31
     a68:	9c 83       	std	Y+4, r25	; 0x04
     a6a:	8b 83       	std	Y+3, r24	; 0x03
     a6c:	12 c0       	rjmp	.+36     	; 0xa92 <__floatunsisf+0xe0>
     a6e:	30 97       	sbiw	r30, 0x00	; 0
     a70:	81 f0       	breq	.+32     	; 0xa92 <__floatunsisf+0xe0>
     a72:	0e 2e       	mov	r0, r30
     a74:	04 c0       	rjmp	.+8      	; 0xa7e <__floatunsisf+0xcc>
     a76:	ee 0c       	add	r14, r14
     a78:	ff 1c       	adc	r15, r15
     a7a:	00 1f       	adc	r16, r16
     a7c:	11 1f       	adc	r17, r17
     a7e:	0a 94       	dec	r0
     a80:	d2 f7       	brpl	.-12     	; 0xa76 <__floatunsisf+0xc4>
     a82:	ed 82       	std	Y+5, r14	; 0x05
     a84:	fe 82       	std	Y+6, r15	; 0x06
     a86:	0f 83       	std	Y+7, r16	; 0x07
     a88:	18 87       	std	Y+8, r17	; 0x08
     a8a:	ce 1a       	sub	r12, r30
     a8c:	df 0a       	sbc	r13, r31
     a8e:	dc 82       	std	Y+4, r13	; 0x04
     a90:	cb 82       	std	Y+3, r12	; 0x03
     a92:	1a 82       	std	Y+2, r1	; 0x02
     a94:	ce 01       	movw	r24, r28
     a96:	01 96       	adiw	r24, 0x01	; 1
     a98:	0e 94 a1 05 	call	0xb42	; 0xb42 <__pack_f>
     a9c:	28 96       	adiw	r28, 0x08	; 8
     a9e:	ea e0       	ldi	r30, 0x0A	; 10
     aa0:	0c 94 2d 31 	jmp	0x625a	; 0x625a <__epilogue_restores__+0x10>

00000aa4 <__clzsi2>:
     aa4:	ef 92       	push	r14
     aa6:	ff 92       	push	r15
     aa8:	0f 93       	push	r16
     aaa:	1f 93       	push	r17
     aac:	7b 01       	movw	r14, r22
     aae:	8c 01       	movw	r16, r24
     ab0:	80 e0       	ldi	r24, 0x00	; 0
     ab2:	e8 16       	cp	r14, r24
     ab4:	80 e0       	ldi	r24, 0x00	; 0
     ab6:	f8 06       	cpc	r15, r24
     ab8:	81 e0       	ldi	r24, 0x01	; 1
     aba:	08 07       	cpc	r16, r24
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	18 07       	cpc	r17, r24
     ac0:	88 f4       	brcc	.+34     	; 0xae4 <__clzsi2+0x40>
     ac2:	8f ef       	ldi	r24, 0xFF	; 255
     ac4:	e8 16       	cp	r14, r24
     ac6:	f1 04       	cpc	r15, r1
     ac8:	01 05       	cpc	r16, r1
     aca:	11 05       	cpc	r17, r1
     acc:	31 f0       	breq	.+12     	; 0xada <__clzsi2+0x36>
     ace:	28 f0       	brcs	.+10     	; 0xada <__clzsi2+0x36>
     ad0:	88 e0       	ldi	r24, 0x08	; 8
     ad2:	90 e0       	ldi	r25, 0x00	; 0
     ad4:	a0 e0       	ldi	r26, 0x00	; 0
     ad6:	b0 e0       	ldi	r27, 0x00	; 0
     ad8:	17 c0       	rjmp	.+46     	; 0xb08 <__clzsi2+0x64>
     ada:	80 e0       	ldi	r24, 0x00	; 0
     adc:	90 e0       	ldi	r25, 0x00	; 0
     ade:	a0 e0       	ldi	r26, 0x00	; 0
     ae0:	b0 e0       	ldi	r27, 0x00	; 0
     ae2:	12 c0       	rjmp	.+36     	; 0xb08 <__clzsi2+0x64>
     ae4:	80 e0       	ldi	r24, 0x00	; 0
     ae6:	e8 16       	cp	r14, r24
     ae8:	80 e0       	ldi	r24, 0x00	; 0
     aea:	f8 06       	cpc	r15, r24
     aec:	80 e0       	ldi	r24, 0x00	; 0
     aee:	08 07       	cpc	r16, r24
     af0:	81 e0       	ldi	r24, 0x01	; 1
     af2:	18 07       	cpc	r17, r24
     af4:	28 f0       	brcs	.+10     	; 0xb00 <__clzsi2+0x5c>
     af6:	88 e1       	ldi	r24, 0x18	; 24
     af8:	90 e0       	ldi	r25, 0x00	; 0
     afa:	a0 e0       	ldi	r26, 0x00	; 0
     afc:	b0 e0       	ldi	r27, 0x00	; 0
     afe:	04 c0       	rjmp	.+8      	; 0xb08 <__clzsi2+0x64>
     b00:	80 e1       	ldi	r24, 0x10	; 16
     b02:	90 e0       	ldi	r25, 0x00	; 0
     b04:	a0 e0       	ldi	r26, 0x00	; 0
     b06:	b0 e0       	ldi	r27, 0x00	; 0
     b08:	20 e2       	ldi	r18, 0x20	; 32
     b0a:	30 e0       	ldi	r19, 0x00	; 0
     b0c:	40 e0       	ldi	r20, 0x00	; 0
     b0e:	50 e0       	ldi	r21, 0x00	; 0
     b10:	28 1b       	sub	r18, r24
     b12:	39 0b       	sbc	r19, r25
     b14:	4a 0b       	sbc	r20, r26
     b16:	5b 0b       	sbc	r21, r27
     b18:	04 c0       	rjmp	.+8      	; 0xb22 <__clzsi2+0x7e>
     b1a:	16 95       	lsr	r17
     b1c:	07 95       	ror	r16
     b1e:	f7 94       	ror	r15
     b20:	e7 94       	ror	r14
     b22:	8a 95       	dec	r24
     b24:	d2 f7       	brpl	.-12     	; 0xb1a <__clzsi2+0x76>
     b26:	f7 01       	movw	r30, r14
     b28:	ee 53       	subi	r30, 0x3E	; 62
     b2a:	ff 4f       	sbci	r31, 0xFF	; 255
     b2c:	80 81       	ld	r24, Z
     b2e:	28 1b       	sub	r18, r24
     b30:	31 09       	sbc	r19, r1
     b32:	41 09       	sbc	r20, r1
     b34:	51 09       	sbc	r21, r1
     b36:	c9 01       	movw	r24, r18
     b38:	1f 91       	pop	r17
     b3a:	0f 91       	pop	r16
     b3c:	ff 90       	pop	r15
     b3e:	ef 90       	pop	r14
     b40:	08 95       	ret

00000b42 <__pack_f>:
     b42:	df 92       	push	r13
     b44:	ef 92       	push	r14
     b46:	ff 92       	push	r15
     b48:	0f 93       	push	r16
     b4a:	1f 93       	push	r17
     b4c:	fc 01       	movw	r30, r24
     b4e:	e4 80       	ldd	r14, Z+4	; 0x04
     b50:	f5 80       	ldd	r15, Z+5	; 0x05
     b52:	06 81       	ldd	r16, Z+6	; 0x06
     b54:	17 81       	ldd	r17, Z+7	; 0x07
     b56:	d1 80       	ldd	r13, Z+1	; 0x01
     b58:	80 81       	ld	r24, Z
     b5a:	82 30       	cpi	r24, 0x02	; 2
     b5c:	48 f4       	brcc	.+18     	; 0xb70 <__pack_f+0x2e>
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	90 e0       	ldi	r25, 0x00	; 0
     b62:	a0 e1       	ldi	r26, 0x10	; 16
     b64:	b0 e0       	ldi	r27, 0x00	; 0
     b66:	e8 2a       	or	r14, r24
     b68:	f9 2a       	or	r15, r25
     b6a:	0a 2b       	or	r16, r26
     b6c:	1b 2b       	or	r17, r27
     b6e:	a5 c0       	rjmp	.+330    	; 0xcba <__pack_f+0x178>
     b70:	84 30       	cpi	r24, 0x04	; 4
     b72:	09 f4       	brne	.+2      	; 0xb76 <__pack_f+0x34>
     b74:	9f c0       	rjmp	.+318    	; 0xcb4 <__pack_f+0x172>
     b76:	82 30       	cpi	r24, 0x02	; 2
     b78:	21 f4       	brne	.+8      	; 0xb82 <__pack_f+0x40>
     b7a:	ee 24       	eor	r14, r14
     b7c:	ff 24       	eor	r15, r15
     b7e:	87 01       	movw	r16, r14
     b80:	05 c0       	rjmp	.+10     	; 0xb8c <__pack_f+0x4a>
     b82:	e1 14       	cp	r14, r1
     b84:	f1 04       	cpc	r15, r1
     b86:	01 05       	cpc	r16, r1
     b88:	11 05       	cpc	r17, r1
     b8a:	19 f4       	brne	.+6      	; 0xb92 <__pack_f+0x50>
     b8c:	e0 e0       	ldi	r30, 0x00	; 0
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	96 c0       	rjmp	.+300    	; 0xcbe <__pack_f+0x17c>
     b92:	62 81       	ldd	r22, Z+2	; 0x02
     b94:	73 81       	ldd	r23, Z+3	; 0x03
     b96:	9f ef       	ldi	r25, 0xFF	; 255
     b98:	62 38       	cpi	r22, 0x82	; 130
     b9a:	79 07       	cpc	r23, r25
     b9c:	0c f0       	brlt	.+2      	; 0xba0 <__pack_f+0x5e>
     b9e:	5b c0       	rjmp	.+182    	; 0xc56 <__pack_f+0x114>
     ba0:	22 e8       	ldi	r18, 0x82	; 130
     ba2:	3f ef       	ldi	r19, 0xFF	; 255
     ba4:	26 1b       	sub	r18, r22
     ba6:	37 0b       	sbc	r19, r23
     ba8:	2a 31       	cpi	r18, 0x1A	; 26
     baa:	31 05       	cpc	r19, r1
     bac:	2c f0       	brlt	.+10     	; 0xbb8 <__pack_f+0x76>
     bae:	20 e0       	ldi	r18, 0x00	; 0
     bb0:	30 e0       	ldi	r19, 0x00	; 0
     bb2:	40 e0       	ldi	r20, 0x00	; 0
     bb4:	50 e0       	ldi	r21, 0x00	; 0
     bb6:	2a c0       	rjmp	.+84     	; 0xc0c <__pack_f+0xca>
     bb8:	b8 01       	movw	r22, r16
     bba:	a7 01       	movw	r20, r14
     bbc:	02 2e       	mov	r0, r18
     bbe:	04 c0       	rjmp	.+8      	; 0xbc8 <__pack_f+0x86>
     bc0:	76 95       	lsr	r23
     bc2:	67 95       	ror	r22
     bc4:	57 95       	ror	r21
     bc6:	47 95       	ror	r20
     bc8:	0a 94       	dec	r0
     bca:	d2 f7       	brpl	.-12     	; 0xbc0 <__pack_f+0x7e>
     bcc:	81 e0       	ldi	r24, 0x01	; 1
     bce:	90 e0       	ldi	r25, 0x00	; 0
     bd0:	a0 e0       	ldi	r26, 0x00	; 0
     bd2:	b0 e0       	ldi	r27, 0x00	; 0
     bd4:	04 c0       	rjmp	.+8      	; 0xbde <__pack_f+0x9c>
     bd6:	88 0f       	add	r24, r24
     bd8:	99 1f       	adc	r25, r25
     bda:	aa 1f       	adc	r26, r26
     bdc:	bb 1f       	adc	r27, r27
     bde:	2a 95       	dec	r18
     be0:	d2 f7       	brpl	.-12     	; 0xbd6 <__pack_f+0x94>
     be2:	01 97       	sbiw	r24, 0x01	; 1
     be4:	a1 09       	sbc	r26, r1
     be6:	b1 09       	sbc	r27, r1
     be8:	8e 21       	and	r24, r14
     bea:	9f 21       	and	r25, r15
     bec:	a0 23       	and	r26, r16
     bee:	b1 23       	and	r27, r17
     bf0:	00 97       	sbiw	r24, 0x00	; 0
     bf2:	a1 05       	cpc	r26, r1
     bf4:	b1 05       	cpc	r27, r1
     bf6:	21 f0       	breq	.+8      	; 0xc00 <__pack_f+0xbe>
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	90 e0       	ldi	r25, 0x00	; 0
     bfc:	a0 e0       	ldi	r26, 0x00	; 0
     bfe:	b0 e0       	ldi	r27, 0x00	; 0
     c00:	9a 01       	movw	r18, r20
     c02:	ab 01       	movw	r20, r22
     c04:	28 2b       	or	r18, r24
     c06:	39 2b       	or	r19, r25
     c08:	4a 2b       	or	r20, r26
     c0a:	5b 2b       	or	r21, r27
     c0c:	da 01       	movw	r26, r20
     c0e:	c9 01       	movw	r24, r18
     c10:	8f 77       	andi	r24, 0x7F	; 127
     c12:	90 70       	andi	r25, 0x00	; 0
     c14:	a0 70       	andi	r26, 0x00	; 0
     c16:	b0 70       	andi	r27, 0x00	; 0
     c18:	80 34       	cpi	r24, 0x40	; 64
     c1a:	91 05       	cpc	r25, r1
     c1c:	a1 05       	cpc	r26, r1
     c1e:	b1 05       	cpc	r27, r1
     c20:	39 f4       	brne	.+14     	; 0xc30 <__pack_f+0xee>
     c22:	27 ff       	sbrs	r18, 7
     c24:	09 c0       	rjmp	.+18     	; 0xc38 <__pack_f+0xf6>
     c26:	20 5c       	subi	r18, 0xC0	; 192
     c28:	3f 4f       	sbci	r19, 0xFF	; 255
     c2a:	4f 4f       	sbci	r20, 0xFF	; 255
     c2c:	5f 4f       	sbci	r21, 0xFF	; 255
     c2e:	04 c0       	rjmp	.+8      	; 0xc38 <__pack_f+0xf6>
     c30:	21 5c       	subi	r18, 0xC1	; 193
     c32:	3f 4f       	sbci	r19, 0xFF	; 255
     c34:	4f 4f       	sbci	r20, 0xFF	; 255
     c36:	5f 4f       	sbci	r21, 0xFF	; 255
     c38:	e0 e0       	ldi	r30, 0x00	; 0
     c3a:	f0 e0       	ldi	r31, 0x00	; 0
     c3c:	20 30       	cpi	r18, 0x00	; 0
     c3e:	a0 e0       	ldi	r26, 0x00	; 0
     c40:	3a 07       	cpc	r19, r26
     c42:	a0 e0       	ldi	r26, 0x00	; 0
     c44:	4a 07       	cpc	r20, r26
     c46:	a0 e4       	ldi	r26, 0x40	; 64
     c48:	5a 07       	cpc	r21, r26
     c4a:	10 f0       	brcs	.+4      	; 0xc50 <__pack_f+0x10e>
     c4c:	e1 e0       	ldi	r30, 0x01	; 1
     c4e:	f0 e0       	ldi	r31, 0x00	; 0
     c50:	79 01       	movw	r14, r18
     c52:	8a 01       	movw	r16, r20
     c54:	27 c0       	rjmp	.+78     	; 0xca4 <__pack_f+0x162>
     c56:	60 38       	cpi	r22, 0x80	; 128
     c58:	71 05       	cpc	r23, r1
     c5a:	64 f5       	brge	.+88     	; 0xcb4 <__pack_f+0x172>
     c5c:	fb 01       	movw	r30, r22
     c5e:	e1 58       	subi	r30, 0x81	; 129
     c60:	ff 4f       	sbci	r31, 0xFF	; 255
     c62:	d8 01       	movw	r26, r16
     c64:	c7 01       	movw	r24, r14
     c66:	8f 77       	andi	r24, 0x7F	; 127
     c68:	90 70       	andi	r25, 0x00	; 0
     c6a:	a0 70       	andi	r26, 0x00	; 0
     c6c:	b0 70       	andi	r27, 0x00	; 0
     c6e:	80 34       	cpi	r24, 0x40	; 64
     c70:	91 05       	cpc	r25, r1
     c72:	a1 05       	cpc	r26, r1
     c74:	b1 05       	cpc	r27, r1
     c76:	39 f4       	brne	.+14     	; 0xc86 <__pack_f+0x144>
     c78:	e7 fe       	sbrs	r14, 7
     c7a:	0d c0       	rjmp	.+26     	; 0xc96 <__pack_f+0x154>
     c7c:	80 e4       	ldi	r24, 0x40	; 64
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	a0 e0       	ldi	r26, 0x00	; 0
     c82:	b0 e0       	ldi	r27, 0x00	; 0
     c84:	04 c0       	rjmp	.+8      	; 0xc8e <__pack_f+0x14c>
     c86:	8f e3       	ldi	r24, 0x3F	; 63
     c88:	90 e0       	ldi	r25, 0x00	; 0
     c8a:	a0 e0       	ldi	r26, 0x00	; 0
     c8c:	b0 e0       	ldi	r27, 0x00	; 0
     c8e:	e8 0e       	add	r14, r24
     c90:	f9 1e       	adc	r15, r25
     c92:	0a 1f       	adc	r16, r26
     c94:	1b 1f       	adc	r17, r27
     c96:	17 ff       	sbrs	r17, 7
     c98:	05 c0       	rjmp	.+10     	; 0xca4 <__pack_f+0x162>
     c9a:	16 95       	lsr	r17
     c9c:	07 95       	ror	r16
     c9e:	f7 94       	ror	r15
     ca0:	e7 94       	ror	r14
     ca2:	31 96       	adiw	r30, 0x01	; 1
     ca4:	87 e0       	ldi	r24, 0x07	; 7
     ca6:	16 95       	lsr	r17
     ca8:	07 95       	ror	r16
     caa:	f7 94       	ror	r15
     cac:	e7 94       	ror	r14
     cae:	8a 95       	dec	r24
     cb0:	d1 f7       	brne	.-12     	; 0xca6 <__pack_f+0x164>
     cb2:	05 c0       	rjmp	.+10     	; 0xcbe <__pack_f+0x17c>
     cb4:	ee 24       	eor	r14, r14
     cb6:	ff 24       	eor	r15, r15
     cb8:	87 01       	movw	r16, r14
     cba:	ef ef       	ldi	r30, 0xFF	; 255
     cbc:	f0 e0       	ldi	r31, 0x00	; 0
     cbe:	6e 2f       	mov	r22, r30
     cc0:	67 95       	ror	r22
     cc2:	66 27       	eor	r22, r22
     cc4:	67 95       	ror	r22
     cc6:	90 2f       	mov	r25, r16
     cc8:	9f 77       	andi	r25, 0x7F	; 127
     cca:	d7 94       	ror	r13
     ccc:	dd 24       	eor	r13, r13
     cce:	d7 94       	ror	r13
     cd0:	8e 2f       	mov	r24, r30
     cd2:	86 95       	lsr	r24
     cd4:	49 2f       	mov	r20, r25
     cd6:	46 2b       	or	r20, r22
     cd8:	58 2f       	mov	r21, r24
     cda:	5d 29       	or	r21, r13
     cdc:	b7 01       	movw	r22, r14
     cde:	ca 01       	movw	r24, r20
     ce0:	1f 91       	pop	r17
     ce2:	0f 91       	pop	r16
     ce4:	ff 90       	pop	r15
     ce6:	ef 90       	pop	r14
     ce8:	df 90       	pop	r13
     cea:	08 95       	ret

00000cec <__unpack_f>:
     cec:	fc 01       	movw	r30, r24
     cee:	db 01       	movw	r26, r22
     cf0:	40 81       	ld	r20, Z
     cf2:	51 81       	ldd	r21, Z+1	; 0x01
     cf4:	22 81       	ldd	r18, Z+2	; 0x02
     cf6:	62 2f       	mov	r22, r18
     cf8:	6f 77       	andi	r22, 0x7F	; 127
     cfa:	70 e0       	ldi	r23, 0x00	; 0
     cfc:	22 1f       	adc	r18, r18
     cfe:	22 27       	eor	r18, r18
     d00:	22 1f       	adc	r18, r18
     d02:	93 81       	ldd	r25, Z+3	; 0x03
     d04:	89 2f       	mov	r24, r25
     d06:	88 0f       	add	r24, r24
     d08:	82 2b       	or	r24, r18
     d0a:	28 2f       	mov	r18, r24
     d0c:	30 e0       	ldi	r19, 0x00	; 0
     d0e:	99 1f       	adc	r25, r25
     d10:	99 27       	eor	r25, r25
     d12:	99 1f       	adc	r25, r25
     d14:	11 96       	adiw	r26, 0x01	; 1
     d16:	9c 93       	st	X, r25
     d18:	11 97       	sbiw	r26, 0x01	; 1
     d1a:	21 15       	cp	r18, r1
     d1c:	31 05       	cpc	r19, r1
     d1e:	a9 f5       	brne	.+106    	; 0xd8a <__unpack_f+0x9e>
     d20:	41 15       	cp	r20, r1
     d22:	51 05       	cpc	r21, r1
     d24:	61 05       	cpc	r22, r1
     d26:	71 05       	cpc	r23, r1
     d28:	11 f4       	brne	.+4      	; 0xd2e <__unpack_f+0x42>
     d2a:	82 e0       	ldi	r24, 0x02	; 2
     d2c:	37 c0       	rjmp	.+110    	; 0xd9c <__unpack_f+0xb0>
     d2e:	82 e8       	ldi	r24, 0x82	; 130
     d30:	9f ef       	ldi	r25, 0xFF	; 255
     d32:	13 96       	adiw	r26, 0x03	; 3
     d34:	9c 93       	st	X, r25
     d36:	8e 93       	st	-X, r24
     d38:	12 97       	sbiw	r26, 0x02	; 2
     d3a:	9a 01       	movw	r18, r20
     d3c:	ab 01       	movw	r20, r22
     d3e:	67 e0       	ldi	r22, 0x07	; 7
     d40:	22 0f       	add	r18, r18
     d42:	33 1f       	adc	r19, r19
     d44:	44 1f       	adc	r20, r20
     d46:	55 1f       	adc	r21, r21
     d48:	6a 95       	dec	r22
     d4a:	d1 f7       	brne	.-12     	; 0xd40 <__unpack_f+0x54>
     d4c:	83 e0       	ldi	r24, 0x03	; 3
     d4e:	8c 93       	st	X, r24
     d50:	0d c0       	rjmp	.+26     	; 0xd6c <__unpack_f+0x80>
     d52:	22 0f       	add	r18, r18
     d54:	33 1f       	adc	r19, r19
     d56:	44 1f       	adc	r20, r20
     d58:	55 1f       	adc	r21, r21
     d5a:	12 96       	adiw	r26, 0x02	; 2
     d5c:	8d 91       	ld	r24, X+
     d5e:	9c 91       	ld	r25, X
     d60:	13 97       	sbiw	r26, 0x03	; 3
     d62:	01 97       	sbiw	r24, 0x01	; 1
     d64:	13 96       	adiw	r26, 0x03	; 3
     d66:	9c 93       	st	X, r25
     d68:	8e 93       	st	-X, r24
     d6a:	12 97       	sbiw	r26, 0x02	; 2
     d6c:	20 30       	cpi	r18, 0x00	; 0
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	38 07       	cpc	r19, r24
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	48 07       	cpc	r20, r24
     d76:	80 e4       	ldi	r24, 0x40	; 64
     d78:	58 07       	cpc	r21, r24
     d7a:	58 f3       	brcs	.-42     	; 0xd52 <__unpack_f+0x66>
     d7c:	14 96       	adiw	r26, 0x04	; 4
     d7e:	2d 93       	st	X+, r18
     d80:	3d 93       	st	X+, r19
     d82:	4d 93       	st	X+, r20
     d84:	5c 93       	st	X, r21
     d86:	17 97       	sbiw	r26, 0x07	; 7
     d88:	08 95       	ret
     d8a:	2f 3f       	cpi	r18, 0xFF	; 255
     d8c:	31 05       	cpc	r19, r1
     d8e:	79 f4       	brne	.+30     	; 0xdae <__unpack_f+0xc2>
     d90:	41 15       	cp	r20, r1
     d92:	51 05       	cpc	r21, r1
     d94:	61 05       	cpc	r22, r1
     d96:	71 05       	cpc	r23, r1
     d98:	19 f4       	brne	.+6      	; 0xda0 <__unpack_f+0xb4>
     d9a:	84 e0       	ldi	r24, 0x04	; 4
     d9c:	8c 93       	st	X, r24
     d9e:	08 95       	ret
     da0:	64 ff       	sbrs	r22, 4
     da2:	03 c0       	rjmp	.+6      	; 0xdaa <__unpack_f+0xbe>
     da4:	81 e0       	ldi	r24, 0x01	; 1
     da6:	8c 93       	st	X, r24
     da8:	12 c0       	rjmp	.+36     	; 0xdce <__unpack_f+0xe2>
     daa:	1c 92       	st	X, r1
     dac:	10 c0       	rjmp	.+32     	; 0xdce <__unpack_f+0xe2>
     dae:	2f 57       	subi	r18, 0x7F	; 127
     db0:	30 40       	sbci	r19, 0x00	; 0
     db2:	13 96       	adiw	r26, 0x03	; 3
     db4:	3c 93       	st	X, r19
     db6:	2e 93       	st	-X, r18
     db8:	12 97       	sbiw	r26, 0x02	; 2
     dba:	83 e0       	ldi	r24, 0x03	; 3
     dbc:	8c 93       	st	X, r24
     dbe:	87 e0       	ldi	r24, 0x07	; 7
     dc0:	44 0f       	add	r20, r20
     dc2:	55 1f       	adc	r21, r21
     dc4:	66 1f       	adc	r22, r22
     dc6:	77 1f       	adc	r23, r23
     dc8:	8a 95       	dec	r24
     dca:	d1 f7       	brne	.-12     	; 0xdc0 <__unpack_f+0xd4>
     dcc:	70 64       	ori	r23, 0x40	; 64
     dce:	14 96       	adiw	r26, 0x04	; 4
     dd0:	4d 93       	st	X+, r20
     dd2:	5d 93       	st	X+, r21
     dd4:	6d 93       	st	X+, r22
     dd6:	7c 93       	st	X, r23
     dd8:	17 97       	sbiw	r26, 0x07	; 7
     dda:	08 95       	ret

00000ddc <__fpcmp_parts_f>:
     ddc:	1f 93       	push	r17
     dde:	dc 01       	movw	r26, r24
     de0:	fb 01       	movw	r30, r22
     de2:	9c 91       	ld	r25, X
     de4:	92 30       	cpi	r25, 0x02	; 2
     de6:	08 f4       	brcc	.+2      	; 0xdea <__fpcmp_parts_f+0xe>
     de8:	47 c0       	rjmp	.+142    	; 0xe78 <__fpcmp_parts_f+0x9c>
     dea:	80 81       	ld	r24, Z
     dec:	82 30       	cpi	r24, 0x02	; 2
     dee:	08 f4       	brcc	.+2      	; 0xdf2 <__fpcmp_parts_f+0x16>
     df0:	43 c0       	rjmp	.+134    	; 0xe78 <__fpcmp_parts_f+0x9c>
     df2:	94 30       	cpi	r25, 0x04	; 4
     df4:	51 f4       	brne	.+20     	; 0xe0a <__fpcmp_parts_f+0x2e>
     df6:	11 96       	adiw	r26, 0x01	; 1
     df8:	1c 91       	ld	r17, X
     dfa:	84 30       	cpi	r24, 0x04	; 4
     dfc:	99 f5       	brne	.+102    	; 0xe64 <__fpcmp_parts_f+0x88>
     dfe:	81 81       	ldd	r24, Z+1	; 0x01
     e00:	68 2f       	mov	r22, r24
     e02:	70 e0       	ldi	r23, 0x00	; 0
     e04:	61 1b       	sub	r22, r17
     e06:	71 09       	sbc	r23, r1
     e08:	3f c0       	rjmp	.+126    	; 0xe88 <__fpcmp_parts_f+0xac>
     e0a:	84 30       	cpi	r24, 0x04	; 4
     e0c:	21 f0       	breq	.+8      	; 0xe16 <__fpcmp_parts_f+0x3a>
     e0e:	92 30       	cpi	r25, 0x02	; 2
     e10:	31 f4       	brne	.+12     	; 0xe1e <__fpcmp_parts_f+0x42>
     e12:	82 30       	cpi	r24, 0x02	; 2
     e14:	b9 f1       	breq	.+110    	; 0xe84 <__fpcmp_parts_f+0xa8>
     e16:	81 81       	ldd	r24, Z+1	; 0x01
     e18:	88 23       	and	r24, r24
     e1a:	89 f1       	breq	.+98     	; 0xe7e <__fpcmp_parts_f+0xa2>
     e1c:	2d c0       	rjmp	.+90     	; 0xe78 <__fpcmp_parts_f+0x9c>
     e1e:	11 96       	adiw	r26, 0x01	; 1
     e20:	1c 91       	ld	r17, X
     e22:	11 97       	sbiw	r26, 0x01	; 1
     e24:	82 30       	cpi	r24, 0x02	; 2
     e26:	f1 f0       	breq	.+60     	; 0xe64 <__fpcmp_parts_f+0x88>
     e28:	81 81       	ldd	r24, Z+1	; 0x01
     e2a:	18 17       	cp	r17, r24
     e2c:	d9 f4       	brne	.+54     	; 0xe64 <__fpcmp_parts_f+0x88>
     e2e:	12 96       	adiw	r26, 0x02	; 2
     e30:	2d 91       	ld	r18, X+
     e32:	3c 91       	ld	r19, X
     e34:	13 97       	sbiw	r26, 0x03	; 3
     e36:	82 81       	ldd	r24, Z+2	; 0x02
     e38:	93 81       	ldd	r25, Z+3	; 0x03
     e3a:	82 17       	cp	r24, r18
     e3c:	93 07       	cpc	r25, r19
     e3e:	94 f0       	brlt	.+36     	; 0xe64 <__fpcmp_parts_f+0x88>
     e40:	28 17       	cp	r18, r24
     e42:	39 07       	cpc	r19, r25
     e44:	bc f0       	brlt	.+46     	; 0xe74 <__fpcmp_parts_f+0x98>
     e46:	14 96       	adiw	r26, 0x04	; 4
     e48:	8d 91       	ld	r24, X+
     e4a:	9d 91       	ld	r25, X+
     e4c:	0d 90       	ld	r0, X+
     e4e:	bc 91       	ld	r27, X
     e50:	a0 2d       	mov	r26, r0
     e52:	24 81       	ldd	r18, Z+4	; 0x04
     e54:	35 81       	ldd	r19, Z+5	; 0x05
     e56:	46 81       	ldd	r20, Z+6	; 0x06
     e58:	57 81       	ldd	r21, Z+7	; 0x07
     e5a:	28 17       	cp	r18, r24
     e5c:	39 07       	cpc	r19, r25
     e5e:	4a 07       	cpc	r20, r26
     e60:	5b 07       	cpc	r21, r27
     e62:	18 f4       	brcc	.+6      	; 0xe6a <__fpcmp_parts_f+0x8e>
     e64:	11 23       	and	r17, r17
     e66:	41 f0       	breq	.+16     	; 0xe78 <__fpcmp_parts_f+0x9c>
     e68:	0a c0       	rjmp	.+20     	; 0xe7e <__fpcmp_parts_f+0xa2>
     e6a:	82 17       	cp	r24, r18
     e6c:	93 07       	cpc	r25, r19
     e6e:	a4 07       	cpc	r26, r20
     e70:	b5 07       	cpc	r27, r21
     e72:	40 f4       	brcc	.+16     	; 0xe84 <__fpcmp_parts_f+0xa8>
     e74:	11 23       	and	r17, r17
     e76:	19 f0       	breq	.+6      	; 0xe7e <__fpcmp_parts_f+0xa2>
     e78:	61 e0       	ldi	r22, 0x01	; 1
     e7a:	70 e0       	ldi	r23, 0x00	; 0
     e7c:	05 c0       	rjmp	.+10     	; 0xe88 <__fpcmp_parts_f+0xac>
     e7e:	6f ef       	ldi	r22, 0xFF	; 255
     e80:	7f ef       	ldi	r23, 0xFF	; 255
     e82:	02 c0       	rjmp	.+4      	; 0xe88 <__fpcmp_parts_f+0xac>
     e84:	60 e0       	ldi	r22, 0x00	; 0
     e86:	70 e0       	ldi	r23, 0x00	; 0
     e88:	cb 01       	movw	r24, r22
     e8a:	1f 91       	pop	r17
     e8c:	08 95       	ret

00000e8e <TIMER0_VidInit>:

void (*TIMER0_CallBack)(void);

/*Timer0 Initialization*/
void TIMER0_VidInit(void)
{
     e8e:	df 93       	push	r29
     e90:	cf 93       	push	r28
     e92:	cd b7       	in	r28, 0x3d	; 61
     e94:	de b7       	in	r29, 0x3e	; 62
	/*Select the suitable Prescaler */
	TCCR0&=0xF8;
     e96:	a3 e5       	ldi	r26, 0x53	; 83
     e98:	b0 e0       	ldi	r27, 0x00	; 0
     e9a:	e3 e5       	ldi	r30, 0x53	; 83
     e9c:	f0 e0       	ldi	r31, 0x00	; 0
     e9e:	80 81       	ld	r24, Z
     ea0:	88 7f       	andi	r24, 0xF8	; 248
     ea2:	8c 93       	st	X, r24
	TCCR0|=TIMER_SET_PRESCALER;
     ea4:	a3 e5       	ldi	r26, 0x53	; 83
     ea6:	b0 e0       	ldi	r27, 0x00	; 0
     ea8:	e3 e5       	ldi	r30, 0x53	; 83
     eaa:	f0 e0       	ldi	r31, 0x00	; 0
     eac:	80 81       	ld	r24, Z
     eae:	84 60       	ori	r24, 0x04	; 4
     eb0:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,3);
	/*Timer Overflow Interrupt Enable*/
	SET_BIT(TIMSK,0);

#elif TIMER0_SET_MODE == TIMER0_CTC_MODE
	CLR_BIT(TCCR0,6);
     eb2:	a3 e5       	ldi	r26, 0x53	; 83
     eb4:	b0 e0       	ldi	r27, 0x00	; 0
     eb6:	e3 e5       	ldi	r30, 0x53	; 83
     eb8:	f0 e0       	ldi	r31, 0x00	; 0
     eba:	80 81       	ld	r24, Z
     ebc:	8f 7b       	andi	r24, 0xBF	; 191
     ebe:	8c 93       	st	X, r24
	SET_BIT(TCCR0,3);
     ec0:	a3 e5       	ldi	r26, 0x53	; 83
     ec2:	b0 e0       	ldi	r27, 0x00	; 0
     ec4:	e3 e5       	ldi	r30, 0x53	; 83
     ec6:	f0 e0       	ldi	r31, 0x00	; 0
     ec8:	80 81       	ld	r24, Z
     eca:	88 60       	ori	r24, 0x08	; 8
     ecc:	8c 93       	st	X, r24
#if TIMER0_SET_CTC_INTERRUPT == TIMER0_CTC_INTERRUPT_ENABLED
	SET_BIT(TIMSK,1);
     ece:	a9 e5       	ldi	r26, 0x59	; 89
     ed0:	b0 e0       	ldi	r27, 0x00	; 0
     ed2:	e9 e5       	ldi	r30, 0x59	; 89
     ed4:	f0 e0       	ldi	r31, 0x00	; 0
     ed6:	80 81       	ld	r24, Z
     ed8:	82 60       	ori	r24, 0x02	; 2
     eda:	8c 93       	st	X, r24
	CLR_BIT(TIMSK,1);
#else
#error "TIMER0 CTC Interrupt Mode is not valid..."
#endif
#if TIMER0_SET_OC0_PIN_MODE == TIMER0_OC0_PIN_DISCONNECTED
	CLR_BIT(TCCR0,5);
     edc:	a3 e5       	ldi	r26, 0x53	; 83
     ede:	b0 e0       	ldi	r27, 0x00	; 0
     ee0:	e3 e5       	ldi	r30, 0x53	; 83
     ee2:	f0 e0       	ldi	r31, 0x00	; 0
     ee4:	80 81       	ld	r24, Z
     ee6:	8f 7d       	andi	r24, 0xDF	; 223
     ee8:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,4);
     eea:	a3 e5       	ldi	r26, 0x53	; 83
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	e3 e5       	ldi	r30, 0x53	; 83
     ef0:	f0 e0       	ldi	r31, 0x00	; 0
     ef2:	80 81       	ld	r24, Z
     ef4:	8f 7e       	andi	r24, 0xEF	; 239
     ef6:	8c 93       	st	X, r24
#endif
#else
#error "TIMER0 Mode is not valid..."
#endif

}
     ef8:	cf 91       	pop	r28
     efa:	df 91       	pop	r29
     efc:	08 95       	ret

00000efe <TIMER0_VidSetPreload>:
/*Set Preload Function*/
void TIMER0_VidSetPreload(u8 Copy_u8Preload)
{
     efe:	df 93       	push	r29
     f00:	cf 93       	push	r28
     f02:	0f 92       	push	r0
     f04:	cd b7       	in	r28, 0x3d	; 61
     f06:	de b7       	in	r29, 0x3e	; 62
     f08:	89 83       	std	Y+1, r24	; 0x01
	TCNT0=Copy_u8Preload;
     f0a:	e2 e5       	ldi	r30, 0x52	; 82
     f0c:	f0 e0       	ldi	r31, 0x00	; 0
     f0e:	89 81       	ldd	r24, Y+1	; 0x01
     f10:	80 83       	st	Z, r24
}
     f12:	0f 90       	pop	r0
     f14:	cf 91       	pop	r28
     f16:	df 91       	pop	r29
     f18:	08 95       	ret

00000f1a <TIMER0_VidSetCTCValue>:
/*Set CTC Value Function*/
void TIMER0_VidSetCTCValue(u8 Copy_u8CTCValue)
{
     f1a:	df 93       	push	r29
     f1c:	cf 93       	push	r28
     f1e:	0f 92       	push	r0
     f20:	cd b7       	in	r28, 0x3d	; 61
     f22:	de b7       	in	r29, 0x3e	; 62
     f24:	89 83       	std	Y+1, r24	; 0x01
	OCR0=Copy_u8CTCValue;
     f26:	ec e5       	ldi	r30, 0x5C	; 92
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	89 81       	ldd	r24, Y+1	; 0x01
     f2c:	80 83       	st	Z, r24
}
     f2e:	0f 90       	pop	r0
     f30:	cf 91       	pop	r28
     f32:	df 91       	pop	r29
     f34:	08 95       	ret

00000f36 <TIMER0_VidOVF_SetCallBack>:
void TIMER0_VidOVF_SetCallBack(void(*Copy_VidCallBack)(void))
{
     f36:	df 93       	push	r29
     f38:	cf 93       	push	r28
     f3a:	00 d0       	rcall	.+0      	; 0xf3c <TIMER0_VidOVF_SetCallBack+0x6>
     f3c:	cd b7       	in	r28, 0x3d	; 61
     f3e:	de b7       	in	r29, 0x3e	; 62
     f40:	9a 83       	std	Y+2, r25	; 0x02
     f42:	89 83       	std	Y+1, r24	; 0x01
	TIMER0_CallBack=Copy_VidCallBack;
     f44:	89 81       	ldd	r24, Y+1	; 0x01
     f46:	9a 81       	ldd	r25, Y+2	; 0x02
     f48:	90 93 56 07 	sts	0x0756, r25
     f4c:	80 93 55 07 	sts	0x0755, r24
}
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	cf 91       	pop	r28
     f56:	df 91       	pop	r29
     f58:	08 95       	ret

00000f5a <TIMER0_VidCTC_SetCallBack>:
void TIMER0_VidCTC_SetCallBack(void(*Copy_VidCallBack)(void))
{
     f5a:	df 93       	push	r29
     f5c:	cf 93       	push	r28
     f5e:	00 d0       	rcall	.+0      	; 0xf60 <TIMER0_VidCTC_SetCallBack+0x6>
     f60:	cd b7       	in	r28, 0x3d	; 61
     f62:	de b7       	in	r29, 0x3e	; 62
     f64:	9a 83       	std	Y+2, r25	; 0x02
     f66:	89 83       	std	Y+1, r24	; 0x01
	TIMER0_CallBack=Copy_VidCallBack;
     f68:	89 81       	ldd	r24, Y+1	; 0x01
     f6a:	9a 81       	ldd	r25, Y+2	; 0x02
     f6c:	90 93 56 07 	sts	0x0756, r25
     f70:	80 93 55 07 	sts	0x0755, r24
}
     f74:	0f 90       	pop	r0
     f76:	0f 90       	pop	r0
     f78:	cf 91       	pop	r28
     f7a:	df 91       	pop	r29
     f7c:	08 95       	ret

00000f7e <__vector_11>:
void __vector_11(void)   __attribute__((signal));
void __vector_11(void)
{
     f7e:	1f 92       	push	r1
     f80:	0f 92       	push	r0
     f82:	0f b6       	in	r0, 0x3f	; 63
     f84:	0f 92       	push	r0
     f86:	11 24       	eor	r1, r1
     f88:	2f 93       	push	r18
     f8a:	3f 93       	push	r19
     f8c:	4f 93       	push	r20
     f8e:	5f 93       	push	r21
     f90:	6f 93       	push	r22
     f92:	7f 93       	push	r23
     f94:	8f 93       	push	r24
     f96:	9f 93       	push	r25
     f98:	af 93       	push	r26
     f9a:	bf 93       	push	r27
     f9c:	ef 93       	push	r30
     f9e:	ff 93       	push	r31
     fa0:	df 93       	push	r29
     fa2:	cf 93       	push	r28
     fa4:	cd b7       	in	r28, 0x3d	; 61
     fa6:	de b7       	in	r29, 0x3e	; 62
	TIMER0_CallBack();
     fa8:	e0 91 55 07 	lds	r30, 0x0755
     fac:	f0 91 56 07 	lds	r31, 0x0756
     fb0:	09 95       	icall
}
     fb2:	cf 91       	pop	r28
     fb4:	df 91       	pop	r29
     fb6:	ff 91       	pop	r31
     fb8:	ef 91       	pop	r30
     fba:	bf 91       	pop	r27
     fbc:	af 91       	pop	r26
     fbe:	9f 91       	pop	r25
     fc0:	8f 91       	pop	r24
     fc2:	7f 91       	pop	r23
     fc4:	6f 91       	pop	r22
     fc6:	5f 91       	pop	r21
     fc8:	4f 91       	pop	r20
     fca:	3f 91       	pop	r19
     fcc:	2f 91       	pop	r18
     fce:	0f 90       	pop	r0
     fd0:	0f be       	out	0x3f, r0	; 63
     fd2:	0f 90       	pop	r0
     fd4:	1f 90       	pop	r1
     fd6:	18 95       	reti

00000fd8 <__vector_10>:
void __vector_10(void)   __attribute__((signal));
void __vector_10(void)
{
     fd8:	1f 92       	push	r1
     fda:	0f 92       	push	r0
     fdc:	0f b6       	in	r0, 0x3f	; 63
     fde:	0f 92       	push	r0
     fe0:	11 24       	eor	r1, r1
     fe2:	2f 93       	push	r18
     fe4:	3f 93       	push	r19
     fe6:	4f 93       	push	r20
     fe8:	5f 93       	push	r21
     fea:	6f 93       	push	r22
     fec:	7f 93       	push	r23
     fee:	8f 93       	push	r24
     ff0:	9f 93       	push	r25
     ff2:	af 93       	push	r26
     ff4:	bf 93       	push	r27
     ff6:	ef 93       	push	r30
     ff8:	ff 93       	push	r31
     ffa:	df 93       	push	r29
     ffc:	cf 93       	push	r28
     ffe:	cd b7       	in	r28, 0x3d	; 61
    1000:	de b7       	in	r29, 0x3e	; 62
	TIMER0_CallBack();
    1002:	e0 91 55 07 	lds	r30, 0x0755
    1006:	f0 91 56 07 	lds	r31, 0x0756
    100a:	09 95       	icall
}
    100c:	cf 91       	pop	r28
    100e:	df 91       	pop	r29
    1010:	ff 91       	pop	r31
    1012:	ef 91       	pop	r30
    1014:	bf 91       	pop	r27
    1016:	af 91       	pop	r26
    1018:	9f 91       	pop	r25
    101a:	8f 91       	pop	r24
    101c:	7f 91       	pop	r23
    101e:	6f 91       	pop	r22
    1020:	5f 91       	pop	r21
    1022:	4f 91       	pop	r20
    1024:	3f 91       	pop	r19
    1026:	2f 91       	pop	r18
    1028:	0f 90       	pop	r0
    102a:	0f be       	out	0x3f, r0	; 63
    102c:	0f 90       	pop	r0
    102e:	1f 90       	pop	r1
    1030:	18 95       	reti

00001032 <MGIE_VidEnable>:

#include"MGIE_Private.h"

/*GIE Enable Function*/
void MGIE_VidEnable(void)
{
    1032:	df 93       	push	r29
    1034:	cf 93       	push	r28
    1036:	cd b7       	in	r28, 0x3d	; 61
    1038:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,7);
    103a:	af e5       	ldi	r26, 0x5F	; 95
    103c:	b0 e0       	ldi	r27, 0x00	; 0
    103e:	ef e5       	ldi	r30, 0x5F	; 95
    1040:	f0 e0       	ldi	r31, 0x00	; 0
    1042:	80 81       	ld	r24, Z
    1044:	80 68       	ori	r24, 0x80	; 128
    1046:	8c 93       	st	X, r24
}
    1048:	cf 91       	pop	r28
    104a:	df 91       	pop	r29
    104c:	08 95       	ret

0000104e <MGIE_VidDisable>:
/*GIE Disable Function*/
void MGIE_VidDisable(void)
{
    104e:	df 93       	push	r29
    1050:	cf 93       	push	r28
    1052:	cd b7       	in	r28, 0x3d	; 61
    1054:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,7);
    1056:	af e5       	ldi	r26, 0x5F	; 95
    1058:	b0 e0       	ldi	r27, 0x00	; 0
    105a:	ef e5       	ldi	r30, 0x5F	; 95
    105c:	f0 e0       	ldi	r31, 0x00	; 0
    105e:	80 81       	ld	r24, Z
    1060:	8f 77       	andi	r24, 0x7F	; 127
    1062:	8c 93       	st	X, r24
}
    1064:	cf 91       	pop	r28
    1066:	df 91       	pop	r29
    1068:	08 95       	ret

0000106a <MDIO_Error_State_SetPinDirection>:
#include"MDIO_Private.h"
#include"MDIO_Interface.h"

/*Set Pin Direction Function */
Error_State MDIO_Error_State_SetPinDirection(u8 Copy_u8PinNumber,u8  Copy_u8PortNumber,u8 Copy_u8PinDirection)
{
    106a:	df 93       	push	r29
    106c:	cf 93       	push	r28
    106e:	00 d0       	rcall	.+0      	; 0x1070 <MDIO_Error_State_SetPinDirection+0x6>
    1070:	00 d0       	rcall	.+0      	; 0x1072 <MDIO_Error_State_SetPinDirection+0x8>
    1072:	00 d0       	rcall	.+0      	; 0x1074 <MDIO_Error_State_SetPinDirection+0xa>
    1074:	cd b7       	in	r28, 0x3d	; 61
    1076:	de b7       	in	r29, 0x3e	; 62
    1078:	8a 83       	std	Y+2, r24	; 0x02
    107a:	6b 83       	std	Y+3, r22	; 0x03
    107c:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    1082:	8a 81       	ldd	r24, Y+2	; 0x02
    1084:	88 30       	cpi	r24, 0x08	; 8
    1086:	08 f0       	brcs	.+2      	; 0x108a <MDIO_Error_State_SetPinDirection+0x20>
    1088:	e8 c0       	rjmp	.+464    	; 0x125a <MDIO_Error_State_SetPinDirection+0x1f0>
	{
		switch(Copy_u8PortNumber)
    108a:	8b 81       	ldd	r24, Y+3	; 0x03
    108c:	28 2f       	mov	r18, r24
    108e:	30 e0       	ldi	r19, 0x00	; 0
    1090:	3e 83       	std	Y+6, r19	; 0x06
    1092:	2d 83       	std	Y+5, r18	; 0x05
    1094:	8d 81       	ldd	r24, Y+5	; 0x05
    1096:	9e 81       	ldd	r25, Y+6	; 0x06
    1098:	81 30       	cpi	r24, 0x01	; 1
    109a:	91 05       	cpc	r25, r1
    109c:	09 f4       	brne	.+2      	; 0x10a0 <MDIO_Error_State_SetPinDirection+0x36>
    109e:	48 c0       	rjmp	.+144    	; 0x1130 <MDIO_Error_State_SetPinDirection+0xc6>
    10a0:	2d 81       	ldd	r18, Y+5	; 0x05
    10a2:	3e 81       	ldd	r19, Y+6	; 0x06
    10a4:	22 30       	cpi	r18, 0x02	; 2
    10a6:	31 05       	cpc	r19, r1
    10a8:	2c f4       	brge	.+10     	; 0x10b4 <MDIO_Error_State_SetPinDirection+0x4a>
    10aa:	8d 81       	ldd	r24, Y+5	; 0x05
    10ac:	9e 81       	ldd	r25, Y+6	; 0x06
    10ae:	00 97       	sbiw	r24, 0x00	; 0
    10b0:	71 f0       	breq	.+28     	; 0x10ce <MDIO_Error_State_SetPinDirection+0x64>
    10b2:	d1 c0       	rjmp	.+418    	; 0x1256 <MDIO_Error_State_SetPinDirection+0x1ec>
    10b4:	2d 81       	ldd	r18, Y+5	; 0x05
    10b6:	3e 81       	ldd	r19, Y+6	; 0x06
    10b8:	22 30       	cpi	r18, 0x02	; 2
    10ba:	31 05       	cpc	r19, r1
    10bc:	09 f4       	brne	.+2      	; 0x10c0 <MDIO_Error_State_SetPinDirection+0x56>
    10be:	69 c0       	rjmp	.+210    	; 0x1192 <MDIO_Error_State_SetPinDirection+0x128>
    10c0:	8d 81       	ldd	r24, Y+5	; 0x05
    10c2:	9e 81       	ldd	r25, Y+6	; 0x06
    10c4:	83 30       	cpi	r24, 0x03	; 3
    10c6:	91 05       	cpc	r25, r1
    10c8:	09 f4       	brne	.+2      	; 0x10cc <MDIO_Error_State_SetPinDirection+0x62>
    10ca:	94 c0       	rjmp	.+296    	; 0x11f4 <MDIO_Error_State_SetPinDirection+0x18a>
    10cc:	c4 c0       	rjmp	.+392    	; 0x1256 <MDIO_Error_State_SetPinDirection+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    10ce:	8c 81       	ldd	r24, Y+4	; 0x04
    10d0:	81 30       	cpi	r24, 0x01	; 1
    10d2:	a1 f4       	brne	.+40     	; 0x10fc <MDIO_Error_State_SetPinDirection+0x92>
			{
				SET_BIT(DDRA,Copy_u8PinNumber);
    10d4:	aa e3       	ldi	r26, 0x3A	; 58
    10d6:	b0 e0       	ldi	r27, 0x00	; 0
    10d8:	ea e3       	ldi	r30, 0x3A	; 58
    10da:	f0 e0       	ldi	r31, 0x00	; 0
    10dc:	80 81       	ld	r24, Z
    10de:	48 2f       	mov	r20, r24
    10e0:	8a 81       	ldd	r24, Y+2	; 0x02
    10e2:	28 2f       	mov	r18, r24
    10e4:	30 e0       	ldi	r19, 0x00	; 0
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	02 2e       	mov	r0, r18
    10ec:	02 c0       	rjmp	.+4      	; 0x10f2 <MDIO_Error_State_SetPinDirection+0x88>
    10ee:	88 0f       	add	r24, r24
    10f0:	99 1f       	adc	r25, r25
    10f2:	0a 94       	dec	r0
    10f4:	e2 f7       	brpl	.-8      	; 0x10ee <MDIO_Error_State_SetPinDirection+0x84>
    10f6:	84 2b       	or	r24, r20
    10f8:	8c 93       	st	X, r24
    10fa:	b0 c0       	rjmp	.+352    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    10fc:	8c 81       	ldd	r24, Y+4	; 0x04
    10fe:	88 23       	and	r24, r24
    1100:	a9 f4       	brne	.+42     	; 0x112c <MDIO_Error_State_SetPinDirection+0xc2>
			{
				CLR_BIT(DDRA,Copy_u8PinNumber);
    1102:	aa e3       	ldi	r26, 0x3A	; 58
    1104:	b0 e0       	ldi	r27, 0x00	; 0
    1106:	ea e3       	ldi	r30, 0x3A	; 58
    1108:	f0 e0       	ldi	r31, 0x00	; 0
    110a:	80 81       	ld	r24, Z
    110c:	48 2f       	mov	r20, r24
    110e:	8a 81       	ldd	r24, Y+2	; 0x02
    1110:	28 2f       	mov	r18, r24
    1112:	30 e0       	ldi	r19, 0x00	; 0
    1114:	81 e0       	ldi	r24, 0x01	; 1
    1116:	90 e0       	ldi	r25, 0x00	; 0
    1118:	02 2e       	mov	r0, r18
    111a:	02 c0       	rjmp	.+4      	; 0x1120 <MDIO_Error_State_SetPinDirection+0xb6>
    111c:	88 0f       	add	r24, r24
    111e:	99 1f       	adc	r25, r25
    1120:	0a 94       	dec	r0
    1122:	e2 f7       	brpl	.-8      	; 0x111c <MDIO_Error_State_SetPinDirection+0xb2>
    1124:	80 95       	com	r24
    1126:	84 23       	and	r24, r20
    1128:	8c 93       	st	X, r24
    112a:	98 c0       	rjmp	.+304    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    112c:	19 82       	std	Y+1, r1	; 0x01
    112e:	96 c0       	rjmp	.+300    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1130:	8c 81       	ldd	r24, Y+4	; 0x04
    1132:	81 30       	cpi	r24, 0x01	; 1
    1134:	a1 f4       	brne	.+40     	; 0x115e <MDIO_Error_State_SetPinDirection+0xf4>
			{
				SET_BIT(DDRB,Copy_u8PinNumber);
    1136:	a7 e3       	ldi	r26, 0x37	; 55
    1138:	b0 e0       	ldi	r27, 0x00	; 0
    113a:	e7 e3       	ldi	r30, 0x37	; 55
    113c:	f0 e0       	ldi	r31, 0x00	; 0
    113e:	80 81       	ld	r24, Z
    1140:	48 2f       	mov	r20, r24
    1142:	8a 81       	ldd	r24, Y+2	; 0x02
    1144:	28 2f       	mov	r18, r24
    1146:	30 e0       	ldi	r19, 0x00	; 0
    1148:	81 e0       	ldi	r24, 0x01	; 1
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	02 2e       	mov	r0, r18
    114e:	02 c0       	rjmp	.+4      	; 0x1154 <MDIO_Error_State_SetPinDirection+0xea>
    1150:	88 0f       	add	r24, r24
    1152:	99 1f       	adc	r25, r25
    1154:	0a 94       	dec	r0
    1156:	e2 f7       	brpl	.-8      	; 0x1150 <MDIO_Error_State_SetPinDirection+0xe6>
    1158:	84 2b       	or	r24, r20
    115a:	8c 93       	st	X, r24
    115c:	7f c0       	rjmp	.+254    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    115e:	8c 81       	ldd	r24, Y+4	; 0x04
    1160:	88 23       	and	r24, r24
    1162:	a9 f4       	brne	.+42     	; 0x118e <MDIO_Error_State_SetPinDirection+0x124>
			{
				CLR_BIT(DDRB,Copy_u8PinNumber);
    1164:	a7 e3       	ldi	r26, 0x37	; 55
    1166:	b0 e0       	ldi	r27, 0x00	; 0
    1168:	e7 e3       	ldi	r30, 0x37	; 55
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	80 81       	ld	r24, Z
    116e:	48 2f       	mov	r20, r24
    1170:	8a 81       	ldd	r24, Y+2	; 0x02
    1172:	28 2f       	mov	r18, r24
    1174:	30 e0       	ldi	r19, 0x00	; 0
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	90 e0       	ldi	r25, 0x00	; 0
    117a:	02 2e       	mov	r0, r18
    117c:	02 c0       	rjmp	.+4      	; 0x1182 <MDIO_Error_State_SetPinDirection+0x118>
    117e:	88 0f       	add	r24, r24
    1180:	99 1f       	adc	r25, r25
    1182:	0a 94       	dec	r0
    1184:	e2 f7       	brpl	.-8      	; 0x117e <MDIO_Error_State_SetPinDirection+0x114>
    1186:	80 95       	com	r24
    1188:	84 23       	and	r24, r20
    118a:	8c 93       	st	X, r24
    118c:	67 c0       	rjmp	.+206    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    118e:	19 82       	std	Y+1, r1	; 0x01
    1190:	65 c0       	rjmp	.+202    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1192:	8c 81       	ldd	r24, Y+4	; 0x04
    1194:	81 30       	cpi	r24, 0x01	; 1
    1196:	a1 f4       	brne	.+40     	; 0x11c0 <MDIO_Error_State_SetPinDirection+0x156>
			{
				SET_BIT(DDRC,Copy_u8PinNumber);
    1198:	a4 e3       	ldi	r26, 0x34	; 52
    119a:	b0 e0       	ldi	r27, 0x00	; 0
    119c:	e4 e3       	ldi	r30, 0x34	; 52
    119e:	f0 e0       	ldi	r31, 0x00	; 0
    11a0:	80 81       	ld	r24, Z
    11a2:	48 2f       	mov	r20, r24
    11a4:	8a 81       	ldd	r24, Y+2	; 0x02
    11a6:	28 2f       	mov	r18, r24
    11a8:	30 e0       	ldi	r19, 0x00	; 0
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	02 2e       	mov	r0, r18
    11b0:	02 c0       	rjmp	.+4      	; 0x11b6 <MDIO_Error_State_SetPinDirection+0x14c>
    11b2:	88 0f       	add	r24, r24
    11b4:	99 1f       	adc	r25, r25
    11b6:	0a 94       	dec	r0
    11b8:	e2 f7       	brpl	.-8      	; 0x11b2 <MDIO_Error_State_SetPinDirection+0x148>
    11ba:	84 2b       	or	r24, r20
    11bc:	8c 93       	st	X, r24
    11be:	4e c0       	rjmp	.+156    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    11c0:	8c 81       	ldd	r24, Y+4	; 0x04
    11c2:	88 23       	and	r24, r24
    11c4:	a9 f4       	brne	.+42     	; 0x11f0 <MDIO_Error_State_SetPinDirection+0x186>
			{
				CLR_BIT(DDRC,Copy_u8PinNumber);
    11c6:	a4 e3       	ldi	r26, 0x34	; 52
    11c8:	b0 e0       	ldi	r27, 0x00	; 0
    11ca:	e4 e3       	ldi	r30, 0x34	; 52
    11cc:	f0 e0       	ldi	r31, 0x00	; 0
    11ce:	80 81       	ld	r24, Z
    11d0:	48 2f       	mov	r20, r24
    11d2:	8a 81       	ldd	r24, Y+2	; 0x02
    11d4:	28 2f       	mov	r18, r24
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    11d8:	81 e0       	ldi	r24, 0x01	; 1
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	02 2e       	mov	r0, r18
    11de:	02 c0       	rjmp	.+4      	; 0x11e4 <MDIO_Error_State_SetPinDirection+0x17a>
    11e0:	88 0f       	add	r24, r24
    11e2:	99 1f       	adc	r25, r25
    11e4:	0a 94       	dec	r0
    11e6:	e2 f7       	brpl	.-8      	; 0x11e0 <MDIO_Error_State_SetPinDirection+0x176>
    11e8:	80 95       	com	r24
    11ea:	84 23       	and	r24, r20
    11ec:	8c 93       	st	X, r24
    11ee:	36 c0       	rjmp	.+108    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    11f0:	19 82       	std	Y+1, r1	; 0x01
    11f2:	34 c0       	rjmp	.+104    	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    11f4:	8c 81       	ldd	r24, Y+4	; 0x04
    11f6:	81 30       	cpi	r24, 0x01	; 1
    11f8:	a1 f4       	brne	.+40     	; 0x1222 <MDIO_Error_State_SetPinDirection+0x1b8>
			{
				SET_BIT(DDRD,Copy_u8PinNumber);
    11fa:	a1 e3       	ldi	r26, 0x31	; 49
    11fc:	b0 e0       	ldi	r27, 0x00	; 0
    11fe:	e1 e3       	ldi	r30, 0x31	; 49
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	80 81       	ld	r24, Z
    1204:	48 2f       	mov	r20, r24
    1206:	8a 81       	ldd	r24, Y+2	; 0x02
    1208:	28 2f       	mov	r18, r24
    120a:	30 e0       	ldi	r19, 0x00	; 0
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	90 e0       	ldi	r25, 0x00	; 0
    1210:	02 2e       	mov	r0, r18
    1212:	02 c0       	rjmp	.+4      	; 0x1218 <MDIO_Error_State_SetPinDirection+0x1ae>
    1214:	88 0f       	add	r24, r24
    1216:	99 1f       	adc	r25, r25
    1218:	0a 94       	dec	r0
    121a:	e2 f7       	brpl	.-8      	; 0x1214 <MDIO_Error_State_SetPinDirection+0x1aa>
    121c:	84 2b       	or	r24, r20
    121e:	8c 93       	st	X, r24
    1220:	1d c0       	rjmp	.+58     	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    1222:	8c 81       	ldd	r24, Y+4	; 0x04
    1224:	88 23       	and	r24, r24
    1226:	a9 f4       	brne	.+42     	; 0x1252 <MDIO_Error_State_SetPinDirection+0x1e8>
			{
				CLR_BIT(DDRD,Copy_u8PinNumber);
    1228:	a1 e3       	ldi	r26, 0x31	; 49
    122a:	b0 e0       	ldi	r27, 0x00	; 0
    122c:	e1 e3       	ldi	r30, 0x31	; 49
    122e:	f0 e0       	ldi	r31, 0x00	; 0
    1230:	80 81       	ld	r24, Z
    1232:	48 2f       	mov	r20, r24
    1234:	8a 81       	ldd	r24, Y+2	; 0x02
    1236:	28 2f       	mov	r18, r24
    1238:	30 e0       	ldi	r19, 0x00	; 0
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	90 e0       	ldi	r25, 0x00	; 0
    123e:	02 2e       	mov	r0, r18
    1240:	02 c0       	rjmp	.+4      	; 0x1246 <MDIO_Error_State_SetPinDirection+0x1dc>
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	0a 94       	dec	r0
    1248:	e2 f7       	brpl	.-8      	; 0x1242 <MDIO_Error_State_SetPinDirection+0x1d8>
    124a:	80 95       	com	r24
    124c:	84 23       	and	r24, r20
    124e:	8c 93       	st	X, r24
    1250:	05 c0       	rjmp	.+10     	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1252:	19 82       	std	Y+1, r1	; 0x01
    1254:	03 c0       	rjmp	.+6      	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1256:	19 82       	std	Y+1, r1	; 0x01
    1258:	01 c0       	rjmp	.+2      	; 0x125c <MDIO_Error_State_SetPinDirection+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    125a:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    125c:	89 81       	ldd	r24, Y+1	; 0x01
}
    125e:	26 96       	adiw	r28, 0x06	; 6
    1260:	0f b6       	in	r0, 0x3f	; 63
    1262:	f8 94       	cli
    1264:	de bf       	out	0x3e, r29	; 62
    1266:	0f be       	out	0x3f, r0	; 63
    1268:	cd bf       	out	0x3d, r28	; 61
    126a:	cf 91       	pop	r28
    126c:	df 91       	pop	r29
    126e:	08 95       	ret

00001270 <MDIO_Error_State_SetPortDirection>:
/*Set Port Direction Function */
Error_State MDIO_Error_State_SetPortDirection(u8 Copy_u8PortNumber,u8 Copy_u8PortDirection)
{
    1270:	df 93       	push	r29
    1272:	cf 93       	push	r28
    1274:	00 d0       	rcall	.+0      	; 0x1276 <MDIO_Error_State_SetPortDirection+0x6>
    1276:	00 d0       	rcall	.+0      	; 0x1278 <MDIO_Error_State_SetPortDirection+0x8>
    1278:	0f 92       	push	r0
    127a:	cd b7       	in	r28, 0x3d	; 61
    127c:	de b7       	in	r29, 0x3e	; 62
    127e:	8a 83       	std	Y+2, r24	; 0x02
    1280:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    1282:	81 e0       	ldi	r24, 0x01	; 1
    1284:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection==PORT_OUTPUT)||(Copy_u8PortDirection==PORT_INPUT))
    1286:	8b 81       	ldd	r24, Y+3	; 0x03
    1288:	8f 3f       	cpi	r24, 0xFF	; 255
    128a:	19 f0       	breq	.+6      	; 0x1292 <MDIO_Error_State_SetPortDirection+0x22>
    128c:	8b 81       	ldd	r24, Y+3	; 0x03
    128e:	88 23       	and	r24, r24
    1290:	a9 f5       	brne	.+106    	; 0x12fc <MDIO_Error_State_SetPortDirection+0x8c>
	{
		switch(Copy_u8PortNumber)
    1292:	8a 81       	ldd	r24, Y+2	; 0x02
    1294:	28 2f       	mov	r18, r24
    1296:	30 e0       	ldi	r19, 0x00	; 0
    1298:	3d 83       	std	Y+5, r19	; 0x05
    129a:	2c 83       	std	Y+4, r18	; 0x04
    129c:	8c 81       	ldd	r24, Y+4	; 0x04
    129e:	9d 81       	ldd	r25, Y+5	; 0x05
    12a0:	81 30       	cpi	r24, 0x01	; 1
    12a2:	91 05       	cpc	r25, r1
    12a4:	d1 f0       	breq	.+52     	; 0x12da <MDIO_Error_State_SetPortDirection+0x6a>
    12a6:	2c 81       	ldd	r18, Y+4	; 0x04
    12a8:	3d 81       	ldd	r19, Y+5	; 0x05
    12aa:	22 30       	cpi	r18, 0x02	; 2
    12ac:	31 05       	cpc	r19, r1
    12ae:	2c f4       	brge	.+10     	; 0x12ba <MDIO_Error_State_SetPortDirection+0x4a>
    12b0:	8c 81       	ldd	r24, Y+4	; 0x04
    12b2:	9d 81       	ldd	r25, Y+5	; 0x05
    12b4:	00 97       	sbiw	r24, 0x00	; 0
    12b6:	61 f0       	breq	.+24     	; 0x12d0 <MDIO_Error_State_SetPortDirection+0x60>
    12b8:	1f c0       	rjmp	.+62     	; 0x12f8 <MDIO_Error_State_SetPortDirection+0x88>
    12ba:	2c 81       	ldd	r18, Y+4	; 0x04
    12bc:	3d 81       	ldd	r19, Y+5	; 0x05
    12be:	22 30       	cpi	r18, 0x02	; 2
    12c0:	31 05       	cpc	r19, r1
    12c2:	81 f0       	breq	.+32     	; 0x12e4 <MDIO_Error_State_SetPortDirection+0x74>
    12c4:	8c 81       	ldd	r24, Y+4	; 0x04
    12c6:	9d 81       	ldd	r25, Y+5	; 0x05
    12c8:	83 30       	cpi	r24, 0x03	; 3
    12ca:	91 05       	cpc	r25, r1
    12cc:	81 f0       	breq	.+32     	; 0x12ee <MDIO_Error_State_SetPortDirection+0x7e>
    12ce:	14 c0       	rjmp	.+40     	; 0x12f8 <MDIO_Error_State_SetPortDirection+0x88>
		{
		case MDIO_PORTA:
			DDRA=Copy_u8PortDirection;
    12d0:	ea e3       	ldi	r30, 0x3A	; 58
    12d2:	f0 e0       	ldi	r31, 0x00	; 0
    12d4:	8b 81       	ldd	r24, Y+3	; 0x03
    12d6:	80 83       	st	Z, r24
    12d8:	12 c0       	rjmp	.+36     	; 0x12fe <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTB:
			DDRB=Copy_u8PortDirection;
    12da:	e7 e3       	ldi	r30, 0x37	; 55
    12dc:	f0 e0       	ldi	r31, 0x00	; 0
    12de:	8b 81       	ldd	r24, Y+3	; 0x03
    12e0:	80 83       	st	Z, r24
    12e2:	0d c0       	rjmp	.+26     	; 0x12fe <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTC:
			DDRC=Copy_u8PortDirection;
    12e4:	e4 e3       	ldi	r30, 0x34	; 52
    12e6:	f0 e0       	ldi	r31, 0x00	; 0
    12e8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ea:	80 83       	st	Z, r24
    12ec:	08 c0       	rjmp	.+16     	; 0x12fe <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTD:
			DDRD=Copy_u8PortDirection;
    12ee:	e1 e3       	ldi	r30, 0x31	; 49
    12f0:	f0 e0       	ldi	r31, 0x00	; 0
    12f2:	8b 81       	ldd	r24, Y+3	; 0x03
    12f4:	80 83       	st	Z, r24
    12f6:	03 c0       	rjmp	.+6      	; 0x12fe <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    12f8:	19 82       	std	Y+1, r1	; 0x01
    12fa:	01 c0       	rjmp	.+2      	; 0x12fe <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    12fc:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    12fe:	89 81       	ldd	r24, Y+1	; 0x01
}
    1300:	0f 90       	pop	r0
    1302:	0f 90       	pop	r0
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
    130a:	cf 91       	pop	r28
    130c:	df 91       	pop	r29
    130e:	08 95       	ret

00001310 <MDIO_Error_State_SetPinValue>:

/*Set Pin Value Function */
Error_State MDIO_Error_State_SetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8 Copy_u8PinValue)
{
    1310:	df 93       	push	r29
    1312:	cf 93       	push	r28
    1314:	00 d0       	rcall	.+0      	; 0x1316 <MDIO_Error_State_SetPinValue+0x6>
    1316:	00 d0       	rcall	.+0      	; 0x1318 <MDIO_Error_State_SetPinValue+0x8>
    1318:	00 d0       	rcall	.+0      	; 0x131a <MDIO_Error_State_SetPinValue+0xa>
    131a:	cd b7       	in	r28, 0x3d	; 61
    131c:	de b7       	in	r29, 0x3e	; 62
    131e:	8a 83       	std	Y+2, r24	; 0x02
    1320:	6b 83       	std	Y+3, r22	; 0x03
    1322:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    1328:	8a 81       	ldd	r24, Y+2	; 0x02
    132a:	88 30       	cpi	r24, 0x08	; 8
    132c:	08 f0       	brcs	.+2      	; 0x1330 <MDIO_Error_State_SetPinValue+0x20>
    132e:	e8 c0       	rjmp	.+464    	; 0x1500 <MDIO_Error_State_SetPinValue+0x1f0>
	{
		switch(Copy_u8PortNumber)
    1330:	8b 81       	ldd	r24, Y+3	; 0x03
    1332:	28 2f       	mov	r18, r24
    1334:	30 e0       	ldi	r19, 0x00	; 0
    1336:	3e 83       	std	Y+6, r19	; 0x06
    1338:	2d 83       	std	Y+5, r18	; 0x05
    133a:	8d 81       	ldd	r24, Y+5	; 0x05
    133c:	9e 81       	ldd	r25, Y+6	; 0x06
    133e:	81 30       	cpi	r24, 0x01	; 1
    1340:	91 05       	cpc	r25, r1
    1342:	09 f4       	brne	.+2      	; 0x1346 <MDIO_Error_State_SetPinValue+0x36>
    1344:	48 c0       	rjmp	.+144    	; 0x13d6 <MDIO_Error_State_SetPinValue+0xc6>
    1346:	2d 81       	ldd	r18, Y+5	; 0x05
    1348:	3e 81       	ldd	r19, Y+6	; 0x06
    134a:	22 30       	cpi	r18, 0x02	; 2
    134c:	31 05       	cpc	r19, r1
    134e:	2c f4       	brge	.+10     	; 0x135a <MDIO_Error_State_SetPinValue+0x4a>
    1350:	8d 81       	ldd	r24, Y+5	; 0x05
    1352:	9e 81       	ldd	r25, Y+6	; 0x06
    1354:	00 97       	sbiw	r24, 0x00	; 0
    1356:	71 f0       	breq	.+28     	; 0x1374 <MDIO_Error_State_SetPinValue+0x64>
    1358:	d1 c0       	rjmp	.+418    	; 0x14fc <MDIO_Error_State_SetPinValue+0x1ec>
    135a:	2d 81       	ldd	r18, Y+5	; 0x05
    135c:	3e 81       	ldd	r19, Y+6	; 0x06
    135e:	22 30       	cpi	r18, 0x02	; 2
    1360:	31 05       	cpc	r19, r1
    1362:	09 f4       	brne	.+2      	; 0x1366 <MDIO_Error_State_SetPinValue+0x56>
    1364:	69 c0       	rjmp	.+210    	; 0x1438 <MDIO_Error_State_SetPinValue+0x128>
    1366:	8d 81       	ldd	r24, Y+5	; 0x05
    1368:	9e 81       	ldd	r25, Y+6	; 0x06
    136a:	83 30       	cpi	r24, 0x03	; 3
    136c:	91 05       	cpc	r25, r1
    136e:	09 f4       	brne	.+2      	; 0x1372 <MDIO_Error_State_SetPinValue+0x62>
    1370:	94 c0       	rjmp	.+296    	; 0x149a <MDIO_Error_State_SetPinValue+0x18a>
    1372:	c4 c0       	rjmp	.+392    	; 0x14fc <MDIO_Error_State_SetPinValue+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinValue==PIN_HIGH)
    1374:	8c 81       	ldd	r24, Y+4	; 0x04
    1376:	81 30       	cpi	r24, 0x01	; 1
    1378:	a1 f4       	brne	.+40     	; 0x13a2 <MDIO_Error_State_SetPinValue+0x92>
			{
				SET_BIT(PORTA,Copy_u8PinNumber);
    137a:	ab e3       	ldi	r26, 0x3B	; 59
    137c:	b0 e0       	ldi	r27, 0x00	; 0
    137e:	eb e3       	ldi	r30, 0x3B	; 59
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	80 81       	ld	r24, Z
    1384:	48 2f       	mov	r20, r24
    1386:	8a 81       	ldd	r24, Y+2	; 0x02
    1388:	28 2f       	mov	r18, r24
    138a:	30 e0       	ldi	r19, 0x00	; 0
    138c:	81 e0       	ldi	r24, 0x01	; 1
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	02 2e       	mov	r0, r18
    1392:	02 c0       	rjmp	.+4      	; 0x1398 <MDIO_Error_State_SetPinValue+0x88>
    1394:	88 0f       	add	r24, r24
    1396:	99 1f       	adc	r25, r25
    1398:	0a 94       	dec	r0
    139a:	e2 f7       	brpl	.-8      	; 0x1394 <MDIO_Error_State_SetPinValue+0x84>
    139c:	84 2b       	or	r24, r20
    139e:	8c 93       	st	X, r24
    13a0:	b0 c0       	rjmp	.+352    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    13a2:	8c 81       	ldd	r24, Y+4	; 0x04
    13a4:	88 23       	and	r24, r24
    13a6:	a9 f4       	brne	.+42     	; 0x13d2 <MDIO_Error_State_SetPinValue+0xc2>
			{
				CLR_BIT(PORTA,Copy_u8PinNumber);
    13a8:	ab e3       	ldi	r26, 0x3B	; 59
    13aa:	b0 e0       	ldi	r27, 0x00	; 0
    13ac:	eb e3       	ldi	r30, 0x3B	; 59
    13ae:	f0 e0       	ldi	r31, 0x00	; 0
    13b0:	80 81       	ld	r24, Z
    13b2:	48 2f       	mov	r20, r24
    13b4:	8a 81       	ldd	r24, Y+2	; 0x02
    13b6:	28 2f       	mov	r18, r24
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	90 e0       	ldi	r25, 0x00	; 0
    13be:	02 2e       	mov	r0, r18
    13c0:	02 c0       	rjmp	.+4      	; 0x13c6 <MDIO_Error_State_SetPinValue+0xb6>
    13c2:	88 0f       	add	r24, r24
    13c4:	99 1f       	adc	r25, r25
    13c6:	0a 94       	dec	r0
    13c8:	e2 f7       	brpl	.-8      	; 0x13c2 <MDIO_Error_State_SetPinValue+0xb2>
    13ca:	80 95       	com	r24
    13cc:	84 23       	and	r24, r20
    13ce:	8c 93       	st	X, r24
    13d0:	98 c0       	rjmp	.+304    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    13d2:	19 82       	std	Y+1, r1	; 0x01
    13d4:	96 c0       	rjmp	.+300    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinValue==PIN_HIGH)
    13d6:	8c 81       	ldd	r24, Y+4	; 0x04
    13d8:	81 30       	cpi	r24, 0x01	; 1
    13da:	a1 f4       	brne	.+40     	; 0x1404 <MDIO_Error_State_SetPinValue+0xf4>
			{
				SET_BIT(PORTB,Copy_u8PinNumber);
    13dc:	a8 e3       	ldi	r26, 0x38	; 56
    13de:	b0 e0       	ldi	r27, 0x00	; 0
    13e0:	e8 e3       	ldi	r30, 0x38	; 56
    13e2:	f0 e0       	ldi	r31, 0x00	; 0
    13e4:	80 81       	ld	r24, Z
    13e6:	48 2f       	mov	r20, r24
    13e8:	8a 81       	ldd	r24, Y+2	; 0x02
    13ea:	28 2f       	mov	r18, r24
    13ec:	30 e0       	ldi	r19, 0x00	; 0
    13ee:	81 e0       	ldi	r24, 0x01	; 1
    13f0:	90 e0       	ldi	r25, 0x00	; 0
    13f2:	02 2e       	mov	r0, r18
    13f4:	02 c0       	rjmp	.+4      	; 0x13fa <MDIO_Error_State_SetPinValue+0xea>
    13f6:	88 0f       	add	r24, r24
    13f8:	99 1f       	adc	r25, r25
    13fa:	0a 94       	dec	r0
    13fc:	e2 f7       	brpl	.-8      	; 0x13f6 <MDIO_Error_State_SetPinValue+0xe6>
    13fe:	84 2b       	or	r24, r20
    1400:	8c 93       	st	X, r24
    1402:	7f c0       	rjmp	.+254    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    1404:	8c 81       	ldd	r24, Y+4	; 0x04
    1406:	88 23       	and	r24, r24
    1408:	a9 f4       	brne	.+42     	; 0x1434 <MDIO_Error_State_SetPinValue+0x124>
			{
				CLR_BIT(PORTB,Copy_u8PinNumber);
    140a:	a8 e3       	ldi	r26, 0x38	; 56
    140c:	b0 e0       	ldi	r27, 0x00	; 0
    140e:	e8 e3       	ldi	r30, 0x38	; 56
    1410:	f0 e0       	ldi	r31, 0x00	; 0
    1412:	80 81       	ld	r24, Z
    1414:	48 2f       	mov	r20, r24
    1416:	8a 81       	ldd	r24, Y+2	; 0x02
    1418:	28 2f       	mov	r18, r24
    141a:	30 e0       	ldi	r19, 0x00	; 0
    141c:	81 e0       	ldi	r24, 0x01	; 1
    141e:	90 e0       	ldi	r25, 0x00	; 0
    1420:	02 2e       	mov	r0, r18
    1422:	02 c0       	rjmp	.+4      	; 0x1428 <MDIO_Error_State_SetPinValue+0x118>
    1424:	88 0f       	add	r24, r24
    1426:	99 1f       	adc	r25, r25
    1428:	0a 94       	dec	r0
    142a:	e2 f7       	brpl	.-8      	; 0x1424 <MDIO_Error_State_SetPinValue+0x114>
    142c:	80 95       	com	r24
    142e:	84 23       	and	r24, r20
    1430:	8c 93       	st	X, r24
    1432:	67 c0       	rjmp	.+206    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1434:	19 82       	std	Y+1, r1	; 0x01
    1436:	65 c0       	rjmp	.+202    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinValue==PIN_HIGH)
    1438:	8c 81       	ldd	r24, Y+4	; 0x04
    143a:	81 30       	cpi	r24, 0x01	; 1
    143c:	a1 f4       	brne	.+40     	; 0x1466 <MDIO_Error_State_SetPinValue+0x156>
			{
				SET_BIT(PORTC,Copy_u8PinNumber);
    143e:	a5 e3       	ldi	r26, 0x35	; 53
    1440:	b0 e0       	ldi	r27, 0x00	; 0
    1442:	e5 e3       	ldi	r30, 0x35	; 53
    1444:	f0 e0       	ldi	r31, 0x00	; 0
    1446:	80 81       	ld	r24, Z
    1448:	48 2f       	mov	r20, r24
    144a:	8a 81       	ldd	r24, Y+2	; 0x02
    144c:	28 2f       	mov	r18, r24
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	90 e0       	ldi	r25, 0x00	; 0
    1454:	02 2e       	mov	r0, r18
    1456:	02 c0       	rjmp	.+4      	; 0x145c <MDIO_Error_State_SetPinValue+0x14c>
    1458:	88 0f       	add	r24, r24
    145a:	99 1f       	adc	r25, r25
    145c:	0a 94       	dec	r0
    145e:	e2 f7       	brpl	.-8      	; 0x1458 <MDIO_Error_State_SetPinValue+0x148>
    1460:	84 2b       	or	r24, r20
    1462:	8c 93       	st	X, r24
    1464:	4e c0       	rjmp	.+156    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    1466:	8c 81       	ldd	r24, Y+4	; 0x04
    1468:	88 23       	and	r24, r24
    146a:	a9 f4       	brne	.+42     	; 0x1496 <MDIO_Error_State_SetPinValue+0x186>
			{
				CLR_BIT(PORTC,Copy_u8PinNumber);
    146c:	a5 e3       	ldi	r26, 0x35	; 53
    146e:	b0 e0       	ldi	r27, 0x00	; 0
    1470:	e5 e3       	ldi	r30, 0x35	; 53
    1472:	f0 e0       	ldi	r31, 0x00	; 0
    1474:	80 81       	ld	r24, Z
    1476:	48 2f       	mov	r20, r24
    1478:	8a 81       	ldd	r24, Y+2	; 0x02
    147a:	28 2f       	mov	r18, r24
    147c:	30 e0       	ldi	r19, 0x00	; 0
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	90 e0       	ldi	r25, 0x00	; 0
    1482:	02 2e       	mov	r0, r18
    1484:	02 c0       	rjmp	.+4      	; 0x148a <MDIO_Error_State_SetPinValue+0x17a>
    1486:	88 0f       	add	r24, r24
    1488:	99 1f       	adc	r25, r25
    148a:	0a 94       	dec	r0
    148c:	e2 f7       	brpl	.-8      	; 0x1486 <MDIO_Error_State_SetPinValue+0x176>
    148e:	80 95       	com	r24
    1490:	84 23       	and	r24, r20
    1492:	8c 93       	st	X, r24
    1494:	36 c0       	rjmp	.+108    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1496:	19 82       	std	Y+1, r1	; 0x01
    1498:	34 c0       	rjmp	.+104    	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinValue==PIN_HIGH)
    149a:	8c 81       	ldd	r24, Y+4	; 0x04
    149c:	81 30       	cpi	r24, 0x01	; 1
    149e:	a1 f4       	brne	.+40     	; 0x14c8 <MDIO_Error_State_SetPinValue+0x1b8>
			{
				SET_BIT(PORTD,Copy_u8PinNumber);
    14a0:	a2 e3       	ldi	r26, 0x32	; 50
    14a2:	b0 e0       	ldi	r27, 0x00	; 0
    14a4:	e2 e3       	ldi	r30, 0x32	; 50
    14a6:	f0 e0       	ldi	r31, 0x00	; 0
    14a8:	80 81       	ld	r24, Z
    14aa:	48 2f       	mov	r20, r24
    14ac:	8a 81       	ldd	r24, Y+2	; 0x02
    14ae:	28 2f       	mov	r18, r24
    14b0:	30 e0       	ldi	r19, 0x00	; 0
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	90 e0       	ldi	r25, 0x00	; 0
    14b6:	02 2e       	mov	r0, r18
    14b8:	02 c0       	rjmp	.+4      	; 0x14be <MDIO_Error_State_SetPinValue+0x1ae>
    14ba:	88 0f       	add	r24, r24
    14bc:	99 1f       	adc	r25, r25
    14be:	0a 94       	dec	r0
    14c0:	e2 f7       	brpl	.-8      	; 0x14ba <MDIO_Error_State_SetPinValue+0x1aa>
    14c2:	84 2b       	or	r24, r20
    14c4:	8c 93       	st	X, r24
    14c6:	1d c0       	rjmp	.+58     	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    14c8:	8c 81       	ldd	r24, Y+4	; 0x04
    14ca:	88 23       	and	r24, r24
    14cc:	a9 f4       	brne	.+42     	; 0x14f8 <MDIO_Error_State_SetPinValue+0x1e8>
			{
				CLR_BIT(PORTD,Copy_u8PinNumber);
    14ce:	a2 e3       	ldi	r26, 0x32	; 50
    14d0:	b0 e0       	ldi	r27, 0x00	; 0
    14d2:	e2 e3       	ldi	r30, 0x32	; 50
    14d4:	f0 e0       	ldi	r31, 0x00	; 0
    14d6:	80 81       	ld	r24, Z
    14d8:	48 2f       	mov	r20, r24
    14da:	8a 81       	ldd	r24, Y+2	; 0x02
    14dc:	28 2f       	mov	r18, r24
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	02 2e       	mov	r0, r18
    14e6:	02 c0       	rjmp	.+4      	; 0x14ec <MDIO_Error_State_SetPinValue+0x1dc>
    14e8:	88 0f       	add	r24, r24
    14ea:	99 1f       	adc	r25, r25
    14ec:	0a 94       	dec	r0
    14ee:	e2 f7       	brpl	.-8      	; 0x14e8 <MDIO_Error_State_SetPinValue+0x1d8>
    14f0:	80 95       	com	r24
    14f2:	84 23       	and	r24, r20
    14f4:	8c 93       	st	X, r24
    14f6:	05 c0       	rjmp	.+10     	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    14f8:	19 82       	std	Y+1, r1	; 0x01
    14fa:	03 c0       	rjmp	.+6      	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    14fc:	19 82       	std	Y+1, r1	; 0x01
    14fe:	01 c0       	rjmp	.+2      	; 0x1502 <MDIO_Error_State_SetPinValue+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1500:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1502:	89 81       	ldd	r24, Y+1	; 0x01
}
    1504:	26 96       	adiw	r28, 0x06	; 6
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	de bf       	out	0x3e, r29	; 62
    150c:	0f be       	out	0x3f, r0	; 63
    150e:	cd bf       	out	0x3d, r28	; 61
    1510:	cf 91       	pop	r28
    1512:	df 91       	pop	r29
    1514:	08 95       	ret

00001516 <MDIO_Error_State_SetPortValue>:

/*Set Port Value Function */
Error_State MDIO_Error_State_SetPortValue(u8 Copy_u8PortNumber,u8 Copy_u8PortValue)
{
    1516:	df 93       	push	r29
    1518:	cf 93       	push	r28
    151a:	00 d0       	rcall	.+0      	; 0x151c <MDIO_Error_State_SetPortValue+0x6>
    151c:	00 d0       	rcall	.+0      	; 0x151e <MDIO_Error_State_SetPortValue+0x8>
    151e:	0f 92       	push	r0
    1520:	cd b7       	in	r28, 0x3d	; 61
    1522:	de b7       	in	r29, 0x3e	; 62
    1524:	8a 83       	std	Y+2, r24	; 0x02
    1526:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    1528:	81 e0       	ldi	r24, 0x01	; 1
    152a:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortNumber)
    152c:	8a 81       	ldd	r24, Y+2	; 0x02
    152e:	28 2f       	mov	r18, r24
    1530:	30 e0       	ldi	r19, 0x00	; 0
    1532:	3d 83       	std	Y+5, r19	; 0x05
    1534:	2c 83       	std	Y+4, r18	; 0x04
    1536:	8c 81       	ldd	r24, Y+4	; 0x04
    1538:	9d 81       	ldd	r25, Y+5	; 0x05
    153a:	81 30       	cpi	r24, 0x01	; 1
    153c:	91 05       	cpc	r25, r1
    153e:	d1 f0       	breq	.+52     	; 0x1574 <MDIO_Error_State_SetPortValue+0x5e>
    1540:	2c 81       	ldd	r18, Y+4	; 0x04
    1542:	3d 81       	ldd	r19, Y+5	; 0x05
    1544:	22 30       	cpi	r18, 0x02	; 2
    1546:	31 05       	cpc	r19, r1
    1548:	2c f4       	brge	.+10     	; 0x1554 <MDIO_Error_State_SetPortValue+0x3e>
    154a:	8c 81       	ldd	r24, Y+4	; 0x04
    154c:	9d 81       	ldd	r25, Y+5	; 0x05
    154e:	00 97       	sbiw	r24, 0x00	; 0
    1550:	61 f0       	breq	.+24     	; 0x156a <MDIO_Error_State_SetPortValue+0x54>
    1552:	1f c0       	rjmp	.+62     	; 0x1592 <MDIO_Error_State_SetPortValue+0x7c>
    1554:	2c 81       	ldd	r18, Y+4	; 0x04
    1556:	3d 81       	ldd	r19, Y+5	; 0x05
    1558:	22 30       	cpi	r18, 0x02	; 2
    155a:	31 05       	cpc	r19, r1
    155c:	81 f0       	breq	.+32     	; 0x157e <MDIO_Error_State_SetPortValue+0x68>
    155e:	8c 81       	ldd	r24, Y+4	; 0x04
    1560:	9d 81       	ldd	r25, Y+5	; 0x05
    1562:	83 30       	cpi	r24, 0x03	; 3
    1564:	91 05       	cpc	r25, r1
    1566:	81 f0       	breq	.+32     	; 0x1588 <MDIO_Error_State_SetPortValue+0x72>
    1568:	14 c0       	rjmp	.+40     	; 0x1592 <MDIO_Error_State_SetPortValue+0x7c>
	{
	case MDIO_PORTA:
		PORTA=Copy_u8PortValue;
    156a:	eb e3       	ldi	r30, 0x3B	; 59
    156c:	f0 e0       	ldi	r31, 0x00	; 0
    156e:	8b 81       	ldd	r24, Y+3	; 0x03
    1570:	80 83       	st	Z, r24
    1572:	10 c0       	rjmp	.+32     	; 0x1594 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTB:
		PORTB=Copy_u8PortValue;
    1574:	e8 e3       	ldi	r30, 0x38	; 56
    1576:	f0 e0       	ldi	r31, 0x00	; 0
    1578:	8b 81       	ldd	r24, Y+3	; 0x03
    157a:	80 83       	st	Z, r24
    157c:	0b c0       	rjmp	.+22     	; 0x1594 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTC:
		PORTC=Copy_u8PortValue;
    157e:	e5 e3       	ldi	r30, 0x35	; 53
    1580:	f0 e0       	ldi	r31, 0x00	; 0
    1582:	8b 81       	ldd	r24, Y+3	; 0x03
    1584:	80 83       	st	Z, r24
    1586:	06 c0       	rjmp	.+12     	; 0x1594 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	case MDIO_PORTD:
		PORTD=Copy_u8PortValue;
    1588:	e2 e3       	ldi	r30, 0x32	; 50
    158a:	f0 e0       	ldi	r31, 0x00	; 0
    158c:	8b 81       	ldd	r24, Y+3	; 0x03
    158e:	80 83       	st	Z, r24
    1590:	01 c0       	rjmp	.+2      	; 0x1594 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	default:
		LOC_Error_State_ReturnState=NOK;
    1592:	19 82       	std	Y+1, r1	; 0x01
		break;
	}
	return LOC_Error_State_ReturnState;
    1594:	89 81       	ldd	r24, Y+1	; 0x01
}
    1596:	0f 90       	pop	r0
    1598:	0f 90       	pop	r0
    159a:	0f 90       	pop	r0
    159c:	0f 90       	pop	r0
    159e:	0f 90       	pop	r0
    15a0:	cf 91       	pop	r28
    15a2:	df 91       	pop	r29
    15a4:	08 95       	ret

000015a6 <MDIO_Error_State_GetPinValue>:

/*Get Pin Value Function */
Error_State MDIO_Error_State_GetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8* P_u8PinValue)
{
    15a6:	df 93       	push	r29
    15a8:	cf 93       	push	r28
    15aa:	cd b7       	in	r28, 0x3d	; 61
    15ac:	de b7       	in	r29, 0x3e	; 62
    15ae:	27 97       	sbiw	r28, 0x07	; 7
    15b0:	0f b6       	in	r0, 0x3f	; 63
    15b2:	f8 94       	cli
    15b4:	de bf       	out	0x3e, r29	; 62
    15b6:	0f be       	out	0x3f, r0	; 63
    15b8:	cd bf       	out	0x3d, r28	; 61
    15ba:	8a 83       	std	Y+2, r24	; 0x02
    15bc:	6b 83       	std	Y+3, r22	; 0x03
    15be:	5d 83       	std	Y+5, r21	; 0x05
    15c0:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    15c2:	81 e0       	ldi	r24, 0x01	; 1
    15c4:	89 83       	std	Y+1, r24	; 0x01

	if(((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))&&(P_u8PinValue!=NULL_POINTER))
    15c6:	8a 81       	ldd	r24, Y+2	; 0x02
    15c8:	88 30       	cpi	r24, 0x08	; 8
    15ca:	08 f0       	brcs	.+2      	; 0x15ce <MDIO_Error_State_GetPinValue+0x28>
    15cc:	79 c0       	rjmp	.+242    	; 0x16c0 <MDIO_Error_State_GetPinValue+0x11a>
    15ce:	8c 81       	ldd	r24, Y+4	; 0x04
    15d0:	9d 81       	ldd	r25, Y+5	; 0x05
    15d2:	81 30       	cpi	r24, 0x01	; 1
    15d4:	91 05       	cpc	r25, r1
    15d6:	09 f4       	brne	.+2      	; 0x15da <MDIO_Error_State_GetPinValue+0x34>
    15d8:	73 c0       	rjmp	.+230    	; 0x16c0 <MDIO_Error_State_GetPinValue+0x11a>
	{
		switch(Copy_u8PortNumber)
    15da:	8b 81       	ldd	r24, Y+3	; 0x03
    15dc:	28 2f       	mov	r18, r24
    15de:	30 e0       	ldi	r19, 0x00	; 0
    15e0:	3f 83       	std	Y+7, r19	; 0x07
    15e2:	2e 83       	std	Y+6, r18	; 0x06
    15e4:	4e 81       	ldd	r20, Y+6	; 0x06
    15e6:	5f 81       	ldd	r21, Y+7	; 0x07
    15e8:	41 30       	cpi	r20, 0x01	; 1
    15ea:	51 05       	cpc	r21, r1
    15ec:	59 f1       	breq	.+86     	; 0x1644 <MDIO_Error_State_GetPinValue+0x9e>
    15ee:	8e 81       	ldd	r24, Y+6	; 0x06
    15f0:	9f 81       	ldd	r25, Y+7	; 0x07
    15f2:	82 30       	cpi	r24, 0x02	; 2
    15f4:	91 05       	cpc	r25, r1
    15f6:	34 f4       	brge	.+12     	; 0x1604 <MDIO_Error_State_GetPinValue+0x5e>
    15f8:	2e 81       	ldd	r18, Y+6	; 0x06
    15fa:	3f 81       	ldd	r19, Y+7	; 0x07
    15fc:	21 15       	cp	r18, r1
    15fe:	31 05       	cpc	r19, r1
    1600:	69 f0       	breq	.+26     	; 0x161c <MDIO_Error_State_GetPinValue+0x76>
    1602:	5c c0       	rjmp	.+184    	; 0x16bc <MDIO_Error_State_GetPinValue+0x116>
    1604:	4e 81       	ldd	r20, Y+6	; 0x06
    1606:	5f 81       	ldd	r21, Y+7	; 0x07
    1608:	42 30       	cpi	r20, 0x02	; 2
    160a:	51 05       	cpc	r21, r1
    160c:	79 f1       	breq	.+94     	; 0x166c <MDIO_Error_State_GetPinValue+0xc6>
    160e:	8e 81       	ldd	r24, Y+6	; 0x06
    1610:	9f 81       	ldd	r25, Y+7	; 0x07
    1612:	83 30       	cpi	r24, 0x03	; 3
    1614:	91 05       	cpc	r25, r1
    1616:	09 f4       	brne	.+2      	; 0x161a <MDIO_Error_State_GetPinValue+0x74>
    1618:	3d c0       	rjmp	.+122    	; 0x1694 <MDIO_Error_State_GetPinValue+0xee>
    161a:	50 c0       	rjmp	.+160    	; 0x16bc <MDIO_Error_State_GetPinValue+0x116>
		{
		case MDIO_PORTA:
			*P_u8PinValue=GET_BIT(PINA,Copy_u8PinNumber);
    161c:	e9 e3       	ldi	r30, 0x39	; 57
    161e:	f0 e0       	ldi	r31, 0x00	; 0
    1620:	80 81       	ld	r24, Z
    1622:	28 2f       	mov	r18, r24
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	8a 81       	ldd	r24, Y+2	; 0x02
    1628:	88 2f       	mov	r24, r24
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	a9 01       	movw	r20, r18
    162e:	02 c0       	rjmp	.+4      	; 0x1634 <MDIO_Error_State_GetPinValue+0x8e>
    1630:	55 95       	asr	r21
    1632:	47 95       	ror	r20
    1634:	8a 95       	dec	r24
    1636:	e2 f7       	brpl	.-8      	; 0x1630 <MDIO_Error_State_GetPinValue+0x8a>
    1638:	ca 01       	movw	r24, r20
    163a:	81 70       	andi	r24, 0x01	; 1
    163c:	ec 81       	ldd	r30, Y+4	; 0x04
    163e:	fd 81       	ldd	r31, Y+5	; 0x05
    1640:	80 83       	st	Z, r24
    1642:	3f c0       	rjmp	.+126    	; 0x16c2 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTB:
			*P_u8PinValue=GET_BIT(PINB,Copy_u8PinNumber);
    1644:	e6 e3       	ldi	r30, 0x36	; 54
    1646:	f0 e0       	ldi	r31, 0x00	; 0
    1648:	80 81       	ld	r24, Z
    164a:	28 2f       	mov	r18, r24
    164c:	30 e0       	ldi	r19, 0x00	; 0
    164e:	8a 81       	ldd	r24, Y+2	; 0x02
    1650:	88 2f       	mov	r24, r24
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	a9 01       	movw	r20, r18
    1656:	02 c0       	rjmp	.+4      	; 0x165c <MDIO_Error_State_GetPinValue+0xb6>
    1658:	55 95       	asr	r21
    165a:	47 95       	ror	r20
    165c:	8a 95       	dec	r24
    165e:	e2 f7       	brpl	.-8      	; 0x1658 <MDIO_Error_State_GetPinValue+0xb2>
    1660:	ca 01       	movw	r24, r20
    1662:	81 70       	andi	r24, 0x01	; 1
    1664:	ec 81       	ldd	r30, Y+4	; 0x04
    1666:	fd 81       	ldd	r31, Y+5	; 0x05
    1668:	80 83       	st	Z, r24
    166a:	2b c0       	rjmp	.+86     	; 0x16c2 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTC:
			*P_u8PinValue=GET_BIT(PINC,Copy_u8PinNumber);
    166c:	e3 e3       	ldi	r30, 0x33	; 51
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	80 81       	ld	r24, Z
    1672:	28 2f       	mov	r18, r24
    1674:	30 e0       	ldi	r19, 0x00	; 0
    1676:	8a 81       	ldd	r24, Y+2	; 0x02
    1678:	88 2f       	mov	r24, r24
    167a:	90 e0       	ldi	r25, 0x00	; 0
    167c:	a9 01       	movw	r20, r18
    167e:	02 c0       	rjmp	.+4      	; 0x1684 <MDIO_Error_State_GetPinValue+0xde>
    1680:	55 95       	asr	r21
    1682:	47 95       	ror	r20
    1684:	8a 95       	dec	r24
    1686:	e2 f7       	brpl	.-8      	; 0x1680 <MDIO_Error_State_GetPinValue+0xda>
    1688:	ca 01       	movw	r24, r20
    168a:	81 70       	andi	r24, 0x01	; 1
    168c:	ec 81       	ldd	r30, Y+4	; 0x04
    168e:	fd 81       	ldd	r31, Y+5	; 0x05
    1690:	80 83       	st	Z, r24
    1692:	17 c0       	rjmp	.+46     	; 0x16c2 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTD:
			*P_u8PinValue=GET_BIT(PIND,Copy_u8PinNumber);
    1694:	e0 e3       	ldi	r30, 0x30	; 48
    1696:	f0 e0       	ldi	r31, 0x00	; 0
    1698:	80 81       	ld	r24, Z
    169a:	28 2f       	mov	r18, r24
    169c:	30 e0       	ldi	r19, 0x00	; 0
    169e:	8a 81       	ldd	r24, Y+2	; 0x02
    16a0:	88 2f       	mov	r24, r24
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	a9 01       	movw	r20, r18
    16a6:	02 c0       	rjmp	.+4      	; 0x16ac <MDIO_Error_State_GetPinValue+0x106>
    16a8:	55 95       	asr	r21
    16aa:	47 95       	ror	r20
    16ac:	8a 95       	dec	r24
    16ae:	e2 f7       	brpl	.-8      	; 0x16a8 <MDIO_Error_State_GetPinValue+0x102>
    16b0:	ca 01       	movw	r24, r20
    16b2:	81 70       	andi	r24, 0x01	; 1
    16b4:	ec 81       	ldd	r30, Y+4	; 0x04
    16b6:	fd 81       	ldd	r31, Y+5	; 0x05
    16b8:	80 83       	st	Z, r24
    16ba:	03 c0       	rjmp	.+6      	; 0x16c2 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    16bc:	19 82       	std	Y+1, r1	; 0x01
    16be:	01 c0       	rjmp	.+2      	; 0x16c2 <MDIO_Error_State_GetPinValue+0x11c>
			break;		
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    16c0:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    16c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    16c4:	27 96       	adiw	r28, 0x07	; 7
    16c6:	0f b6       	in	r0, 0x3f	; 63
    16c8:	f8 94       	cli
    16ca:	de bf       	out	0x3e, r29	; 62
    16cc:	0f be       	out	0x3f, r0	; 63
    16ce:	cd bf       	out	0x3d, r28	; 61
    16d0:	cf 91       	pop	r28
    16d2:	df 91       	pop	r29
    16d4:	08 95       	ret

000016d6 <MDIO_Error_State_SetNippleValue>:
/*Set Nipple Direction Function */

/*Set Nipple Values Function */
Error_State MDIO_Error_State_SetNippleValue(u8 Copy_u8PinStart,u8 Copy_u8PortNumber,u8 Copy_u8Value)
{
    16d6:	df 93       	push	r29
    16d8:	cf 93       	push	r28
    16da:	00 d0       	rcall	.+0      	; 0x16dc <MDIO_Error_State_SetNippleValue+0x6>
    16dc:	00 d0       	rcall	.+0      	; 0x16de <MDIO_Error_State_SetNippleValue+0x8>
    16de:	00 d0       	rcall	.+0      	; 0x16e0 <MDIO_Error_State_SetNippleValue+0xa>
    16e0:	cd b7       	in	r28, 0x3d	; 61
    16e2:	de b7       	in	r29, 0x3e	; 62
    16e4:	8a 83       	std	Y+2, r24	; 0x02
    16e6:	6b 83       	std	Y+3, r22	; 0x03
    16e8:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    16ea:	81 e0       	ldi	r24, 0x01	; 1
    16ec:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinStart<=4)
    16ee:	8a 81       	ldd	r24, Y+2	; 0x02
    16f0:	85 30       	cpi	r24, 0x05	; 5
    16f2:	08 f0       	brcs	.+2      	; 0x16f6 <MDIO_Error_State_SetNippleValue+0x20>
    16f4:	97 c0       	rjmp	.+302    	; 0x1824 <MDIO_Error_State_SetNippleValue+0x14e>
	{
		switch(Copy_u8PortNumber)
    16f6:	8b 81       	ldd	r24, Y+3	; 0x03
    16f8:	28 2f       	mov	r18, r24
    16fa:	30 e0       	ldi	r19, 0x00	; 0
    16fc:	3e 83       	std	Y+6, r19	; 0x06
    16fe:	2d 83       	std	Y+5, r18	; 0x05
    1700:	8d 81       	ldd	r24, Y+5	; 0x05
    1702:	9e 81       	ldd	r25, Y+6	; 0x06
    1704:	81 30       	cpi	r24, 0x01	; 1
    1706:	91 05       	cpc	r25, r1
    1708:	a1 f1       	breq	.+104    	; 0x1772 <MDIO_Error_State_SetNippleValue+0x9c>
    170a:	2d 81       	ldd	r18, Y+5	; 0x05
    170c:	3e 81       	ldd	r19, Y+6	; 0x06
    170e:	22 30       	cpi	r18, 0x02	; 2
    1710:	31 05       	cpc	r19, r1
    1712:	2c f4       	brge	.+10     	; 0x171e <MDIO_Error_State_SetNippleValue+0x48>
    1714:	8d 81       	ldd	r24, Y+5	; 0x05
    1716:	9e 81       	ldd	r25, Y+6	; 0x06
    1718:	00 97       	sbiw	r24, 0x00	; 0
    171a:	71 f0       	breq	.+28     	; 0x1738 <MDIO_Error_State_SetNippleValue+0x62>
    171c:	81 c0       	rjmp	.+258    	; 0x1820 <MDIO_Error_State_SetNippleValue+0x14a>
    171e:	2d 81       	ldd	r18, Y+5	; 0x05
    1720:	3e 81       	ldd	r19, Y+6	; 0x06
    1722:	22 30       	cpi	r18, 0x02	; 2
    1724:	31 05       	cpc	r19, r1
    1726:	09 f4       	brne	.+2      	; 0x172a <MDIO_Error_State_SetNippleValue+0x54>
    1728:	41 c0       	rjmp	.+130    	; 0x17ac <MDIO_Error_State_SetNippleValue+0xd6>
    172a:	8d 81       	ldd	r24, Y+5	; 0x05
    172c:	9e 81       	ldd	r25, Y+6	; 0x06
    172e:	83 30       	cpi	r24, 0x03	; 3
    1730:	91 05       	cpc	r25, r1
    1732:	09 f4       	brne	.+2      	; 0x1736 <MDIO_Error_State_SetNippleValue+0x60>
    1734:	58 c0       	rjmp	.+176    	; 0x17e6 <MDIO_Error_State_SetNippleValue+0x110>
    1736:	74 c0       	rjmp	.+232    	; 0x1820 <MDIO_Error_State_SetNippleValue+0x14a>
		case MDIO_PORTA:
		/*for(u8 i=Copy_u8PinStart;i<=7;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTA&=(~(0x0F<<Copy_u8PinStart));
    1738:	ab e3       	ldi	r26, 0x3B	; 59
    173a:	b0 e0       	ldi	r27, 0x00	; 0
    173c:	eb e3       	ldi	r30, 0x3B	; 59
    173e:	f0 e0       	ldi	r31, 0x00	; 0
    1740:	80 81       	ld	r24, Z
    1742:	48 2f       	mov	r20, r24
    1744:	8a 81       	ldd	r24, Y+2	; 0x02
    1746:	28 2f       	mov	r18, r24
    1748:	30 e0       	ldi	r19, 0x00	; 0
    174a:	8f e0       	ldi	r24, 0x0F	; 15
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	02 2e       	mov	r0, r18
    1750:	02 c0       	rjmp	.+4      	; 0x1756 <MDIO_Error_State_SetNippleValue+0x80>
    1752:	88 0f       	add	r24, r24
    1754:	99 1f       	adc	r25, r25
    1756:	0a 94       	dec	r0
    1758:	e2 f7       	brpl	.-8      	; 0x1752 <MDIO_Error_State_SetNippleValue+0x7c>
    175a:	80 95       	com	r24
    175c:	84 23       	and	r24, r20
    175e:	8c 93       	st	X, r24
			PORTA|=Copy_u8Value;
    1760:	ab e3       	ldi	r26, 0x3B	; 59
    1762:	b0 e0       	ldi	r27, 0x00	; 0
    1764:	eb e3       	ldi	r30, 0x3B	; 59
    1766:	f0 e0       	ldi	r31, 0x00	; 0
    1768:	90 81       	ld	r25, Z
    176a:	8c 81       	ldd	r24, Y+4	; 0x04
    176c:	89 2b       	or	r24, r25
    176e:	8c 93       	st	X, r24
    1770:	5a c0       	rjmp	.+180    	; 0x1826 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTB:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTB&=(~(0x0F<<Copy_u8PinStart));
    1772:	a8 e3       	ldi	r26, 0x38	; 56
    1774:	b0 e0       	ldi	r27, 0x00	; 0
    1776:	e8 e3       	ldi	r30, 0x38	; 56
    1778:	f0 e0       	ldi	r31, 0x00	; 0
    177a:	80 81       	ld	r24, Z
    177c:	48 2f       	mov	r20, r24
    177e:	8a 81       	ldd	r24, Y+2	; 0x02
    1780:	28 2f       	mov	r18, r24
    1782:	30 e0       	ldi	r19, 0x00	; 0
    1784:	8f e0       	ldi	r24, 0x0F	; 15
    1786:	90 e0       	ldi	r25, 0x00	; 0
    1788:	02 2e       	mov	r0, r18
    178a:	02 c0       	rjmp	.+4      	; 0x1790 <MDIO_Error_State_SetNippleValue+0xba>
    178c:	88 0f       	add	r24, r24
    178e:	99 1f       	adc	r25, r25
    1790:	0a 94       	dec	r0
    1792:	e2 f7       	brpl	.-8      	; 0x178c <MDIO_Error_State_SetNippleValue+0xb6>
    1794:	80 95       	com	r24
    1796:	84 23       	and	r24, r20
    1798:	8c 93       	st	X, r24
			PORTB|=Copy_u8Value;
    179a:	a8 e3       	ldi	r26, 0x38	; 56
    179c:	b0 e0       	ldi	r27, 0x00	; 0
    179e:	e8 e3       	ldi	r30, 0x38	; 56
    17a0:	f0 e0       	ldi	r31, 0x00	; 0
    17a2:	90 81       	ld	r25, Z
    17a4:	8c 81       	ldd	r24, Y+4	; 0x04
    17a6:	89 2b       	or	r24, r25
    17a8:	8c 93       	st	X, r24
    17aa:	3d c0       	rjmp	.+122    	; 0x1826 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTC:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTC&=(~(0x0F<<Copy_u8PinStart));
    17ac:	a5 e3       	ldi	r26, 0x35	; 53
    17ae:	b0 e0       	ldi	r27, 0x00	; 0
    17b0:	e5 e3       	ldi	r30, 0x35	; 53
    17b2:	f0 e0       	ldi	r31, 0x00	; 0
    17b4:	80 81       	ld	r24, Z
    17b6:	48 2f       	mov	r20, r24
    17b8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ba:	28 2f       	mov	r18, r24
    17bc:	30 e0       	ldi	r19, 0x00	; 0
    17be:	8f e0       	ldi	r24, 0x0F	; 15
    17c0:	90 e0       	ldi	r25, 0x00	; 0
    17c2:	02 2e       	mov	r0, r18
    17c4:	02 c0       	rjmp	.+4      	; 0x17ca <MDIO_Error_State_SetNippleValue+0xf4>
    17c6:	88 0f       	add	r24, r24
    17c8:	99 1f       	adc	r25, r25
    17ca:	0a 94       	dec	r0
    17cc:	e2 f7       	brpl	.-8      	; 0x17c6 <MDIO_Error_State_SetNippleValue+0xf0>
    17ce:	80 95       	com	r24
    17d0:	84 23       	and	r24, r20
    17d2:	8c 93       	st	X, r24
			PORTC|=Copy_u8Value;
    17d4:	a5 e3       	ldi	r26, 0x35	; 53
    17d6:	b0 e0       	ldi	r27, 0x00	; 0
    17d8:	e5 e3       	ldi	r30, 0x35	; 53
    17da:	f0 e0       	ldi	r31, 0x00	; 0
    17dc:	90 81       	ld	r25, Z
    17de:	8c 81       	ldd	r24, Y+4	; 0x04
    17e0:	89 2b       	or	r24, r25
    17e2:	8c 93       	st	X, r24
    17e4:	20 c0       	rjmp	.+64     	; 0x1826 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTD:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTD&=(~(0x0F<<Copy_u8PinStart));
    17e6:	a2 e3       	ldi	r26, 0x32	; 50
    17e8:	b0 e0       	ldi	r27, 0x00	; 0
    17ea:	e2 e3       	ldi	r30, 0x32	; 50
    17ec:	f0 e0       	ldi	r31, 0x00	; 0
    17ee:	80 81       	ld	r24, Z
    17f0:	48 2f       	mov	r20, r24
    17f2:	8a 81       	ldd	r24, Y+2	; 0x02
    17f4:	28 2f       	mov	r18, r24
    17f6:	30 e0       	ldi	r19, 0x00	; 0
    17f8:	8f e0       	ldi	r24, 0x0F	; 15
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	02 2e       	mov	r0, r18
    17fe:	02 c0       	rjmp	.+4      	; 0x1804 <MDIO_Error_State_SetNippleValue+0x12e>
    1800:	88 0f       	add	r24, r24
    1802:	99 1f       	adc	r25, r25
    1804:	0a 94       	dec	r0
    1806:	e2 f7       	brpl	.-8      	; 0x1800 <MDIO_Error_State_SetNippleValue+0x12a>
    1808:	80 95       	com	r24
    180a:	84 23       	and	r24, r20
    180c:	8c 93       	st	X, r24
			PORTD|=Copy_u8Value;
    180e:	a2 e3       	ldi	r26, 0x32	; 50
    1810:	b0 e0       	ldi	r27, 0x00	; 0
    1812:	e2 e3       	ldi	r30, 0x32	; 50
    1814:	f0 e0       	ldi	r31, 0x00	; 0
    1816:	90 81       	ld	r25, Z
    1818:	8c 81       	ldd	r24, Y+4	; 0x04
    181a:	89 2b       	or	r24, r25
    181c:	8c 93       	st	X, r24
    181e:	03 c0       	rjmp	.+6      	; 0x1826 <MDIO_Error_State_SetNippleValue+0x150>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1820:	19 82       	std	Y+1, r1	; 0x01
    1822:	01 c0       	rjmp	.+2      	; 0x1826 <MDIO_Error_State_SetNippleValue+0x150>
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1824:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    1826:	89 81       	ldd	r24, Y+1	; 0x01
}
    1828:	26 96       	adiw	r28, 0x06	; 6
    182a:	0f b6       	in	r0, 0x3f	; 63
    182c:	f8 94       	cli
    182e:	de bf       	out	0x3e, r29	; 62
    1830:	0f be       	out	0x3f, r0	; 63
    1832:	cd bf       	out	0x3d, r28	; 61
    1834:	cf 91       	pop	r28
    1836:	df 91       	pop	r29
    1838:	08 95       	ret

0000183a <MADC_VidInit>:

void (*MADC_CallBack)(void);

/*ADC Initialization*/
void MADC_VidInit(void)
{
    183a:	df 93       	push	r29
    183c:	cf 93       	push	r28
    183e:	cd b7       	in	r28, 0x3d	; 61
    1840:	de b7       	in	r29, 0x3e	; 62
	/*Select Reference Voltage*/
#if MADC_SET_REFERENCEVOLATGE == MADC_AVCC_REFERENCEVOLATGE
	SET_BIT(ADMUX,6);
    1842:	a7 e2       	ldi	r26, 0x27	; 39
    1844:	b0 e0       	ldi	r27, 0x00	; 0
    1846:	e7 e2       	ldi	r30, 0x27	; 39
    1848:	f0 e0       	ldi	r31, 0x00	; 0
    184a:	80 81       	ld	r24, Z
    184c:	80 64       	ori	r24, 0x40	; 64
    184e:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,7);
    1850:	a7 e2       	ldi	r26, 0x27	; 39
    1852:	b0 e0       	ldi	r27, 0x00	; 0
    1854:	e7 e2       	ldi	r30, 0x27	; 39
    1856:	f0 e0       	ldi	r31, 0x00	; 0
    1858:	80 81       	ld	r24, Z
    185a:	8f 77       	andi	r24, 0x7F	; 127
    185c:	8c 93       	st	X, r24
	SET_BIT(ADMUX,7);
#else
#error"ADC Reference Voltage Option I s not valid.... "
#endif
/*Set Prescaler*/
ADCSRA&=MADC_BIT_MASKING_PRESCALER;
    185e:	a6 e2       	ldi	r26, 0x26	; 38
    1860:	b0 e0       	ldi	r27, 0x00	; 0
    1862:	e6 e2       	ldi	r30, 0x26	; 38
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	80 81       	ld	r24, Z
    1868:	88 7f       	andi	r24, 0xF8	; 248
    186a:	8c 93       	st	X, r24
ADCSRA|=MADC_SET_PRESCALER;
    186c:	a6 e2       	ldi	r26, 0x26	; 38
    186e:	b0 e0       	ldi	r27, 0x00	; 0
    1870:	e6 e2       	ldi	r30, 0x26	; 38
    1872:	f0 e0       	ldi	r31, 0x00	; 0
    1874:	80 81       	ld	r24, Z
    1876:	87 60       	ori	r24, 0x07	; 7
    1878:	8c 93       	st	X, r24

#if MADC_SET_ADJUST == MADC_LEFT_ADJUST
	SET_BIT(ADMUX,5);
#elif MADC_SET_ADJUST == MADC_RIGHT_ADJUST
	CLR_BIT(ADMUX,5);
    187a:	a7 e2       	ldi	r26, 0x27	; 39
    187c:	b0 e0       	ldi	r27, 0x00	; 0
    187e:	e7 e2       	ldi	r30, 0x27	; 39
    1880:	f0 e0       	ldi	r31, 0x00	; 0
    1882:	80 81       	ld	r24, Z
    1884:	8f 7d       	andi	r24, 0xDF	; 223
    1886:	8c 93       	st	X, r24
#else
#error"ADC Left adjust option is not valid...."
#endif
/*Enable To ADC*/
SET_BIT(ADCSRA,7);
    1888:	a6 e2       	ldi	r26, 0x26	; 38
    188a:	b0 e0       	ldi	r27, 0x00	; 0
    188c:	e6 e2       	ldi	r30, 0x26	; 38
    188e:	f0 e0       	ldi	r31, 0x00	; 0
    1890:	80 81       	ld	r24, Z
    1892:	80 68       	ori	r24, 0x80	; 128
    1894:	8c 93       	st	X, r24
}
    1896:	cf 91       	pop	r28
    1898:	df 91       	pop	r29
    189a:	08 95       	ret

0000189c <MADC_VidADCInterruptEnable>:
void MADC_VidADCInterruptEnable(void)
{
    189c:	df 93       	push	r29
    189e:	cf 93       	push	r28
    18a0:	cd b7       	in	r28, 0x3d	; 61
    18a2:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADCSRA,3);
    18a4:	a6 e2       	ldi	r26, 0x26	; 38
    18a6:	b0 e0       	ldi	r27, 0x00	; 0
    18a8:	e6 e2       	ldi	r30, 0x26	; 38
    18aa:	f0 e0       	ldi	r31, 0x00	; 0
    18ac:	80 81       	ld	r24, Z
    18ae:	88 60       	ori	r24, 0x08	; 8
    18b0:	8c 93       	st	X, r24
}
    18b2:	cf 91       	pop	r28
    18b4:	df 91       	pop	r29
    18b6:	08 95       	ret

000018b8 <MADC_u16ADC_StartConversion>:
/*ADC Start Conversion-->Polling , Return ADC Value*/
u16 MADC_u16ADC_StartConversion(u8 Copy_u8Channel)
{
    18b8:	df 93       	push	r29
    18ba:	cf 93       	push	r28
    18bc:	0f 92       	push	r0
    18be:	cd b7       	in	r28, 0x3d	; 61
    18c0:	de b7       	in	r29, 0x3e	; 62
    18c2:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    18c4:	89 81       	ldd	r24, Y+1	; 0x01
    18c6:	87 70       	andi	r24, 0x07	; 7
    18c8:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    18ca:	a7 e2       	ldi	r26, 0x27	; 39
    18cc:	b0 e0       	ldi	r27, 0x00	; 0
    18ce:	e7 e2       	ldi	r30, 0x27	; 39
    18d0:	f0 e0       	ldi	r31, 0x00	; 0
    18d2:	80 81       	ld	r24, Z
    18d4:	80 7e       	andi	r24, 0xE0	; 224
    18d6:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    18d8:	a7 e2       	ldi	r26, 0x27	; 39
    18da:	b0 e0       	ldi	r27, 0x00	; 0
    18dc:	e7 e2       	ldi	r30, 0x27	; 39
    18de:	f0 e0       	ldi	r31, 0x00	; 0
    18e0:	90 81       	ld	r25, Z
    18e2:	89 81       	ldd	r24, Y+1	; 0x01
    18e4:	89 2b       	or	r24, r25
    18e6:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    18e8:	a6 e2       	ldi	r26, 0x26	; 38
    18ea:	b0 e0       	ldi	r27, 0x00	; 0
    18ec:	e6 e2       	ldi	r30, 0x26	; 38
    18ee:	f0 e0       	ldi	r31, 0x00	; 0
    18f0:	80 81       	ld	r24, Z
    18f2:	80 64       	ori	r24, 0x40	; 64
    18f4:	8c 93       	st	X, r24
	/*Wait On ADC Conversion Completed Flag is set to one */
	while(GET_BIT(ADCSRA,4)==0);
    18f6:	e6 e2       	ldi	r30, 0x26	; 38
    18f8:	f0 e0       	ldi	r31, 0x00	; 0
    18fa:	80 81       	ld	r24, Z
    18fc:	82 95       	swap	r24
    18fe:	8f 70       	andi	r24, 0x0F	; 15
    1900:	88 2f       	mov	r24, r24
    1902:	90 e0       	ldi	r25, 0x00	; 0
    1904:	81 70       	andi	r24, 0x01	; 1
    1906:	90 70       	andi	r25, 0x00	; 0
    1908:	00 97       	sbiw	r24, 0x00	; 0
    190a:	a9 f3       	breq	.-22     	; 0x18f6 <MADC_u16ADC_StartConversion+0x3e>

	return ADC;
    190c:	e4 e2       	ldi	r30, 0x24	; 36
    190e:	f0 e0       	ldi	r31, 0x00	; 0
    1910:	80 81       	ld	r24, Z
    1912:	91 81       	ldd	r25, Z+1	; 0x01
}
    1914:	0f 90       	pop	r0
    1916:	cf 91       	pop	r28
    1918:	df 91       	pop	r29
    191a:	08 95       	ret

0000191c <MADC_u16ADC_StartConversion_With_Interrupt>:
void MADC_u16ADC_StartConversion_With_Interrupt(u8 Copy_u8Channel)
{
    191c:	df 93       	push	r29
    191e:	cf 93       	push	r28
    1920:	0f 92       	push	r0
    1922:	cd b7       	in	r28, 0x3d	; 61
    1924:	de b7       	in	r29, 0x3e	; 62
    1926:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    1928:	89 81       	ldd	r24, Y+1	; 0x01
    192a:	87 70       	andi	r24, 0x07	; 7
    192c:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    192e:	a7 e2       	ldi	r26, 0x27	; 39
    1930:	b0 e0       	ldi	r27, 0x00	; 0
    1932:	e7 e2       	ldi	r30, 0x27	; 39
    1934:	f0 e0       	ldi	r31, 0x00	; 0
    1936:	80 81       	ld	r24, Z
    1938:	80 7e       	andi	r24, 0xE0	; 224
    193a:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    193c:	a7 e2       	ldi	r26, 0x27	; 39
    193e:	b0 e0       	ldi	r27, 0x00	; 0
    1940:	e7 e2       	ldi	r30, 0x27	; 39
    1942:	f0 e0       	ldi	r31, 0x00	; 0
    1944:	90 81       	ld	r25, Z
    1946:	89 81       	ldd	r24, Y+1	; 0x01
    1948:	89 2b       	or	r24, r25
    194a:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    194c:	a6 e2       	ldi	r26, 0x26	; 38
    194e:	b0 e0       	ldi	r27, 0x00	; 0
    1950:	e6 e2       	ldi	r30, 0x26	; 38
    1952:	f0 e0       	ldi	r31, 0x00	; 0
    1954:	80 81       	ld	r24, Z
    1956:	80 64       	ori	r24, 0x40	; 64
    1958:	8c 93       	st	X, r24
}
    195a:	0f 90       	pop	r0
    195c:	cf 91       	pop	r28
    195e:	df 91       	pop	r29
    1960:	08 95       	ret

00001962 <MADC_u16ADCRead>:
u16 MADC_u16ADCRead(void)
{
    1962:	df 93       	push	r29
    1964:	cf 93       	push	r28
    1966:	cd b7       	in	r28, 0x3d	; 61
    1968:	de b7       	in	r29, 0x3e	; 62
	return ADC;
    196a:	e4 e2       	ldi	r30, 0x24	; 36
    196c:	f0 e0       	ldi	r31, 0x00	; 0
    196e:	80 81       	ld	r24, Z
    1970:	91 81       	ldd	r25, Z+1	; 0x01
}
    1972:	cf 91       	pop	r28
    1974:	df 91       	pop	r29
    1976:	08 95       	ret

00001978 <MADC_VidSetCallBack>:
void MADC_VidSetCallBack(void (*Copy_pFun)(void))
{
    1978:	df 93       	push	r29
    197a:	cf 93       	push	r28
    197c:	00 d0       	rcall	.+0      	; 0x197e <MADC_VidSetCallBack+0x6>
    197e:	cd b7       	in	r28, 0x3d	; 61
    1980:	de b7       	in	r29, 0x3e	; 62
    1982:	9a 83       	std	Y+2, r25	; 0x02
    1984:	89 83       	std	Y+1, r24	; 0x01
	MADC_CallBack=Copy_pFun;
    1986:	89 81       	ldd	r24, Y+1	; 0x01
    1988:	9a 81       	ldd	r25, Y+2	; 0x02
    198a:	90 93 58 07 	sts	0x0758, r25
    198e:	80 93 57 07 	sts	0x0757, r24
}
    1992:	0f 90       	pop	r0
    1994:	0f 90       	pop	r0
    1996:	cf 91       	pop	r28
    1998:	df 91       	pop	r29
    199a:	08 95       	ret

0000199c <__vector_16>:

void __vector_16(void)
{
    199c:	1f 92       	push	r1
    199e:	0f 92       	push	r0
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	0f 92       	push	r0
    19a4:	11 24       	eor	r1, r1
    19a6:	2f 93       	push	r18
    19a8:	3f 93       	push	r19
    19aa:	4f 93       	push	r20
    19ac:	5f 93       	push	r21
    19ae:	6f 93       	push	r22
    19b0:	7f 93       	push	r23
    19b2:	8f 93       	push	r24
    19b4:	9f 93       	push	r25
    19b6:	af 93       	push	r26
    19b8:	bf 93       	push	r27
    19ba:	ef 93       	push	r30
    19bc:	ff 93       	push	r31
    19be:	df 93       	push	r29
    19c0:	cf 93       	push	r28
    19c2:	cd b7       	in	r28, 0x3d	; 61
    19c4:	de b7       	in	r29, 0x3e	; 62
	MADC_CallBack();
    19c6:	e0 91 57 07 	lds	r30, 0x0757
    19ca:	f0 91 58 07 	lds	r31, 0x0758
    19ce:	09 95       	icall
}
    19d0:	cf 91       	pop	r28
    19d2:	df 91       	pop	r29
    19d4:	ff 91       	pop	r31
    19d6:	ef 91       	pop	r30
    19d8:	bf 91       	pop	r27
    19da:	af 91       	pop	r26
    19dc:	9f 91       	pop	r25
    19de:	8f 91       	pop	r24
    19e0:	7f 91       	pop	r23
    19e2:	6f 91       	pop	r22
    19e4:	5f 91       	pop	r21
    19e6:	4f 91       	pop	r20
    19e8:	3f 91       	pop	r19
    19ea:	2f 91       	pop	r18
    19ec:	0f 90       	pop	r0
    19ee:	0f be       	out	0x3f, r0	; 63
    19f0:	0f 90       	pop	r0
    19f2:	1f 90       	pop	r1
    19f4:	18 95       	reti

000019f6 <HKPD_VidInit>:
		'#'
		},
};
/*KPD INIT*/
void HKPD_VidInit(void)
{
    19f6:	df 93       	push	r29
    19f8:	cf 93       	push	r28
    19fa:	cd b7       	in	r28, 0x3d	; 61
    19fc:	de b7       	in	r29, 0x3e	; 62
	/* Set Row Pins as an Input */
	MDIO_Error_State_SetPinDirection(ROW_PIN0,ROW_PORT,PIN_INPUT);
    19fe:	84 e0       	ldi	r24, 0x04	; 4
    1a00:	61 e0       	ldi	r22, 0x01	; 1
    1a02:	40 e0       	ldi	r20, 0x00	; 0
    1a04:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN1,ROW_PORT,PIN_INPUT);
    1a08:	85 e0       	ldi	r24, 0x05	; 5
    1a0a:	61 e0       	ldi	r22, 0x01	; 1
    1a0c:	40 e0       	ldi	r20, 0x00	; 0
    1a0e:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN2,ROW_PORT,PIN_INPUT);
    1a12:	86 e0       	ldi	r24, 0x06	; 6
    1a14:	61 e0       	ldi	r22, 0x01	; 1
    1a16:	40 e0       	ldi	r20, 0x00	; 0
    1a18:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN3,ROW_PORT,PIN_INPUT);
    1a1c:	87 e0       	ldi	r24, 0x07	; 7
    1a1e:	61 e0       	ldi	r22, 0x01	; 1
    1a20:	40 e0       	ldi	r20, 0x00	; 0
    1a22:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	/* Set Column Pins as an Output */
	MDIO_Error_State_SetPinDirection(COL_PIN0,COL_PORT,PIN_OUTPUT);
    1a26:	82 e0       	ldi	r24, 0x02	; 2
    1a28:	63 e0       	ldi	r22, 0x03	; 3
    1a2a:	41 e0       	ldi	r20, 0x01	; 1
    1a2c:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN1,COL_PORT,PIN_OUTPUT);
    1a30:	83 e0       	ldi	r24, 0x03	; 3
    1a32:	63 e0       	ldi	r22, 0x03	; 3
    1a34:	41 e0       	ldi	r20, 0x01	; 1
    1a36:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN2,COL_PORT,PIN_OUTPUT);
    1a3a:	84 e0       	ldi	r24, 0x04	; 4
    1a3c:	63 e0       	ldi	r22, 0x03	; 3
    1a3e:	41 e0       	ldi	r20, 0x01	; 1
    1a40:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN3,COL_PORT,PIN_OUTPUT);
    1a44:	85 e0       	ldi	r24, 0x05	; 5
    1a46:	63 e0       	ldi	r22, 0x03	; 3
    1a48:	41 e0       	ldi	r20, 0x01	; 1
    1a4a:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	/* Active Pull Up Resistor For Row Pins */
	MDIO_Error_State_SetPinValue(ROW_PIN0,ROW_PORT,PIN_HIGH);
    1a4e:	84 e0       	ldi	r24, 0x04	; 4
    1a50:	61 e0       	ldi	r22, 0x01	; 1
    1a52:	41 e0       	ldi	r20, 0x01	; 1
    1a54:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN1,ROW_PORT,PIN_HIGH);
    1a58:	85 e0       	ldi	r24, 0x05	; 5
    1a5a:	61 e0       	ldi	r22, 0x01	; 1
    1a5c:	41 e0       	ldi	r20, 0x01	; 1
    1a5e:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN2,ROW_PORT,PIN_HIGH);
    1a62:	86 e0       	ldi	r24, 0x06	; 6
    1a64:	61 e0       	ldi	r22, 0x01	; 1
    1a66:	41 e0       	ldi	r20, 0x01	; 1
    1a68:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN3,ROW_PORT,PIN_HIGH);
    1a6c:	87 e0       	ldi	r24, 0x07	; 7
    1a6e:	61 e0       	ldi	r22, 0x01	; 1
    1a70:	41 e0       	ldi	r20, 0x01	; 1
    1a72:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	/* Initialize 4 Column Pins By Ones */
	MDIO_Error_State_SetPinValue(COL_PIN0,COL_PORT,PIN_HIGH);
    1a76:	82 e0       	ldi	r24, 0x02	; 2
    1a78:	63 e0       	ldi	r22, 0x03	; 3
    1a7a:	41 e0       	ldi	r20, 0x01	; 1
    1a7c:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN1,COL_PORT,PIN_HIGH);
    1a80:	83 e0       	ldi	r24, 0x03	; 3
    1a82:	63 e0       	ldi	r22, 0x03	; 3
    1a84:	41 e0       	ldi	r20, 0x01	; 1
    1a86:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN2,COL_PORT,PIN_HIGH);
    1a8a:	84 e0       	ldi	r24, 0x04	; 4
    1a8c:	63 e0       	ldi	r22, 0x03	; 3
    1a8e:	41 e0       	ldi	r20, 0x01	; 1
    1a90:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN3,COL_PORT,PIN_HIGH);
    1a94:	85 e0       	ldi	r24, 0x05	; 5
    1a96:	63 e0       	ldi	r22, 0x03	; 3
    1a98:	41 e0       	ldi	r20, 0x01	; 1
    1a9a:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
}
    1a9e:	cf 91       	pop	r28
    1aa0:	df 91       	pop	r29
    1aa2:	08 95       	ret

00001aa4 <HKPD_U8GetKeyPressed>:
/*KPD Get pressed*/
u8 HKPD_U8GetKeyPressed(void)
{
    1aa4:	df 93       	push	r29
    1aa6:	cf 93       	push	r28
    1aa8:	cd b7       	in	r28, 0x3d	; 61
    1aaa:	de b7       	in	r29, 0x3e	; 62
    1aac:	62 97       	sbiw	r28, 0x12	; 18
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	de bf       	out	0x3e, r29	; 62
    1ab4:	0f be       	out	0x3f, r0	; 63
    1ab6:	cd bf       	out	0x3d, r28	; 61
	u8 LOC_U8RowCount;
	u8 LOC_U8ColCount;
	/*Initialize the switch status to NOT PRESSED*/
	u8 LOC_U8ReturnValue=NOT_PRESSED;
    1ab8:	1f 86       	std	Y+15, r1	; 0x0f
	u8 LOC_U8PinState;
	/*Looping on columns of the keypad*/
	for(LOC_U8ColCount=COL_INIT;LOC_U8ColCount<=COL_END;LOC_U8ColCount++)
    1aba:	82 e0       	ldi	r24, 0x02	; 2
    1abc:	88 8b       	std	Y+16, r24	; 0x10
    1abe:	b9 c0       	rjmp	.+370    	; 0x1c32 <HKPD_U8GetKeyPressed+0x18e>
	{
		/*Active the Column */
		MDIO_Error_State_SetPinValue(LOC_U8ColCount,COL_PORT,PIN_LOW);
    1ac0:	88 89       	ldd	r24, Y+16	; 0x10
    1ac2:	63 e0       	ldi	r22, 0x03	; 3
    1ac4:	40 e0       	ldi	r20, 0x00	; 0
    1ac6:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
		/*Loop to read the all row pins*/
		for(LOC_U8RowCount=ROW_INIT;LOC_U8RowCount<=ROW_END;LOC_U8RowCount++)
    1aca:	84 e0       	ldi	r24, 0x04	; 4
    1acc:	89 8b       	std	Y+17, r24	; 0x11
    1ace:	a5 c0       	rjmp	.+330    	; 0x1c1a <HKPD_U8GetKeyPressed+0x176>
		{
			/*check the status of the switch*/
			MDIO_Error_State_GetPinValue(LOC_U8RowCount,ROW_PORT,&LOC_U8PinState);
    1ad0:	9e 01       	movw	r18, r28
    1ad2:	2e 5e       	subi	r18, 0xEE	; 238
    1ad4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ad6:	89 89       	ldd	r24, Y+17	; 0x11
    1ad8:	61 e0       	ldi	r22, 0x01	; 1
    1ada:	a9 01       	movw	r20, r18
    1adc:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <MDIO_Error_State_GetPinValue>
			if(LOC_U8PinState==0)
    1ae0:	8a 89       	ldd	r24, Y+18	; 0x12
    1ae2:	88 23       	and	r24, r24
    1ae4:	09 f0       	breq	.+2      	; 0x1ae8 <HKPD_U8GetKeyPressed+0x44>
    1ae6:	96 c0       	rjmp	.+300    	; 0x1c14 <HKPD_U8GetKeyPressed+0x170>
			{
				/*Get the Value of the current pressed switch*/
				LOC_U8ReturnValue=KPD_u8SwitchVal[LOC_U8ColCount-COL_INIT][LOC_U8RowCount-ROW_INIT];
    1ae8:	88 89       	ldd	r24, Y+16	; 0x10
    1aea:	88 2f       	mov	r24, r24
    1aec:	90 e0       	ldi	r25, 0x00	; 0
    1aee:	ac 01       	movw	r20, r24
    1af0:	42 50       	subi	r20, 0x02	; 2
    1af2:	50 40       	sbci	r21, 0x00	; 0
    1af4:	89 89       	ldd	r24, Y+17	; 0x11
    1af6:	88 2f       	mov	r24, r24
    1af8:	90 e0       	ldi	r25, 0x00	; 0
    1afa:	9c 01       	movw	r18, r24
    1afc:	24 50       	subi	r18, 0x04	; 4
    1afe:	30 40       	sbci	r19, 0x00	; 0
    1b00:	ca 01       	movw	r24, r20
    1b02:	88 0f       	add	r24, r24
    1b04:	99 1f       	adc	r25, r25
    1b06:	88 0f       	add	r24, r24
    1b08:	99 1f       	adc	r25, r25
    1b0a:	82 0f       	add	r24, r18
    1b0c:	93 1f       	adc	r25, r19
    1b0e:	fc 01       	movw	r30, r24
    1b10:	e8 53       	subi	r30, 0x38	; 56
    1b12:	fe 4f       	sbci	r31, 0xFE	; 254
    1b14:	80 81       	ld	r24, Z
    1b16:	8f 87       	std	Y+15, r24	; 0x0f
    1b18:	08 c0       	rjmp	.+16     	; 0x1b2a <HKPD_U8GetKeyPressed+0x86>
				/*wait until the switch is released(Single Press)*/
				while(LOC_U8PinState==0)
				{
					MDIO_Error_State_GetPinValue(LOC_U8RowCount,ROW_PORT,&LOC_U8PinState);
    1b1a:	9e 01       	movw	r18, r28
    1b1c:	2e 5e       	subi	r18, 0xEE	; 238
    1b1e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b20:	89 89       	ldd	r24, Y+17	; 0x11
    1b22:	61 e0       	ldi	r22, 0x01	; 1
    1b24:	a9 01       	movw	r20, r18
    1b26:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <MDIO_Error_State_GetPinValue>
			if(LOC_U8PinState==0)
			{
				/*Get the Value of the current pressed switch*/
				LOC_U8ReturnValue=KPD_u8SwitchVal[LOC_U8ColCount-COL_INIT][LOC_U8RowCount-ROW_INIT];
				/*wait until the switch is released(Single Press)*/
				while(LOC_U8PinState==0)
    1b2a:	8a 89       	ldd	r24, Y+18	; 0x12
    1b2c:	88 23       	and	r24, r24
    1b2e:	a9 f3       	breq	.-22     	; 0x1b1a <HKPD_U8GetKeyPressed+0x76>
    1b30:	80 e0       	ldi	r24, 0x00	; 0
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	a0 e2       	ldi	r26, 0x20	; 32
    1b36:	b1 e4       	ldi	r27, 0x41	; 65
    1b38:	8b 87       	std	Y+11, r24	; 0x0b
    1b3a:	9c 87       	std	Y+12, r25	; 0x0c
    1b3c:	ad 87       	std	Y+13, r26	; 0x0d
    1b3e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b40:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b42:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b44:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b46:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b48:	20 e0       	ldi	r18, 0x00	; 0
    1b4a:	30 e0       	ldi	r19, 0x00	; 0
    1b4c:	4a ef       	ldi	r20, 0xFA	; 250
    1b4e:	54 e4       	ldi	r21, 0x44	; 68
    1b50:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b54:	dc 01       	movw	r26, r24
    1b56:	cb 01       	movw	r24, r22
    1b58:	8f 83       	std	Y+7, r24	; 0x07
    1b5a:	98 87       	std	Y+8, r25	; 0x08
    1b5c:	a9 87       	std	Y+9, r26	; 0x09
    1b5e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1b60:	6f 81       	ldd	r22, Y+7	; 0x07
    1b62:	78 85       	ldd	r23, Y+8	; 0x08
    1b64:	89 85       	ldd	r24, Y+9	; 0x09
    1b66:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b68:	20 e0       	ldi	r18, 0x00	; 0
    1b6a:	30 e0       	ldi	r19, 0x00	; 0
    1b6c:	40 e8       	ldi	r20, 0x80	; 128
    1b6e:	5f e3       	ldi	r21, 0x3F	; 63
    1b70:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1b74:	88 23       	and	r24, r24
    1b76:	2c f4       	brge	.+10     	; 0x1b82 <HKPD_U8GetKeyPressed+0xde>
		__ticks = 1;
    1b78:	81 e0       	ldi	r24, 0x01	; 1
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	9e 83       	std	Y+6, r25	; 0x06
    1b7e:	8d 83       	std	Y+5, r24	; 0x05
    1b80:	3f c0       	rjmp	.+126    	; 0x1c00 <HKPD_U8GetKeyPressed+0x15c>
	else if (__tmp > 65535)
    1b82:	6f 81       	ldd	r22, Y+7	; 0x07
    1b84:	78 85       	ldd	r23, Y+8	; 0x08
    1b86:	89 85       	ldd	r24, Y+9	; 0x09
    1b88:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b8a:	20 e0       	ldi	r18, 0x00	; 0
    1b8c:	3f ef       	ldi	r19, 0xFF	; 255
    1b8e:	4f e7       	ldi	r20, 0x7F	; 127
    1b90:	57 e4       	ldi	r21, 0x47	; 71
    1b92:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1b96:	18 16       	cp	r1, r24
    1b98:	4c f5       	brge	.+82     	; 0x1bec <HKPD_U8GetKeyPressed+0x148>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b9a:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b9c:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b9e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ba0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ba2:	20 e0       	ldi	r18, 0x00	; 0
    1ba4:	30 e0       	ldi	r19, 0x00	; 0
    1ba6:	40 e2       	ldi	r20, 0x20	; 32
    1ba8:	51 e4       	ldi	r21, 0x41	; 65
    1baa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bae:	dc 01       	movw	r26, r24
    1bb0:	cb 01       	movw	r24, r22
    1bb2:	bc 01       	movw	r22, r24
    1bb4:	cd 01       	movw	r24, r26
    1bb6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bba:	dc 01       	movw	r26, r24
    1bbc:	cb 01       	movw	r24, r22
    1bbe:	9e 83       	std	Y+6, r25	; 0x06
    1bc0:	8d 83       	std	Y+5, r24	; 0x05
    1bc2:	0f c0       	rjmp	.+30     	; 0x1be2 <HKPD_U8GetKeyPressed+0x13e>
    1bc4:	88 ec       	ldi	r24, 0xC8	; 200
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	9c 83       	std	Y+4, r25	; 0x04
    1bca:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1bcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bce:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd0:	01 97       	sbiw	r24, 0x01	; 1
    1bd2:	f1 f7       	brne	.-4      	; 0x1bd0 <HKPD_U8GetKeyPressed+0x12c>
    1bd4:	9c 83       	std	Y+4, r25	; 0x04
    1bd6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1bd8:	8d 81       	ldd	r24, Y+5	; 0x05
    1bda:	9e 81       	ldd	r25, Y+6	; 0x06
    1bdc:	01 97       	sbiw	r24, 0x01	; 1
    1bde:	9e 83       	std	Y+6, r25	; 0x06
    1be0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1be2:	8d 81       	ldd	r24, Y+5	; 0x05
    1be4:	9e 81       	ldd	r25, Y+6	; 0x06
    1be6:	00 97       	sbiw	r24, 0x00	; 0
    1be8:	69 f7       	brne	.-38     	; 0x1bc4 <HKPD_U8GetKeyPressed+0x120>
    1bea:	14 c0       	rjmp	.+40     	; 0x1c14 <HKPD_U8GetKeyPressed+0x170>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1bec:	6f 81       	ldd	r22, Y+7	; 0x07
    1bee:	78 85       	ldd	r23, Y+8	; 0x08
    1bf0:	89 85       	ldd	r24, Y+9	; 0x09
    1bf2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bf4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bf8:	dc 01       	movw	r26, r24
    1bfa:	cb 01       	movw	r24, r22
    1bfc:	9e 83       	std	Y+6, r25	; 0x06
    1bfe:	8d 83       	std	Y+5, r24	; 0x05
    1c00:	8d 81       	ldd	r24, Y+5	; 0x05
    1c02:	9e 81       	ldd	r25, Y+6	; 0x06
    1c04:	9a 83       	std	Y+2, r25	; 0x02
    1c06:	89 83       	std	Y+1, r24	; 0x01
    1c08:	89 81       	ldd	r24, Y+1	; 0x01
    1c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c0c:	01 97       	sbiw	r24, 0x01	; 1
    1c0e:	f1 f7       	brne	.-4      	; 0x1c0c <HKPD_U8GetKeyPressed+0x168>
    1c10:	9a 83       	std	Y+2, r25	; 0x02
    1c12:	89 83       	std	Y+1, r24	; 0x01
	for(LOC_U8ColCount=COL_INIT;LOC_U8ColCount<=COL_END;LOC_U8ColCount++)
	{
		/*Active the Column */
		MDIO_Error_State_SetPinValue(LOC_U8ColCount,COL_PORT,PIN_LOW);
		/*Loop to read the all row pins*/
		for(LOC_U8RowCount=ROW_INIT;LOC_U8RowCount<=ROW_END;LOC_U8RowCount++)
    1c14:	89 89       	ldd	r24, Y+17	; 0x11
    1c16:	8f 5f       	subi	r24, 0xFF	; 255
    1c18:	89 8b       	std	Y+17, r24	; 0x11
    1c1a:	89 89       	ldd	r24, Y+17	; 0x11
    1c1c:	88 30       	cpi	r24, 0x08	; 8
    1c1e:	08 f4       	brcc	.+2      	; 0x1c22 <HKPD_U8GetKeyPressed+0x17e>
    1c20:	57 cf       	rjmp	.-338    	; 0x1ad0 <HKPD_U8GetKeyPressed+0x2c>
			{
				/*Do Nothing*/
			}
		}
		/*Deactivate the Column*/
		MDIO_Error_State_SetPinValue(LOC_U8ColCount,COL_PORT,PIN_HIGH);
    1c22:	88 89       	ldd	r24, Y+16	; 0x10
    1c24:	63 e0       	ldi	r22, 0x03	; 3
    1c26:	41 e0       	ldi	r20, 0x01	; 1
    1c28:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	u8 LOC_U8ColCount;
	/*Initialize the switch status to NOT PRESSED*/
	u8 LOC_U8ReturnValue=NOT_PRESSED;
	u8 LOC_U8PinState;
	/*Looping on columns of the keypad*/
	for(LOC_U8ColCount=COL_INIT;LOC_U8ColCount<=COL_END;LOC_U8ColCount++)
    1c2c:	88 89       	ldd	r24, Y+16	; 0x10
    1c2e:	8f 5f       	subi	r24, 0xFF	; 255
    1c30:	88 8b       	std	Y+16, r24	; 0x10
    1c32:	88 89       	ldd	r24, Y+16	; 0x10
    1c34:	86 30       	cpi	r24, 0x06	; 6
    1c36:	08 f4       	brcc	.+2      	; 0x1c3a <HKPD_U8GetKeyPressed+0x196>
    1c38:	43 cf       	rjmp	.-378    	; 0x1ac0 <HKPD_U8GetKeyPressed+0x1c>
			}
		}
		/*Deactivate the Column*/
		MDIO_Error_State_SetPinValue(LOC_U8ColCount,COL_PORT,PIN_HIGH);
	}
	return LOC_U8ReturnValue;
    1c3a:	8f 85       	ldd	r24, Y+15	; 0x0f
}
    1c3c:	62 96       	adiw	r28, 0x12	; 18
    1c3e:	0f b6       	in	r0, 0x3f	; 63
    1c40:	f8 94       	cli
    1c42:	de bf       	out	0x3e, r29	; 62
    1c44:	0f be       	out	0x3f, r0	; 63
    1c46:	cd bf       	out	0x3d, r28	; 61
    1c48:	cf 91       	pop	r28
    1c4a:	df 91       	pop	r29
    1c4c:	08 95       	ret

00001c4e <HCLCD_VidWriteCommand_8Bits>:
#include"HCLCD_Interface.h"

#include"util/delay.h"

void HCLCD_VidWriteCommand_8Bits(u8 Copy_u8Command)
{
    1c4e:	df 93       	push	r29
    1c50:	cf 93       	push	r28
    1c52:	cd b7       	in	r28, 0x3d	; 61
    1c54:	de b7       	in	r29, 0x3e	; 62
    1c56:	6d 97       	sbiw	r28, 0x1d	; 29
    1c58:	0f b6       	in	r0, 0x3f	; 63
    1c5a:	f8 94       	cli
    1c5c:	de bf       	out	0x3e, r29	; 62
    1c5e:	0f be       	out	0x3f, r0	; 63
    1c60:	cd bf       	out	0x3d, r28	; 61
    1c62:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    1c64:	81 e0       	ldi	r24, 0x01	; 1
    1c66:	60 e0       	ldi	r22, 0x00	; 0
    1c68:	40 e0       	ldi	r20, 0x00	; 0
    1c6a:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
    1c6e:	80 e0       	ldi	r24, 0x00	; 0
    1c70:	60 e0       	ldi	r22, 0x00	; 0
    1c72:	40 e0       	ldi	r20, 0x00	; 0
    1c74:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Command);
    1c78:	80 e0       	ldi	r24, 0x00	; 0
    1c7a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1c7c:	0e 94 8b 0a 	call	0x1516	; 0x1516 <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    1c80:	82 e0       	ldi	r24, 0x02	; 2
    1c82:	60 e0       	ldi	r22, 0x00	; 0
    1c84:	41 e0       	ldi	r20, 0x01	; 1
    1c86:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
    1c8a:	80 e0       	ldi	r24, 0x00	; 0
    1c8c:	90 e0       	ldi	r25, 0x00	; 0
    1c8e:	a0 e0       	ldi	r26, 0x00	; 0
    1c90:	b0 e4       	ldi	r27, 0x40	; 64
    1c92:	89 8f       	std	Y+25, r24	; 0x19
    1c94:	9a 8f       	std	Y+26, r25	; 0x1a
    1c96:	ab 8f       	std	Y+27, r26	; 0x1b
    1c98:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c9a:	69 8d       	ldd	r22, Y+25	; 0x19
    1c9c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1c9e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ca0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1ca2:	20 e0       	ldi	r18, 0x00	; 0
    1ca4:	30 e0       	ldi	r19, 0x00	; 0
    1ca6:	4a ef       	ldi	r20, 0xFA	; 250
    1ca8:	54 e4       	ldi	r21, 0x44	; 68
    1caa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cae:	dc 01       	movw	r26, r24
    1cb0:	cb 01       	movw	r24, r22
    1cb2:	8d 8b       	std	Y+21, r24	; 0x15
    1cb4:	9e 8b       	std	Y+22, r25	; 0x16
    1cb6:	af 8b       	std	Y+23, r26	; 0x17
    1cb8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1cba:	6d 89       	ldd	r22, Y+21	; 0x15
    1cbc:	7e 89       	ldd	r23, Y+22	; 0x16
    1cbe:	8f 89       	ldd	r24, Y+23	; 0x17
    1cc0:	98 8d       	ldd	r25, Y+24	; 0x18
    1cc2:	20 e0       	ldi	r18, 0x00	; 0
    1cc4:	30 e0       	ldi	r19, 0x00	; 0
    1cc6:	40 e8       	ldi	r20, 0x80	; 128
    1cc8:	5f e3       	ldi	r21, 0x3F	; 63
    1cca:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1cce:	88 23       	and	r24, r24
    1cd0:	2c f4       	brge	.+10     	; 0x1cdc <HCLCD_VidWriteCommand_8Bits+0x8e>
		__ticks = 1;
    1cd2:	81 e0       	ldi	r24, 0x01	; 1
    1cd4:	90 e0       	ldi	r25, 0x00	; 0
    1cd6:	9c 8b       	std	Y+20, r25	; 0x14
    1cd8:	8b 8b       	std	Y+19, r24	; 0x13
    1cda:	3f c0       	rjmp	.+126    	; 0x1d5a <HCLCD_VidWriteCommand_8Bits+0x10c>
	else if (__tmp > 65535)
    1cdc:	6d 89       	ldd	r22, Y+21	; 0x15
    1cde:	7e 89       	ldd	r23, Y+22	; 0x16
    1ce0:	8f 89       	ldd	r24, Y+23	; 0x17
    1ce2:	98 8d       	ldd	r25, Y+24	; 0x18
    1ce4:	20 e0       	ldi	r18, 0x00	; 0
    1ce6:	3f ef       	ldi	r19, 0xFF	; 255
    1ce8:	4f e7       	ldi	r20, 0x7F	; 127
    1cea:	57 e4       	ldi	r21, 0x47	; 71
    1cec:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1cf0:	18 16       	cp	r1, r24
    1cf2:	4c f5       	brge	.+82     	; 0x1d46 <HCLCD_VidWriteCommand_8Bits+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1cf4:	69 8d       	ldd	r22, Y+25	; 0x19
    1cf6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1cf8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1cfa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1cfc:	20 e0       	ldi	r18, 0x00	; 0
    1cfe:	30 e0       	ldi	r19, 0x00	; 0
    1d00:	40 e2       	ldi	r20, 0x20	; 32
    1d02:	51 e4       	ldi	r21, 0x41	; 65
    1d04:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d08:	dc 01       	movw	r26, r24
    1d0a:	cb 01       	movw	r24, r22
    1d0c:	bc 01       	movw	r22, r24
    1d0e:	cd 01       	movw	r24, r26
    1d10:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d14:	dc 01       	movw	r26, r24
    1d16:	cb 01       	movw	r24, r22
    1d18:	9c 8b       	std	Y+20, r25	; 0x14
    1d1a:	8b 8b       	std	Y+19, r24	; 0x13
    1d1c:	0f c0       	rjmp	.+30     	; 0x1d3c <HCLCD_VidWriteCommand_8Bits+0xee>
    1d1e:	88 ec       	ldi	r24, 0xC8	; 200
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	9a 8b       	std	Y+18, r25	; 0x12
    1d24:	89 8b       	std	Y+17, r24	; 0x11
    1d26:	89 89       	ldd	r24, Y+17	; 0x11
    1d28:	9a 89       	ldd	r25, Y+18	; 0x12
    1d2a:	01 97       	sbiw	r24, 0x01	; 1
    1d2c:	f1 f7       	brne	.-4      	; 0x1d2a <HCLCD_VidWriteCommand_8Bits+0xdc>
    1d2e:	9a 8b       	std	Y+18, r25	; 0x12
    1d30:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d32:	8b 89       	ldd	r24, Y+19	; 0x13
    1d34:	9c 89       	ldd	r25, Y+20	; 0x14
    1d36:	01 97       	sbiw	r24, 0x01	; 1
    1d38:	9c 8b       	std	Y+20, r25	; 0x14
    1d3a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d3c:	8b 89       	ldd	r24, Y+19	; 0x13
    1d3e:	9c 89       	ldd	r25, Y+20	; 0x14
    1d40:	00 97       	sbiw	r24, 0x00	; 0
    1d42:	69 f7       	brne	.-38     	; 0x1d1e <HCLCD_VidWriteCommand_8Bits+0xd0>
    1d44:	14 c0       	rjmp	.+40     	; 0x1d6e <HCLCD_VidWriteCommand_8Bits+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d46:	6d 89       	ldd	r22, Y+21	; 0x15
    1d48:	7e 89       	ldd	r23, Y+22	; 0x16
    1d4a:	8f 89       	ldd	r24, Y+23	; 0x17
    1d4c:	98 8d       	ldd	r25, Y+24	; 0x18
    1d4e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d52:	dc 01       	movw	r26, r24
    1d54:	cb 01       	movw	r24, r22
    1d56:	9c 8b       	std	Y+20, r25	; 0x14
    1d58:	8b 8b       	std	Y+19, r24	; 0x13
    1d5a:	8b 89       	ldd	r24, Y+19	; 0x13
    1d5c:	9c 89       	ldd	r25, Y+20	; 0x14
    1d5e:	98 8b       	std	Y+16, r25	; 0x10
    1d60:	8f 87       	std	Y+15, r24	; 0x0f
    1d62:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d64:	98 89       	ldd	r25, Y+16	; 0x10
    1d66:	01 97       	sbiw	r24, 0x01	; 1
    1d68:	f1 f7       	brne	.-4      	; 0x1d66 <HCLCD_VidWriteCommand_8Bits+0x118>
    1d6a:	98 8b       	std	Y+16, r25	; 0x10
    1d6c:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    1d6e:	82 e0       	ldi	r24, 0x02	; 2
    1d70:	60 e0       	ldi	r22, 0x00	; 0
    1d72:	40 e0       	ldi	r20, 0x00	; 0
    1d74:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
    1d78:	80 e0       	ldi	r24, 0x00	; 0
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	a0 e0       	ldi	r26, 0x00	; 0
    1d7e:	b0 e4       	ldi	r27, 0x40	; 64
    1d80:	8b 87       	std	Y+11, r24	; 0x0b
    1d82:	9c 87       	std	Y+12, r25	; 0x0c
    1d84:	ad 87       	std	Y+13, r26	; 0x0d
    1d86:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d88:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d8a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d90:	20 e0       	ldi	r18, 0x00	; 0
    1d92:	30 e0       	ldi	r19, 0x00	; 0
    1d94:	4a ef       	ldi	r20, 0xFA	; 250
    1d96:	54 e4       	ldi	r21, 0x44	; 68
    1d98:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d9c:	dc 01       	movw	r26, r24
    1d9e:	cb 01       	movw	r24, r22
    1da0:	8f 83       	std	Y+7, r24	; 0x07
    1da2:	98 87       	std	Y+8, r25	; 0x08
    1da4:	a9 87       	std	Y+9, r26	; 0x09
    1da6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1da8:	6f 81       	ldd	r22, Y+7	; 0x07
    1daa:	78 85       	ldd	r23, Y+8	; 0x08
    1dac:	89 85       	ldd	r24, Y+9	; 0x09
    1dae:	9a 85       	ldd	r25, Y+10	; 0x0a
    1db0:	20 e0       	ldi	r18, 0x00	; 0
    1db2:	30 e0       	ldi	r19, 0x00	; 0
    1db4:	40 e8       	ldi	r20, 0x80	; 128
    1db6:	5f e3       	ldi	r21, 0x3F	; 63
    1db8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1dbc:	88 23       	and	r24, r24
    1dbe:	2c f4       	brge	.+10     	; 0x1dca <HCLCD_VidWriteCommand_8Bits+0x17c>
		__ticks = 1;
    1dc0:	81 e0       	ldi	r24, 0x01	; 1
    1dc2:	90 e0       	ldi	r25, 0x00	; 0
    1dc4:	9e 83       	std	Y+6, r25	; 0x06
    1dc6:	8d 83       	std	Y+5, r24	; 0x05
    1dc8:	3f c0       	rjmp	.+126    	; 0x1e48 <HCLCD_VidWriteCommand_8Bits+0x1fa>
	else if (__tmp > 65535)
    1dca:	6f 81       	ldd	r22, Y+7	; 0x07
    1dcc:	78 85       	ldd	r23, Y+8	; 0x08
    1dce:	89 85       	ldd	r24, Y+9	; 0x09
    1dd0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1dd2:	20 e0       	ldi	r18, 0x00	; 0
    1dd4:	3f ef       	ldi	r19, 0xFF	; 255
    1dd6:	4f e7       	ldi	r20, 0x7F	; 127
    1dd8:	57 e4       	ldi	r21, 0x47	; 71
    1dda:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1dde:	18 16       	cp	r1, r24
    1de0:	4c f5       	brge	.+82     	; 0x1e34 <HCLCD_VidWriteCommand_8Bits+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1de2:	6b 85       	ldd	r22, Y+11	; 0x0b
    1de4:	7c 85       	ldd	r23, Y+12	; 0x0c
    1de6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1de8:	9e 85       	ldd	r25, Y+14	; 0x0e
    1dea:	20 e0       	ldi	r18, 0x00	; 0
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	40 e2       	ldi	r20, 0x20	; 32
    1df0:	51 e4       	ldi	r21, 0x41	; 65
    1df2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1df6:	dc 01       	movw	r26, r24
    1df8:	cb 01       	movw	r24, r22
    1dfa:	bc 01       	movw	r22, r24
    1dfc:	cd 01       	movw	r24, r26
    1dfe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e02:	dc 01       	movw	r26, r24
    1e04:	cb 01       	movw	r24, r22
    1e06:	9e 83       	std	Y+6, r25	; 0x06
    1e08:	8d 83       	std	Y+5, r24	; 0x05
    1e0a:	0f c0       	rjmp	.+30     	; 0x1e2a <HCLCD_VidWriteCommand_8Bits+0x1dc>
    1e0c:	88 ec       	ldi	r24, 0xC8	; 200
    1e0e:	90 e0       	ldi	r25, 0x00	; 0
    1e10:	9c 83       	std	Y+4, r25	; 0x04
    1e12:	8b 83       	std	Y+3, r24	; 0x03
    1e14:	8b 81       	ldd	r24, Y+3	; 0x03
    1e16:	9c 81       	ldd	r25, Y+4	; 0x04
    1e18:	01 97       	sbiw	r24, 0x01	; 1
    1e1a:	f1 f7       	brne	.-4      	; 0x1e18 <HCLCD_VidWriteCommand_8Bits+0x1ca>
    1e1c:	9c 83       	std	Y+4, r25	; 0x04
    1e1e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e20:	8d 81       	ldd	r24, Y+5	; 0x05
    1e22:	9e 81       	ldd	r25, Y+6	; 0x06
    1e24:	01 97       	sbiw	r24, 0x01	; 1
    1e26:	9e 83       	std	Y+6, r25	; 0x06
    1e28:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e2a:	8d 81       	ldd	r24, Y+5	; 0x05
    1e2c:	9e 81       	ldd	r25, Y+6	; 0x06
    1e2e:	00 97       	sbiw	r24, 0x00	; 0
    1e30:	69 f7       	brne	.-38     	; 0x1e0c <HCLCD_VidWriteCommand_8Bits+0x1be>
    1e32:	14 c0       	rjmp	.+40     	; 0x1e5c <HCLCD_VidWriteCommand_8Bits+0x20e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e34:	6f 81       	ldd	r22, Y+7	; 0x07
    1e36:	78 85       	ldd	r23, Y+8	; 0x08
    1e38:	89 85       	ldd	r24, Y+9	; 0x09
    1e3a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e3c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e40:	dc 01       	movw	r26, r24
    1e42:	cb 01       	movw	r24, r22
    1e44:	9e 83       	std	Y+6, r25	; 0x06
    1e46:	8d 83       	std	Y+5, r24	; 0x05
    1e48:	8d 81       	ldd	r24, Y+5	; 0x05
    1e4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e4c:	9a 83       	std	Y+2, r25	; 0x02
    1e4e:	89 83       	std	Y+1, r24	; 0x01
    1e50:	89 81       	ldd	r24, Y+1	; 0x01
    1e52:	9a 81       	ldd	r25, Y+2	; 0x02
    1e54:	01 97       	sbiw	r24, 0x01	; 1
    1e56:	f1 f7       	brne	.-4      	; 0x1e54 <HCLCD_VidWriteCommand_8Bits+0x206>
    1e58:	9a 83       	std	Y+2, r25	; 0x02
    1e5a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    1e5c:	82 e0       	ldi	r24, 0x02	; 2
    1e5e:	60 e0       	ldi	r22, 0x00	; 0
    1e60:	41 e0       	ldi	r20, 0x01	; 1
    1e62:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
}
    1e66:	6d 96       	adiw	r28, 0x1d	; 29
    1e68:	0f b6       	in	r0, 0x3f	; 63
    1e6a:	f8 94       	cli
    1e6c:	de bf       	out	0x3e, r29	; 62
    1e6e:	0f be       	out	0x3f, r0	; 63
    1e70:	cd bf       	out	0x3d, r28	; 61
    1e72:	cf 91       	pop	r28
    1e74:	df 91       	pop	r29
    1e76:	08 95       	ret

00001e78 <HCLCD_Vid8Bits_Init>:

void HCLCD_Vid8Bits_Init(void)
{
    1e78:	df 93       	push	r29
    1e7a:	cf 93       	push	r28
    1e7c:	cd b7       	in	r28, 0x3d	; 61
    1e7e:	de b7       	in	r29, 0x3e	; 62
    1e80:	e8 97       	sbiw	r28, 0x38	; 56
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	de bf       	out	0x3e, r29	; 62
    1e88:	0f be       	out	0x3f, r0	; 63
    1e8a:	cd bf       	out	0x3d, r28	; 61
	/*LCD Data and control port intialization*/
	MDIO_Error_State_SetPortDirection(DATA_PORT,PORT_OUTPUT);
    1e8c:	80 e0       	ldi	r24, 0x00	; 0
    1e8e:	6f ef       	ldi	r22, 0xFF	; 255
    1e90:	0e 94 38 09 	call	0x1270	; 0x1270 <MDIO_Error_State_SetPortDirection>
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	60 e0       	ldi	r22, 0x00	; 0
    1e98:	41 e0       	ldi	r20, 0x01	; 1
    1e9a:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
    1e9e:	80 e0       	ldi	r24, 0x00	; 0
    1ea0:	60 e0       	ldi	r22, 0x00	; 0
    1ea2:	41 e0       	ldi	r20, 0x01	; 1
    1ea4:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    1ea8:	82 e0       	ldi	r24, 0x02	; 2
    1eaa:	60 e0       	ldi	r22, 0x00	; 0
    1eac:	41 e0       	ldi	r20, 0x01	; 1
    1eae:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
    1eb2:	80 e0       	ldi	r24, 0x00	; 0
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	a0 ef       	ldi	r26, 0xF0	; 240
    1eb8:	b1 e4       	ldi	r27, 0x41	; 65
    1eba:	8d ab       	std	Y+53, r24	; 0x35
    1ebc:	9e ab       	std	Y+54, r25	; 0x36
    1ebe:	af ab       	std	Y+55, r26	; 0x37
    1ec0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1ec2:	6d a9       	ldd	r22, Y+53	; 0x35
    1ec4:	7e a9       	ldd	r23, Y+54	; 0x36
    1ec6:	8f a9       	ldd	r24, Y+55	; 0x37
    1ec8:	98 ad       	ldd	r25, Y+56	; 0x38
    1eca:	20 e0       	ldi	r18, 0x00	; 0
    1ecc:	30 e0       	ldi	r19, 0x00	; 0
    1ece:	4a ef       	ldi	r20, 0xFA	; 250
    1ed0:	54 e4       	ldi	r21, 0x44	; 68
    1ed2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ed6:	dc 01       	movw	r26, r24
    1ed8:	cb 01       	movw	r24, r22
    1eda:	89 ab       	std	Y+49, r24	; 0x31
    1edc:	9a ab       	std	Y+50, r25	; 0x32
    1ede:	ab ab       	std	Y+51, r26	; 0x33
    1ee0:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1ee2:	69 a9       	ldd	r22, Y+49	; 0x31
    1ee4:	7a a9       	ldd	r23, Y+50	; 0x32
    1ee6:	8b a9       	ldd	r24, Y+51	; 0x33
    1ee8:	9c a9       	ldd	r25, Y+52	; 0x34
    1eea:	20 e0       	ldi	r18, 0x00	; 0
    1eec:	30 e0       	ldi	r19, 0x00	; 0
    1eee:	40 e8       	ldi	r20, 0x80	; 128
    1ef0:	5f e3       	ldi	r21, 0x3F	; 63
    1ef2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1ef6:	88 23       	and	r24, r24
    1ef8:	2c f4       	brge	.+10     	; 0x1f04 <HCLCD_Vid8Bits_Init+0x8c>
		__ticks = 1;
    1efa:	81 e0       	ldi	r24, 0x01	; 1
    1efc:	90 e0       	ldi	r25, 0x00	; 0
    1efe:	98 ab       	std	Y+48, r25	; 0x30
    1f00:	8f a7       	std	Y+47, r24	; 0x2f
    1f02:	3f c0       	rjmp	.+126    	; 0x1f82 <HCLCD_Vid8Bits_Init+0x10a>
	else if (__tmp > 65535)
    1f04:	69 a9       	ldd	r22, Y+49	; 0x31
    1f06:	7a a9       	ldd	r23, Y+50	; 0x32
    1f08:	8b a9       	ldd	r24, Y+51	; 0x33
    1f0a:	9c a9       	ldd	r25, Y+52	; 0x34
    1f0c:	20 e0       	ldi	r18, 0x00	; 0
    1f0e:	3f ef       	ldi	r19, 0xFF	; 255
    1f10:	4f e7       	ldi	r20, 0x7F	; 127
    1f12:	57 e4       	ldi	r21, 0x47	; 71
    1f14:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f18:	18 16       	cp	r1, r24
    1f1a:	4c f5       	brge	.+82     	; 0x1f6e <HCLCD_Vid8Bits_Init+0xf6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f1c:	6d a9       	ldd	r22, Y+53	; 0x35
    1f1e:	7e a9       	ldd	r23, Y+54	; 0x36
    1f20:	8f a9       	ldd	r24, Y+55	; 0x37
    1f22:	98 ad       	ldd	r25, Y+56	; 0x38
    1f24:	20 e0       	ldi	r18, 0x00	; 0
    1f26:	30 e0       	ldi	r19, 0x00	; 0
    1f28:	40 e2       	ldi	r20, 0x20	; 32
    1f2a:	51 e4       	ldi	r21, 0x41	; 65
    1f2c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f30:	dc 01       	movw	r26, r24
    1f32:	cb 01       	movw	r24, r22
    1f34:	bc 01       	movw	r22, r24
    1f36:	cd 01       	movw	r24, r26
    1f38:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f3c:	dc 01       	movw	r26, r24
    1f3e:	cb 01       	movw	r24, r22
    1f40:	98 ab       	std	Y+48, r25	; 0x30
    1f42:	8f a7       	std	Y+47, r24	; 0x2f
    1f44:	0f c0       	rjmp	.+30     	; 0x1f64 <HCLCD_Vid8Bits_Init+0xec>
    1f46:	88 ec       	ldi	r24, 0xC8	; 200
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	9e a7       	std	Y+46, r25	; 0x2e
    1f4c:	8d a7       	std	Y+45, r24	; 0x2d
    1f4e:	8d a5       	ldd	r24, Y+45	; 0x2d
    1f50:	9e a5       	ldd	r25, Y+46	; 0x2e
    1f52:	01 97       	sbiw	r24, 0x01	; 1
    1f54:	f1 f7       	brne	.-4      	; 0x1f52 <HCLCD_Vid8Bits_Init+0xda>
    1f56:	9e a7       	std	Y+46, r25	; 0x2e
    1f58:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f5a:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f5c:	98 a9       	ldd	r25, Y+48	; 0x30
    1f5e:	01 97       	sbiw	r24, 0x01	; 1
    1f60:	98 ab       	std	Y+48, r25	; 0x30
    1f62:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f64:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f66:	98 a9       	ldd	r25, Y+48	; 0x30
    1f68:	00 97       	sbiw	r24, 0x00	; 0
    1f6a:	69 f7       	brne	.-38     	; 0x1f46 <HCLCD_Vid8Bits_Init+0xce>
    1f6c:	14 c0       	rjmp	.+40     	; 0x1f96 <HCLCD_Vid8Bits_Init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f6e:	69 a9       	ldd	r22, Y+49	; 0x31
    1f70:	7a a9       	ldd	r23, Y+50	; 0x32
    1f72:	8b a9       	ldd	r24, Y+51	; 0x33
    1f74:	9c a9       	ldd	r25, Y+52	; 0x34
    1f76:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f7a:	dc 01       	movw	r26, r24
    1f7c:	cb 01       	movw	r24, r22
    1f7e:	98 ab       	std	Y+48, r25	; 0x30
    1f80:	8f a7       	std	Y+47, r24	; 0x2f
    1f82:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f84:	98 a9       	ldd	r25, Y+48	; 0x30
    1f86:	9c a7       	std	Y+44, r25	; 0x2c
    1f88:	8b a7       	std	Y+43, r24	; 0x2b
    1f8a:	8b a5       	ldd	r24, Y+43	; 0x2b
    1f8c:	9c a5       	ldd	r25, Y+44	; 0x2c
    1f8e:	01 97       	sbiw	r24, 0x01	; 1
    1f90:	f1 f7       	brne	.-4      	; 0x1f8e <HCLCD_Vid8Bits_Init+0x116>
    1f92:	9c a7       	std	Y+44, r25	; 0x2c
    1f94:	8b a7       	std	Y+43, r24	; 0x2b

	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_FUNCTION_SET);
    1f96:	88 e2       	ldi	r24, 0x28	; 40
    1f98:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <HCLCD_VidWriteCommand_8Bits>
    1f9c:	80 e0       	ldi	r24, 0x00	; 0
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	a0 e8       	ldi	r26, 0x80	; 128
    1fa2:	bf e3       	ldi	r27, 0x3F	; 63
    1fa4:	8f a3       	std	Y+39, r24	; 0x27
    1fa6:	98 a7       	std	Y+40, r25	; 0x28
    1fa8:	a9 a7       	std	Y+41, r26	; 0x29
    1faa:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fac:	6f a1       	ldd	r22, Y+39	; 0x27
    1fae:	78 a5       	ldd	r23, Y+40	; 0x28
    1fb0:	89 a5       	ldd	r24, Y+41	; 0x29
    1fb2:	9a a5       	ldd	r25, Y+42	; 0x2a
    1fb4:	20 e0       	ldi	r18, 0x00	; 0
    1fb6:	30 e0       	ldi	r19, 0x00	; 0
    1fb8:	4a ef       	ldi	r20, 0xFA	; 250
    1fba:	54 e4       	ldi	r21, 0x44	; 68
    1fbc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fc0:	dc 01       	movw	r26, r24
    1fc2:	cb 01       	movw	r24, r22
    1fc4:	8b a3       	std	Y+35, r24	; 0x23
    1fc6:	9c a3       	std	Y+36, r25	; 0x24
    1fc8:	ad a3       	std	Y+37, r26	; 0x25
    1fca:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1fcc:	6b a1       	ldd	r22, Y+35	; 0x23
    1fce:	7c a1       	ldd	r23, Y+36	; 0x24
    1fd0:	8d a1       	ldd	r24, Y+37	; 0x25
    1fd2:	9e a1       	ldd	r25, Y+38	; 0x26
    1fd4:	20 e0       	ldi	r18, 0x00	; 0
    1fd6:	30 e0       	ldi	r19, 0x00	; 0
    1fd8:	40 e8       	ldi	r20, 0x80	; 128
    1fda:	5f e3       	ldi	r21, 0x3F	; 63
    1fdc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1fe0:	88 23       	and	r24, r24
    1fe2:	2c f4       	brge	.+10     	; 0x1fee <HCLCD_Vid8Bits_Init+0x176>
		__ticks = 1;
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	90 e0       	ldi	r25, 0x00	; 0
    1fe8:	9a a3       	std	Y+34, r25	; 0x22
    1fea:	89 a3       	std	Y+33, r24	; 0x21
    1fec:	3f c0       	rjmp	.+126    	; 0x206c <HCLCD_Vid8Bits_Init+0x1f4>
	else if (__tmp > 65535)
    1fee:	6b a1       	ldd	r22, Y+35	; 0x23
    1ff0:	7c a1       	ldd	r23, Y+36	; 0x24
    1ff2:	8d a1       	ldd	r24, Y+37	; 0x25
    1ff4:	9e a1       	ldd	r25, Y+38	; 0x26
    1ff6:	20 e0       	ldi	r18, 0x00	; 0
    1ff8:	3f ef       	ldi	r19, 0xFF	; 255
    1ffa:	4f e7       	ldi	r20, 0x7F	; 127
    1ffc:	57 e4       	ldi	r21, 0x47	; 71
    1ffe:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2002:	18 16       	cp	r1, r24
    2004:	4c f5       	brge	.+82     	; 0x2058 <HCLCD_Vid8Bits_Init+0x1e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2006:	6f a1       	ldd	r22, Y+39	; 0x27
    2008:	78 a5       	ldd	r23, Y+40	; 0x28
    200a:	89 a5       	ldd	r24, Y+41	; 0x29
    200c:	9a a5       	ldd	r25, Y+42	; 0x2a
    200e:	20 e0       	ldi	r18, 0x00	; 0
    2010:	30 e0       	ldi	r19, 0x00	; 0
    2012:	40 e2       	ldi	r20, 0x20	; 32
    2014:	51 e4       	ldi	r21, 0x41	; 65
    2016:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    201a:	dc 01       	movw	r26, r24
    201c:	cb 01       	movw	r24, r22
    201e:	bc 01       	movw	r22, r24
    2020:	cd 01       	movw	r24, r26
    2022:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2026:	dc 01       	movw	r26, r24
    2028:	cb 01       	movw	r24, r22
    202a:	9a a3       	std	Y+34, r25	; 0x22
    202c:	89 a3       	std	Y+33, r24	; 0x21
    202e:	0f c0       	rjmp	.+30     	; 0x204e <HCLCD_Vid8Bits_Init+0x1d6>
    2030:	88 ec       	ldi	r24, 0xC8	; 200
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	98 a3       	std	Y+32, r25	; 0x20
    2036:	8f 8f       	std	Y+31, r24	; 0x1f
    2038:	8f 8d       	ldd	r24, Y+31	; 0x1f
    203a:	98 a1       	ldd	r25, Y+32	; 0x20
    203c:	01 97       	sbiw	r24, 0x01	; 1
    203e:	f1 f7       	brne	.-4      	; 0x203c <HCLCD_Vid8Bits_Init+0x1c4>
    2040:	98 a3       	std	Y+32, r25	; 0x20
    2042:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2044:	89 a1       	ldd	r24, Y+33	; 0x21
    2046:	9a a1       	ldd	r25, Y+34	; 0x22
    2048:	01 97       	sbiw	r24, 0x01	; 1
    204a:	9a a3       	std	Y+34, r25	; 0x22
    204c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    204e:	89 a1       	ldd	r24, Y+33	; 0x21
    2050:	9a a1       	ldd	r25, Y+34	; 0x22
    2052:	00 97       	sbiw	r24, 0x00	; 0
    2054:	69 f7       	brne	.-38     	; 0x2030 <HCLCD_Vid8Bits_Init+0x1b8>
    2056:	14 c0       	rjmp	.+40     	; 0x2080 <HCLCD_Vid8Bits_Init+0x208>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2058:	6b a1       	ldd	r22, Y+35	; 0x23
    205a:	7c a1       	ldd	r23, Y+36	; 0x24
    205c:	8d a1       	ldd	r24, Y+37	; 0x25
    205e:	9e a1       	ldd	r25, Y+38	; 0x26
    2060:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2064:	dc 01       	movw	r26, r24
    2066:	cb 01       	movw	r24, r22
    2068:	9a a3       	std	Y+34, r25	; 0x22
    206a:	89 a3       	std	Y+33, r24	; 0x21
    206c:	89 a1       	ldd	r24, Y+33	; 0x21
    206e:	9a a1       	ldd	r25, Y+34	; 0x22
    2070:	9e 8f       	std	Y+30, r25	; 0x1e
    2072:	8d 8f       	std	Y+29, r24	; 0x1d
    2074:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2076:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2078:	01 97       	sbiw	r24, 0x01	; 1
    207a:	f1 f7       	brne	.-4      	; 0x2078 <HCLCD_Vid8Bits_Init+0x200>
    207c:	9e 8f       	std	Y+30, r25	; 0x1e
    207e:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_DISPLAY_ON_OFF);
    2080:	8c e0       	ldi	r24, 0x0C	; 12
    2082:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <HCLCD_VidWriteCommand_8Bits>
    2086:	80 e0       	ldi	r24, 0x00	; 0
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	a0 e8       	ldi	r26, 0x80	; 128
    208c:	bf e3       	ldi	r27, 0x3F	; 63
    208e:	89 8f       	std	Y+25, r24	; 0x19
    2090:	9a 8f       	std	Y+26, r25	; 0x1a
    2092:	ab 8f       	std	Y+27, r26	; 0x1b
    2094:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2096:	69 8d       	ldd	r22, Y+25	; 0x19
    2098:	7a 8d       	ldd	r23, Y+26	; 0x1a
    209a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    209c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    209e:	20 e0       	ldi	r18, 0x00	; 0
    20a0:	30 e0       	ldi	r19, 0x00	; 0
    20a2:	4a ef       	ldi	r20, 0xFA	; 250
    20a4:	54 e4       	ldi	r21, 0x44	; 68
    20a6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20aa:	dc 01       	movw	r26, r24
    20ac:	cb 01       	movw	r24, r22
    20ae:	8d 8b       	std	Y+21, r24	; 0x15
    20b0:	9e 8b       	std	Y+22, r25	; 0x16
    20b2:	af 8b       	std	Y+23, r26	; 0x17
    20b4:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    20b6:	6d 89       	ldd	r22, Y+21	; 0x15
    20b8:	7e 89       	ldd	r23, Y+22	; 0x16
    20ba:	8f 89       	ldd	r24, Y+23	; 0x17
    20bc:	98 8d       	ldd	r25, Y+24	; 0x18
    20be:	20 e0       	ldi	r18, 0x00	; 0
    20c0:	30 e0       	ldi	r19, 0x00	; 0
    20c2:	40 e8       	ldi	r20, 0x80	; 128
    20c4:	5f e3       	ldi	r21, 0x3F	; 63
    20c6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    20ca:	88 23       	and	r24, r24
    20cc:	2c f4       	brge	.+10     	; 0x20d8 <HCLCD_Vid8Bits_Init+0x260>
		__ticks = 1;
    20ce:	81 e0       	ldi	r24, 0x01	; 1
    20d0:	90 e0       	ldi	r25, 0x00	; 0
    20d2:	9c 8b       	std	Y+20, r25	; 0x14
    20d4:	8b 8b       	std	Y+19, r24	; 0x13
    20d6:	3f c0       	rjmp	.+126    	; 0x2156 <HCLCD_Vid8Bits_Init+0x2de>
	else if (__tmp > 65535)
    20d8:	6d 89       	ldd	r22, Y+21	; 0x15
    20da:	7e 89       	ldd	r23, Y+22	; 0x16
    20dc:	8f 89       	ldd	r24, Y+23	; 0x17
    20de:	98 8d       	ldd	r25, Y+24	; 0x18
    20e0:	20 e0       	ldi	r18, 0x00	; 0
    20e2:	3f ef       	ldi	r19, 0xFF	; 255
    20e4:	4f e7       	ldi	r20, 0x7F	; 127
    20e6:	57 e4       	ldi	r21, 0x47	; 71
    20e8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    20ec:	18 16       	cp	r1, r24
    20ee:	4c f5       	brge	.+82     	; 0x2142 <HCLCD_Vid8Bits_Init+0x2ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    20f0:	69 8d       	ldd	r22, Y+25	; 0x19
    20f2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    20f4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    20f6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    20f8:	20 e0       	ldi	r18, 0x00	; 0
    20fa:	30 e0       	ldi	r19, 0x00	; 0
    20fc:	40 e2       	ldi	r20, 0x20	; 32
    20fe:	51 e4       	ldi	r21, 0x41	; 65
    2100:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2104:	dc 01       	movw	r26, r24
    2106:	cb 01       	movw	r24, r22
    2108:	bc 01       	movw	r22, r24
    210a:	cd 01       	movw	r24, r26
    210c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2110:	dc 01       	movw	r26, r24
    2112:	cb 01       	movw	r24, r22
    2114:	9c 8b       	std	Y+20, r25	; 0x14
    2116:	8b 8b       	std	Y+19, r24	; 0x13
    2118:	0f c0       	rjmp	.+30     	; 0x2138 <HCLCD_Vid8Bits_Init+0x2c0>
    211a:	88 ec       	ldi	r24, 0xC8	; 200
    211c:	90 e0       	ldi	r25, 0x00	; 0
    211e:	9a 8b       	std	Y+18, r25	; 0x12
    2120:	89 8b       	std	Y+17, r24	; 0x11
    2122:	89 89       	ldd	r24, Y+17	; 0x11
    2124:	9a 89       	ldd	r25, Y+18	; 0x12
    2126:	01 97       	sbiw	r24, 0x01	; 1
    2128:	f1 f7       	brne	.-4      	; 0x2126 <HCLCD_Vid8Bits_Init+0x2ae>
    212a:	9a 8b       	std	Y+18, r25	; 0x12
    212c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    212e:	8b 89       	ldd	r24, Y+19	; 0x13
    2130:	9c 89       	ldd	r25, Y+20	; 0x14
    2132:	01 97       	sbiw	r24, 0x01	; 1
    2134:	9c 8b       	std	Y+20, r25	; 0x14
    2136:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2138:	8b 89       	ldd	r24, Y+19	; 0x13
    213a:	9c 89       	ldd	r25, Y+20	; 0x14
    213c:	00 97       	sbiw	r24, 0x00	; 0
    213e:	69 f7       	brne	.-38     	; 0x211a <HCLCD_Vid8Bits_Init+0x2a2>
    2140:	14 c0       	rjmp	.+40     	; 0x216a <HCLCD_Vid8Bits_Init+0x2f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2142:	6d 89       	ldd	r22, Y+21	; 0x15
    2144:	7e 89       	ldd	r23, Y+22	; 0x16
    2146:	8f 89       	ldd	r24, Y+23	; 0x17
    2148:	98 8d       	ldd	r25, Y+24	; 0x18
    214a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    214e:	dc 01       	movw	r26, r24
    2150:	cb 01       	movw	r24, r22
    2152:	9c 8b       	std	Y+20, r25	; 0x14
    2154:	8b 8b       	std	Y+19, r24	; 0x13
    2156:	8b 89       	ldd	r24, Y+19	; 0x13
    2158:	9c 89       	ldd	r25, Y+20	; 0x14
    215a:	98 8b       	std	Y+16, r25	; 0x10
    215c:	8f 87       	std	Y+15, r24	; 0x0f
    215e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2160:	98 89       	ldd	r25, Y+16	; 0x10
    2162:	01 97       	sbiw	r24, 0x01	; 1
    2164:	f1 f7       	brne	.-4      	; 0x2162 <HCLCD_Vid8Bits_Init+0x2ea>
    2166:	98 8b       	std	Y+16, r25	; 0x10
    2168:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_8Bits(DISPLAY_CLEAR);
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <HCLCD_VidWriteCommand_8Bits>
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	a0 e0       	ldi	r26, 0x00	; 0
    2176:	b0 e4       	ldi	r27, 0x40	; 64
    2178:	8b 87       	std	Y+11, r24	; 0x0b
    217a:	9c 87       	std	Y+12, r25	; 0x0c
    217c:	ad 87       	std	Y+13, r26	; 0x0d
    217e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2180:	6b 85       	ldd	r22, Y+11	; 0x0b
    2182:	7c 85       	ldd	r23, Y+12	; 0x0c
    2184:	8d 85       	ldd	r24, Y+13	; 0x0d
    2186:	9e 85       	ldd	r25, Y+14	; 0x0e
    2188:	20 e0       	ldi	r18, 0x00	; 0
    218a:	30 e0       	ldi	r19, 0x00	; 0
    218c:	4a ef       	ldi	r20, 0xFA	; 250
    218e:	54 e4       	ldi	r21, 0x44	; 68
    2190:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2194:	dc 01       	movw	r26, r24
    2196:	cb 01       	movw	r24, r22
    2198:	8f 83       	std	Y+7, r24	; 0x07
    219a:	98 87       	std	Y+8, r25	; 0x08
    219c:	a9 87       	std	Y+9, r26	; 0x09
    219e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    21a0:	6f 81       	ldd	r22, Y+7	; 0x07
    21a2:	78 85       	ldd	r23, Y+8	; 0x08
    21a4:	89 85       	ldd	r24, Y+9	; 0x09
    21a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    21a8:	20 e0       	ldi	r18, 0x00	; 0
    21aa:	30 e0       	ldi	r19, 0x00	; 0
    21ac:	40 e8       	ldi	r20, 0x80	; 128
    21ae:	5f e3       	ldi	r21, 0x3F	; 63
    21b0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    21b4:	88 23       	and	r24, r24
    21b6:	2c f4       	brge	.+10     	; 0x21c2 <HCLCD_Vid8Bits_Init+0x34a>
		__ticks = 1;
    21b8:	81 e0       	ldi	r24, 0x01	; 1
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	9e 83       	std	Y+6, r25	; 0x06
    21be:	8d 83       	std	Y+5, r24	; 0x05
    21c0:	3f c0       	rjmp	.+126    	; 0x2240 <HCLCD_Vid8Bits_Init+0x3c8>
	else if (__tmp > 65535)
    21c2:	6f 81       	ldd	r22, Y+7	; 0x07
    21c4:	78 85       	ldd	r23, Y+8	; 0x08
    21c6:	89 85       	ldd	r24, Y+9	; 0x09
    21c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    21ca:	20 e0       	ldi	r18, 0x00	; 0
    21cc:	3f ef       	ldi	r19, 0xFF	; 255
    21ce:	4f e7       	ldi	r20, 0x7F	; 127
    21d0:	57 e4       	ldi	r21, 0x47	; 71
    21d2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    21d6:	18 16       	cp	r1, r24
    21d8:	4c f5       	brge	.+82     	; 0x222c <HCLCD_Vid8Bits_Init+0x3b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21da:	6b 85       	ldd	r22, Y+11	; 0x0b
    21dc:	7c 85       	ldd	r23, Y+12	; 0x0c
    21de:	8d 85       	ldd	r24, Y+13	; 0x0d
    21e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    21e2:	20 e0       	ldi	r18, 0x00	; 0
    21e4:	30 e0       	ldi	r19, 0x00	; 0
    21e6:	40 e2       	ldi	r20, 0x20	; 32
    21e8:	51 e4       	ldi	r21, 0x41	; 65
    21ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21ee:	dc 01       	movw	r26, r24
    21f0:	cb 01       	movw	r24, r22
    21f2:	bc 01       	movw	r22, r24
    21f4:	cd 01       	movw	r24, r26
    21f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21fa:	dc 01       	movw	r26, r24
    21fc:	cb 01       	movw	r24, r22
    21fe:	9e 83       	std	Y+6, r25	; 0x06
    2200:	8d 83       	std	Y+5, r24	; 0x05
    2202:	0f c0       	rjmp	.+30     	; 0x2222 <HCLCD_Vid8Bits_Init+0x3aa>
    2204:	88 ec       	ldi	r24, 0xC8	; 200
    2206:	90 e0       	ldi	r25, 0x00	; 0
    2208:	9c 83       	std	Y+4, r25	; 0x04
    220a:	8b 83       	std	Y+3, r24	; 0x03
    220c:	8b 81       	ldd	r24, Y+3	; 0x03
    220e:	9c 81       	ldd	r25, Y+4	; 0x04
    2210:	01 97       	sbiw	r24, 0x01	; 1
    2212:	f1 f7       	brne	.-4      	; 0x2210 <HCLCD_Vid8Bits_Init+0x398>
    2214:	9c 83       	std	Y+4, r25	; 0x04
    2216:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2218:	8d 81       	ldd	r24, Y+5	; 0x05
    221a:	9e 81       	ldd	r25, Y+6	; 0x06
    221c:	01 97       	sbiw	r24, 0x01	; 1
    221e:	9e 83       	std	Y+6, r25	; 0x06
    2220:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2222:	8d 81       	ldd	r24, Y+5	; 0x05
    2224:	9e 81       	ldd	r25, Y+6	; 0x06
    2226:	00 97       	sbiw	r24, 0x00	; 0
    2228:	69 f7       	brne	.-38     	; 0x2204 <HCLCD_Vid8Bits_Init+0x38c>
    222a:	14 c0       	rjmp	.+40     	; 0x2254 <HCLCD_Vid8Bits_Init+0x3dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    222c:	6f 81       	ldd	r22, Y+7	; 0x07
    222e:	78 85       	ldd	r23, Y+8	; 0x08
    2230:	89 85       	ldd	r24, Y+9	; 0x09
    2232:	9a 85       	ldd	r25, Y+10	; 0x0a
    2234:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2238:	dc 01       	movw	r26, r24
    223a:	cb 01       	movw	r24, r22
    223c:	9e 83       	std	Y+6, r25	; 0x06
    223e:	8d 83       	std	Y+5, r24	; 0x05
    2240:	8d 81       	ldd	r24, Y+5	; 0x05
    2242:	9e 81       	ldd	r25, Y+6	; 0x06
    2244:	9a 83       	std	Y+2, r25	; 0x02
    2246:	89 83       	std	Y+1, r24	; 0x01
    2248:	89 81       	ldd	r24, Y+1	; 0x01
    224a:	9a 81       	ldd	r25, Y+2	; 0x02
    224c:	01 97       	sbiw	r24, 0x01	; 1
    224e:	f1 f7       	brne	.-4      	; 0x224c <HCLCD_Vid8Bits_Init+0x3d4>
    2250:	9a 83       	std	Y+2, r25	; 0x02
    2252:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_ENTRY_MODE_SET);
    2254:	86 e0       	ldi	r24, 0x06	; 6
    2256:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <HCLCD_VidWriteCommand_8Bits>
}
    225a:	e8 96       	adiw	r28, 0x38	; 56
    225c:	0f b6       	in	r0, 0x3f	; 63
    225e:	f8 94       	cli
    2260:	de bf       	out	0x3e, r29	; 62
    2262:	0f be       	out	0x3f, r0	; 63
    2264:	cd bf       	out	0x3d, r28	; 61
    2266:	cf 91       	pop	r28
    2268:	df 91       	pop	r29
    226a:	08 95       	ret

0000226c <HCLCD_VidWriteChar_8Bits>:
void HCLCD_VidWriteChar_8Bits(u8 Copy_u8Data)
{
    226c:	df 93       	push	r29
    226e:	cf 93       	push	r28
    2270:	cd b7       	in	r28, 0x3d	; 61
    2272:	de b7       	in	r29, 0x3e	; 62
    2274:	6d 97       	sbiw	r28, 0x1d	; 29
    2276:	0f b6       	in	r0, 0x3f	; 63
    2278:	f8 94       	cli
    227a:	de bf       	out	0x3e, r29	; 62
    227c:	0f be       	out	0x3f, r0	; 63
    227e:	cd bf       	out	0x3d, r28	; 61
    2280:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Data register--> Write one on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    2282:	81 e0       	ldi	r24, 0x01	; 1
    2284:	60 e0       	ldi	r22, 0x00	; 0
    2286:	41 e0       	ldi	r20, 0x01	; 1
    2288:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
    228c:	80 e0       	ldi	r24, 0x00	; 0
    228e:	60 e0       	ldi	r22, 0x00	; 0
    2290:	40 e0       	ldi	r20, 0x00	; 0
    2292:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Data);
    2296:	80 e0       	ldi	r24, 0x00	; 0
    2298:	6d 8d       	ldd	r22, Y+29	; 0x1d
    229a:	0e 94 8b 0a 	call	0x1516	; 0x1516 <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    229e:	82 e0       	ldi	r24, 0x02	; 2
    22a0:	60 e0       	ldi	r22, 0x00	; 0
    22a2:	41 e0       	ldi	r20, 0x01	; 1
    22a4:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
    22a8:	80 e0       	ldi	r24, 0x00	; 0
    22aa:	90 e0       	ldi	r25, 0x00	; 0
    22ac:	a0 e0       	ldi	r26, 0x00	; 0
    22ae:	b0 e4       	ldi	r27, 0x40	; 64
    22b0:	89 8f       	std	Y+25, r24	; 0x19
    22b2:	9a 8f       	std	Y+26, r25	; 0x1a
    22b4:	ab 8f       	std	Y+27, r26	; 0x1b
    22b6:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22b8:	69 8d       	ldd	r22, Y+25	; 0x19
    22ba:	7a 8d       	ldd	r23, Y+26	; 0x1a
    22bc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    22be:	9c 8d       	ldd	r25, Y+28	; 0x1c
    22c0:	20 e0       	ldi	r18, 0x00	; 0
    22c2:	30 e0       	ldi	r19, 0x00	; 0
    22c4:	4a ef       	ldi	r20, 0xFA	; 250
    22c6:	54 e4       	ldi	r21, 0x44	; 68
    22c8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22cc:	dc 01       	movw	r26, r24
    22ce:	cb 01       	movw	r24, r22
    22d0:	8d 8b       	std	Y+21, r24	; 0x15
    22d2:	9e 8b       	std	Y+22, r25	; 0x16
    22d4:	af 8b       	std	Y+23, r26	; 0x17
    22d6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    22d8:	6d 89       	ldd	r22, Y+21	; 0x15
    22da:	7e 89       	ldd	r23, Y+22	; 0x16
    22dc:	8f 89       	ldd	r24, Y+23	; 0x17
    22de:	98 8d       	ldd	r25, Y+24	; 0x18
    22e0:	20 e0       	ldi	r18, 0x00	; 0
    22e2:	30 e0       	ldi	r19, 0x00	; 0
    22e4:	40 e8       	ldi	r20, 0x80	; 128
    22e6:	5f e3       	ldi	r21, 0x3F	; 63
    22e8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    22ec:	88 23       	and	r24, r24
    22ee:	2c f4       	brge	.+10     	; 0x22fa <HCLCD_VidWriteChar_8Bits+0x8e>
		__ticks = 1;
    22f0:	81 e0       	ldi	r24, 0x01	; 1
    22f2:	90 e0       	ldi	r25, 0x00	; 0
    22f4:	9c 8b       	std	Y+20, r25	; 0x14
    22f6:	8b 8b       	std	Y+19, r24	; 0x13
    22f8:	3f c0       	rjmp	.+126    	; 0x2378 <HCLCD_VidWriteChar_8Bits+0x10c>
	else if (__tmp > 65535)
    22fa:	6d 89       	ldd	r22, Y+21	; 0x15
    22fc:	7e 89       	ldd	r23, Y+22	; 0x16
    22fe:	8f 89       	ldd	r24, Y+23	; 0x17
    2300:	98 8d       	ldd	r25, Y+24	; 0x18
    2302:	20 e0       	ldi	r18, 0x00	; 0
    2304:	3f ef       	ldi	r19, 0xFF	; 255
    2306:	4f e7       	ldi	r20, 0x7F	; 127
    2308:	57 e4       	ldi	r21, 0x47	; 71
    230a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    230e:	18 16       	cp	r1, r24
    2310:	4c f5       	brge	.+82     	; 0x2364 <HCLCD_VidWriteChar_8Bits+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2312:	69 8d       	ldd	r22, Y+25	; 0x19
    2314:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2316:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2318:	9c 8d       	ldd	r25, Y+28	; 0x1c
    231a:	20 e0       	ldi	r18, 0x00	; 0
    231c:	30 e0       	ldi	r19, 0x00	; 0
    231e:	40 e2       	ldi	r20, 0x20	; 32
    2320:	51 e4       	ldi	r21, 0x41	; 65
    2322:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2326:	dc 01       	movw	r26, r24
    2328:	cb 01       	movw	r24, r22
    232a:	bc 01       	movw	r22, r24
    232c:	cd 01       	movw	r24, r26
    232e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2332:	dc 01       	movw	r26, r24
    2334:	cb 01       	movw	r24, r22
    2336:	9c 8b       	std	Y+20, r25	; 0x14
    2338:	8b 8b       	std	Y+19, r24	; 0x13
    233a:	0f c0       	rjmp	.+30     	; 0x235a <HCLCD_VidWriteChar_8Bits+0xee>
    233c:	88 ec       	ldi	r24, 0xC8	; 200
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	9a 8b       	std	Y+18, r25	; 0x12
    2342:	89 8b       	std	Y+17, r24	; 0x11
    2344:	89 89       	ldd	r24, Y+17	; 0x11
    2346:	9a 89       	ldd	r25, Y+18	; 0x12
    2348:	01 97       	sbiw	r24, 0x01	; 1
    234a:	f1 f7       	brne	.-4      	; 0x2348 <HCLCD_VidWriteChar_8Bits+0xdc>
    234c:	9a 8b       	std	Y+18, r25	; 0x12
    234e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2350:	8b 89       	ldd	r24, Y+19	; 0x13
    2352:	9c 89       	ldd	r25, Y+20	; 0x14
    2354:	01 97       	sbiw	r24, 0x01	; 1
    2356:	9c 8b       	std	Y+20, r25	; 0x14
    2358:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    235a:	8b 89       	ldd	r24, Y+19	; 0x13
    235c:	9c 89       	ldd	r25, Y+20	; 0x14
    235e:	00 97       	sbiw	r24, 0x00	; 0
    2360:	69 f7       	brne	.-38     	; 0x233c <HCLCD_VidWriteChar_8Bits+0xd0>
    2362:	14 c0       	rjmp	.+40     	; 0x238c <HCLCD_VidWriteChar_8Bits+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2364:	6d 89       	ldd	r22, Y+21	; 0x15
    2366:	7e 89       	ldd	r23, Y+22	; 0x16
    2368:	8f 89       	ldd	r24, Y+23	; 0x17
    236a:	98 8d       	ldd	r25, Y+24	; 0x18
    236c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2370:	dc 01       	movw	r26, r24
    2372:	cb 01       	movw	r24, r22
    2374:	9c 8b       	std	Y+20, r25	; 0x14
    2376:	8b 8b       	std	Y+19, r24	; 0x13
    2378:	8b 89       	ldd	r24, Y+19	; 0x13
    237a:	9c 89       	ldd	r25, Y+20	; 0x14
    237c:	98 8b       	std	Y+16, r25	; 0x10
    237e:	8f 87       	std	Y+15, r24	; 0x0f
    2380:	8f 85       	ldd	r24, Y+15	; 0x0f
    2382:	98 89       	ldd	r25, Y+16	; 0x10
    2384:	01 97       	sbiw	r24, 0x01	; 1
    2386:	f1 f7       	brne	.-4      	; 0x2384 <HCLCD_VidWriteChar_8Bits+0x118>
    2388:	98 8b       	std	Y+16, r25	; 0x10
    238a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    238c:	82 e0       	ldi	r24, 0x02	; 2
    238e:	60 e0       	ldi	r22, 0x00	; 0
    2390:	40 e0       	ldi	r20, 0x00	; 0
    2392:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
    2396:	80 e0       	ldi	r24, 0x00	; 0
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	a0 e0       	ldi	r26, 0x00	; 0
    239c:	b0 e4       	ldi	r27, 0x40	; 64
    239e:	8b 87       	std	Y+11, r24	; 0x0b
    23a0:	9c 87       	std	Y+12, r25	; 0x0c
    23a2:	ad 87       	std	Y+13, r26	; 0x0d
    23a4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    23a6:	6b 85       	ldd	r22, Y+11	; 0x0b
    23a8:	7c 85       	ldd	r23, Y+12	; 0x0c
    23aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    23ac:	9e 85       	ldd	r25, Y+14	; 0x0e
    23ae:	20 e0       	ldi	r18, 0x00	; 0
    23b0:	30 e0       	ldi	r19, 0x00	; 0
    23b2:	4a ef       	ldi	r20, 0xFA	; 250
    23b4:	54 e4       	ldi	r21, 0x44	; 68
    23b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23ba:	dc 01       	movw	r26, r24
    23bc:	cb 01       	movw	r24, r22
    23be:	8f 83       	std	Y+7, r24	; 0x07
    23c0:	98 87       	std	Y+8, r25	; 0x08
    23c2:	a9 87       	std	Y+9, r26	; 0x09
    23c4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    23c6:	6f 81       	ldd	r22, Y+7	; 0x07
    23c8:	78 85       	ldd	r23, Y+8	; 0x08
    23ca:	89 85       	ldd	r24, Y+9	; 0x09
    23cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    23ce:	20 e0       	ldi	r18, 0x00	; 0
    23d0:	30 e0       	ldi	r19, 0x00	; 0
    23d2:	40 e8       	ldi	r20, 0x80	; 128
    23d4:	5f e3       	ldi	r21, 0x3F	; 63
    23d6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    23da:	88 23       	and	r24, r24
    23dc:	2c f4       	brge	.+10     	; 0x23e8 <HCLCD_VidWriteChar_8Bits+0x17c>
		__ticks = 1;
    23de:	81 e0       	ldi	r24, 0x01	; 1
    23e0:	90 e0       	ldi	r25, 0x00	; 0
    23e2:	9e 83       	std	Y+6, r25	; 0x06
    23e4:	8d 83       	std	Y+5, r24	; 0x05
    23e6:	3f c0       	rjmp	.+126    	; 0x2466 <HCLCD_VidWriteChar_8Bits+0x1fa>
	else if (__tmp > 65535)
    23e8:	6f 81       	ldd	r22, Y+7	; 0x07
    23ea:	78 85       	ldd	r23, Y+8	; 0x08
    23ec:	89 85       	ldd	r24, Y+9	; 0x09
    23ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    23f0:	20 e0       	ldi	r18, 0x00	; 0
    23f2:	3f ef       	ldi	r19, 0xFF	; 255
    23f4:	4f e7       	ldi	r20, 0x7F	; 127
    23f6:	57 e4       	ldi	r21, 0x47	; 71
    23f8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    23fc:	18 16       	cp	r1, r24
    23fe:	4c f5       	brge	.+82     	; 0x2452 <HCLCD_VidWriteChar_8Bits+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2400:	6b 85       	ldd	r22, Y+11	; 0x0b
    2402:	7c 85       	ldd	r23, Y+12	; 0x0c
    2404:	8d 85       	ldd	r24, Y+13	; 0x0d
    2406:	9e 85       	ldd	r25, Y+14	; 0x0e
    2408:	20 e0       	ldi	r18, 0x00	; 0
    240a:	30 e0       	ldi	r19, 0x00	; 0
    240c:	40 e2       	ldi	r20, 0x20	; 32
    240e:	51 e4       	ldi	r21, 0x41	; 65
    2410:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2414:	dc 01       	movw	r26, r24
    2416:	cb 01       	movw	r24, r22
    2418:	bc 01       	movw	r22, r24
    241a:	cd 01       	movw	r24, r26
    241c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2420:	dc 01       	movw	r26, r24
    2422:	cb 01       	movw	r24, r22
    2424:	9e 83       	std	Y+6, r25	; 0x06
    2426:	8d 83       	std	Y+5, r24	; 0x05
    2428:	0f c0       	rjmp	.+30     	; 0x2448 <HCLCD_VidWriteChar_8Bits+0x1dc>
    242a:	88 ec       	ldi	r24, 0xC8	; 200
    242c:	90 e0       	ldi	r25, 0x00	; 0
    242e:	9c 83       	std	Y+4, r25	; 0x04
    2430:	8b 83       	std	Y+3, r24	; 0x03
    2432:	8b 81       	ldd	r24, Y+3	; 0x03
    2434:	9c 81       	ldd	r25, Y+4	; 0x04
    2436:	01 97       	sbiw	r24, 0x01	; 1
    2438:	f1 f7       	brne	.-4      	; 0x2436 <HCLCD_VidWriteChar_8Bits+0x1ca>
    243a:	9c 83       	std	Y+4, r25	; 0x04
    243c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    243e:	8d 81       	ldd	r24, Y+5	; 0x05
    2440:	9e 81       	ldd	r25, Y+6	; 0x06
    2442:	01 97       	sbiw	r24, 0x01	; 1
    2444:	9e 83       	std	Y+6, r25	; 0x06
    2446:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2448:	8d 81       	ldd	r24, Y+5	; 0x05
    244a:	9e 81       	ldd	r25, Y+6	; 0x06
    244c:	00 97       	sbiw	r24, 0x00	; 0
    244e:	69 f7       	brne	.-38     	; 0x242a <HCLCD_VidWriteChar_8Bits+0x1be>
    2450:	14 c0       	rjmp	.+40     	; 0x247a <HCLCD_VidWriteChar_8Bits+0x20e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2452:	6f 81       	ldd	r22, Y+7	; 0x07
    2454:	78 85       	ldd	r23, Y+8	; 0x08
    2456:	89 85       	ldd	r24, Y+9	; 0x09
    2458:	9a 85       	ldd	r25, Y+10	; 0x0a
    245a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    245e:	dc 01       	movw	r26, r24
    2460:	cb 01       	movw	r24, r22
    2462:	9e 83       	std	Y+6, r25	; 0x06
    2464:	8d 83       	std	Y+5, r24	; 0x05
    2466:	8d 81       	ldd	r24, Y+5	; 0x05
    2468:	9e 81       	ldd	r25, Y+6	; 0x06
    246a:	9a 83       	std	Y+2, r25	; 0x02
    246c:	89 83       	std	Y+1, r24	; 0x01
    246e:	89 81       	ldd	r24, Y+1	; 0x01
    2470:	9a 81       	ldd	r25, Y+2	; 0x02
    2472:	01 97       	sbiw	r24, 0x01	; 1
    2474:	f1 f7       	brne	.-4      	; 0x2472 <HCLCD_VidWriteChar_8Bits+0x206>
    2476:	9a 83       	std	Y+2, r25	; 0x02
    2478:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    247a:	82 e0       	ldi	r24, 0x02	; 2
    247c:	60 e0       	ldi	r22, 0x00	; 0
    247e:	41 e0       	ldi	r20, 0x01	; 1
    2480:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
}
    2484:	6d 96       	adiw	r28, 0x1d	; 29
    2486:	0f b6       	in	r0, 0x3f	; 63
    2488:	f8 94       	cli
    248a:	de bf       	out	0x3e, r29	; 62
    248c:	0f be       	out	0x3f, r0	; 63
    248e:	cd bf       	out	0x3d, r28	; 61
    2490:	cf 91       	pop	r28
    2492:	df 91       	pop	r29
    2494:	08 95       	ret

00002496 <HCLCD_VidWriteString_8Bits>:

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
    2496:	df 93       	push	r29
    2498:	cf 93       	push	r28
    249a:	00 d0       	rcall	.+0      	; 0x249c <HCLCD_VidWriteString_8Bits+0x6>
    249c:	0f 92       	push	r0
    249e:	cd b7       	in	r28, 0x3d	; 61
    24a0:	de b7       	in	r29, 0x3e	; 62
    24a2:	9b 83       	std	Y+3, r25	; 0x03
    24a4:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    24a6:	19 82       	std	Y+1, r1	; 0x01
    24a8:	0e c0       	rjmp	.+28     	; 0x24c6 <HCLCD_VidWriteString_8Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
    24aa:	89 81       	ldd	r24, Y+1	; 0x01
    24ac:	28 2f       	mov	r18, r24
    24ae:	30 e0       	ldi	r19, 0x00	; 0
    24b0:	8a 81       	ldd	r24, Y+2	; 0x02
    24b2:	9b 81       	ldd	r25, Y+3	; 0x03
    24b4:	fc 01       	movw	r30, r24
    24b6:	e2 0f       	add	r30, r18
    24b8:	f3 1f       	adc	r31, r19
    24ba:	80 81       	ld	r24, Z
    24bc:	0e 94 36 11 	call	0x226c	; 0x226c <HCLCD_VidWriteChar_8Bits>
		Loc_u8Count++;
    24c0:	89 81       	ldd	r24, Y+1	; 0x01
    24c2:	8f 5f       	subi	r24, 0xFF	; 255
    24c4:	89 83       	std	Y+1, r24	; 0x01
}

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    24c6:	89 81       	ldd	r24, Y+1	; 0x01
    24c8:	28 2f       	mov	r18, r24
    24ca:	30 e0       	ldi	r19, 0x00	; 0
    24cc:	8a 81       	ldd	r24, Y+2	; 0x02
    24ce:	9b 81       	ldd	r25, Y+3	; 0x03
    24d0:	fc 01       	movw	r30, r24
    24d2:	e2 0f       	add	r30, r18
    24d4:	f3 1f       	adc	r31, r19
    24d6:	80 81       	ld	r24, Z
    24d8:	88 23       	and	r24, r24
    24da:	39 f7       	brne	.-50     	; 0x24aa <HCLCD_VidWriteString_8Bits+0x14>
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    24dc:	0f 90       	pop	r0
    24de:	0f 90       	pop	r0
    24e0:	0f 90       	pop	r0
    24e2:	cf 91       	pop	r28
    24e4:	df 91       	pop	r29
    24e6:	08 95       	ret

000024e8 <HCLCD_VidWriteNumber_8Bits>:
void HCLCD_VidWriteNumber_8Bits(u32 Copy_u8Number)
{
    24e8:	0f 93       	push	r16
    24ea:	1f 93       	push	r17
    24ec:	df 93       	push	r29
    24ee:	cf 93       	push	r28
    24f0:	cd b7       	in	r28, 0x3d	; 61
    24f2:	de b7       	in	r29, 0x3e	; 62
    24f4:	60 97       	sbiw	r28, 0x10	; 16
    24f6:	0f b6       	in	r0, 0x3f	; 63
    24f8:	f8 94       	cli
    24fa:	de bf       	out	0x3e, r29	; 62
    24fc:	0f be       	out	0x3f, r0	; 63
    24fe:	cd bf       	out	0x3d, r28	; 61
    2500:	6d 87       	std	Y+13, r22	; 0x0d
    2502:	7e 87       	std	Y+14, r23	; 0x0e
    2504:	8f 87       	std	Y+15, r24	; 0x0f
    2506:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    2508:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    250a:	8d 85       	ldd	r24, Y+13	; 0x0d
    250c:	9e 85       	ldd	r25, Y+14	; 0x0e
    250e:	af 85       	ldd	r26, Y+15	; 0x0f
    2510:	b8 89       	ldd	r27, Y+16	; 0x10
    2512:	00 97       	sbiw	r24, 0x00	; 0
    2514:	a1 05       	cpc	r26, r1
    2516:	b1 05       	cpc	r27, r1
    2518:	09 f4       	brne	.+2      	; 0x251c <HCLCD_VidWriteNumber_8Bits+0x34>
    251a:	4f c0       	rjmp	.+158    	; 0x25ba <HCLCD_VidWriteNumber_8Bits+0xd2>
    251c:	2d c0       	rjmp	.+90     	; 0x2578 <HCLCD_VidWriteNumber_8Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    251e:	8a 81       	ldd	r24, Y+2	; 0x02
    2520:	08 2f       	mov	r16, r24
    2522:	10 e0       	ldi	r17, 0x00	; 0
    2524:	8d 85       	ldd	r24, Y+13	; 0x0d
    2526:	9e 85       	ldd	r25, Y+14	; 0x0e
    2528:	af 85       	ldd	r26, Y+15	; 0x0f
    252a:	b8 89       	ldd	r27, Y+16	; 0x10
    252c:	2a e0       	ldi	r18, 0x0A	; 10
    252e:	30 e0       	ldi	r19, 0x00	; 0
    2530:	40 e0       	ldi	r20, 0x00	; 0
    2532:	50 e0       	ldi	r21, 0x00	; 0
    2534:	bc 01       	movw	r22, r24
    2536:	cd 01       	movw	r24, r26
    2538:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__udivmodsi4>
    253c:	dc 01       	movw	r26, r24
    253e:	cb 01       	movw	r24, r22
    2540:	28 2f       	mov	r18, r24
    2542:	ce 01       	movw	r24, r28
    2544:	03 96       	adiw	r24, 0x03	; 3
    2546:	fc 01       	movw	r30, r24
    2548:	e0 0f       	add	r30, r16
    254a:	f1 1f       	adc	r31, r17
    254c:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    254e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2550:	9e 85       	ldd	r25, Y+14	; 0x0e
    2552:	af 85       	ldd	r26, Y+15	; 0x0f
    2554:	b8 89       	ldd	r27, Y+16	; 0x10
    2556:	2a e0       	ldi	r18, 0x0A	; 10
    2558:	30 e0       	ldi	r19, 0x00	; 0
    255a:	40 e0       	ldi	r20, 0x00	; 0
    255c:	50 e0       	ldi	r21, 0x00	; 0
    255e:	bc 01       	movw	r22, r24
    2560:	cd 01       	movw	r24, r26
    2562:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__udivmodsi4>
    2566:	da 01       	movw	r26, r20
    2568:	c9 01       	movw	r24, r18
    256a:	8d 87       	std	Y+13, r24	; 0x0d
    256c:	9e 87       	std	Y+14, r25	; 0x0e
    256e:	af 87       	std	Y+15, r26	; 0x0f
    2570:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    2572:	8a 81       	ldd	r24, Y+2	; 0x02
    2574:	8f 5f       	subi	r24, 0xFF	; 255
    2576:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    2578:	8d 85       	ldd	r24, Y+13	; 0x0d
    257a:	9e 85       	ldd	r25, Y+14	; 0x0e
    257c:	af 85       	ldd	r26, Y+15	; 0x0f
    257e:	b8 89       	ldd	r27, Y+16	; 0x10
    2580:	00 97       	sbiw	r24, 0x00	; 0
    2582:	a1 05       	cpc	r26, r1
    2584:	b1 05       	cpc	r27, r1
    2586:	59 f6       	brne	.-106    	; 0x251e <HCLCD_VidWriteNumber_8Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    2588:	8a 81       	ldd	r24, Y+2	; 0x02
    258a:	81 50       	subi	r24, 0x01	; 1
    258c:	89 83       	std	Y+1, r24	; 0x01
    258e:	11 c0       	rjmp	.+34     	; 0x25b2 <HCLCD_VidWriteNumber_8Bits+0xca>
		{
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
    2590:	89 81       	ldd	r24, Y+1	; 0x01
    2592:	28 2f       	mov	r18, r24
    2594:	33 27       	eor	r19, r19
    2596:	27 fd       	sbrc	r18, 7
    2598:	30 95       	com	r19
    259a:	ce 01       	movw	r24, r28
    259c:	03 96       	adiw	r24, 0x03	; 3
    259e:	fc 01       	movw	r30, r24
    25a0:	e2 0f       	add	r30, r18
    25a2:	f3 1f       	adc	r31, r19
    25a4:	80 81       	ld	r24, Z
    25a6:	80 5d       	subi	r24, 0xD0	; 208
    25a8:	0e 94 36 11 	call	0x226c	; 0x226c <HCLCD_VidWriteChar_8Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    25ac:	89 81       	ldd	r24, Y+1	; 0x01
    25ae:	81 50       	subi	r24, 0x01	; 1
    25b0:	89 83       	std	Y+1, r24	; 0x01
    25b2:	89 81       	ldd	r24, Y+1	; 0x01
    25b4:	88 23       	and	r24, r24
    25b6:	64 f7       	brge	.-40     	; 0x2590 <HCLCD_VidWriteNumber_8Bits+0xa8>
    25b8:	03 c0       	rjmp	.+6      	; 0x25c0 <HCLCD_VidWriteNumber_8Bits+0xd8>
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    25ba:	80 e3       	ldi	r24, 0x30	; 48
    25bc:	0e 94 36 11 	call	0x226c	; 0x226c <HCLCD_VidWriteChar_8Bits>
	}
}
    25c0:	60 96       	adiw	r28, 0x10	; 16
    25c2:	0f b6       	in	r0, 0x3f	; 63
    25c4:	f8 94       	cli
    25c6:	de bf       	out	0x3e, r29	; 62
    25c8:	0f be       	out	0x3f, r0	; 63
    25ca:	cd bf       	out	0x3d, r28	; 61
    25cc:	cf 91       	pop	r28
    25ce:	df 91       	pop	r29
    25d0:	1f 91       	pop	r17
    25d2:	0f 91       	pop	r16
    25d4:	08 95       	ret

000025d6 <HCLCD_VidSetPosition>:
void HCLCD_VidSetPosition(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    25d6:	df 93       	push	r29
    25d8:	cf 93       	push	r28
    25da:	00 d0       	rcall	.+0      	; 0x25dc <HCLCD_VidSetPosition+0x6>
    25dc:	cd b7       	in	r28, 0x3d	; 61
    25de:	de b7       	in	r29, 0x3e	; 62
    25e0:	89 83       	std	Y+1, r24	; 0x01
    25e2:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    25e4:	89 81       	ldd	r24, Y+1	; 0x01
    25e6:	81 30       	cpi	r24, 0x01	; 1
    25e8:	41 f4       	brne	.+16     	; 0x25fa <HCLCD_VidSetPosition+0x24>
    25ea:	8a 81       	ldd	r24, Y+2	; 0x02
    25ec:	80 31       	cpi	r24, 0x10	; 16
    25ee:	28 f4       	brcc	.+10     	; 0x25fa <HCLCD_VidSetPosition+0x24>
	{
		HCLCD_VidWriteCommand_8Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    25f0:	8a 81       	ldd	r24, Y+2	; 0x02
    25f2:	80 58       	subi	r24, 0x80	; 128
    25f4:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <HCLCD_VidWriteCommand_8Bits>
    25f8:	0a c0       	rjmp	.+20     	; 0x260e <HCLCD_VidSetPosition+0x38>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    25fa:	89 81       	ldd	r24, Y+1	; 0x01
    25fc:	82 30       	cpi	r24, 0x02	; 2
    25fe:	39 f4       	brne	.+14     	; 0x260e <HCLCD_VidSetPosition+0x38>
    2600:	8a 81       	ldd	r24, Y+2	; 0x02
    2602:	80 31       	cpi	r24, 0x10	; 16
    2604:	20 f4       	brcc	.+8      	; 0x260e <HCLCD_VidSetPosition+0x38>
	{
		HCLCD_VidWriteCommand_8Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2606:	8a 81       	ldd	r24, Y+2	; 0x02
    2608:	80 54       	subi	r24, 0x40	; 64
    260a:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <HCLCD_VidWriteCommand_8Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    260e:	0f 90       	pop	r0
    2610:	0f 90       	pop	r0
    2612:	cf 91       	pop	r28
    2614:	df 91       	pop	r29
    2616:	08 95       	ret

00002618 <HCLCD_VidWriteCommand_4Bits>:

void HCLCD_VidWriteCommand_4Bits(u8 Copy_u8Command)
{
    2618:	df 93       	push	r29
    261a:	cf 93       	push	r28
    261c:	cd b7       	in	r28, 0x3d	; 61
    261e:	de b7       	in	r29, 0x3e	; 62
    2620:	60 97       	sbiw	r28, 0x10	; 16
    2622:	0f b6       	in	r0, 0x3f	; 63
    2624:	f8 94       	cli
    2626:	de bf       	out	0x3e, r29	; 62
    2628:	0f be       	out	0x3f, r0	; 63
    262a:	cd bf       	out	0x3d, r28	; 61
    262c:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyCommand;
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    262e:	81 e0       	ldi	r24, 0x01	; 1
    2630:	60 e0       	ldi	r22, 0x00	; 0
    2632:	40 e0       	ldi	r20, 0x00	; 0
    2634:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
    2638:	80 e0       	ldi	r24, 0x00	; 0
    263a:	60 e0       	ldi	r22, 0x00	; 0
    263c:	40 e0       	ldi	r20, 0x00	; 0
    263e:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	/*Send  Command*/
	LOC_u8CopyCommand=(Copy_u8Command&0x0F)<<HCLCD_PINSTART;
    2642:	88 89       	ldd	r24, Y+16	; 0x10
    2644:	8f 70       	andi	r24, 0x0F	; 15
    2646:	88 0f       	add	r24, r24
    2648:	88 0f       	add	r24, r24
    264a:	88 0f       	add	r24, r24
    264c:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyCommand);
    264e:	83 e0       	ldi	r24, 0x03	; 3
    2650:	60 e0       	ldi	r22, 0x00	; 0
    2652:	4f 85       	ldd	r20, Y+15	; 0x0f
    2654:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    2658:	82 e0       	ldi	r24, 0x02	; 2
    265a:	60 e0       	ldi	r22, 0x00	; 0
    265c:	41 e0       	ldi	r20, 0x01	; 1
    265e:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
    2662:	80 e0       	ldi	r24, 0x00	; 0
    2664:	90 e0       	ldi	r25, 0x00	; 0
    2666:	a0 e0       	ldi	r26, 0x00	; 0
    2668:	b0 e4       	ldi	r27, 0x40	; 64
    266a:	8b 87       	std	Y+11, r24	; 0x0b
    266c:	9c 87       	std	Y+12, r25	; 0x0c
    266e:	ad 87       	std	Y+13, r26	; 0x0d
    2670:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2672:	6b 85       	ldd	r22, Y+11	; 0x0b
    2674:	7c 85       	ldd	r23, Y+12	; 0x0c
    2676:	8d 85       	ldd	r24, Y+13	; 0x0d
    2678:	9e 85       	ldd	r25, Y+14	; 0x0e
    267a:	20 e0       	ldi	r18, 0x00	; 0
    267c:	30 e0       	ldi	r19, 0x00	; 0
    267e:	4a ef       	ldi	r20, 0xFA	; 250
    2680:	54 e4       	ldi	r21, 0x44	; 68
    2682:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2686:	dc 01       	movw	r26, r24
    2688:	cb 01       	movw	r24, r22
    268a:	8f 83       	std	Y+7, r24	; 0x07
    268c:	98 87       	std	Y+8, r25	; 0x08
    268e:	a9 87       	std	Y+9, r26	; 0x09
    2690:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2692:	6f 81       	ldd	r22, Y+7	; 0x07
    2694:	78 85       	ldd	r23, Y+8	; 0x08
    2696:	89 85       	ldd	r24, Y+9	; 0x09
    2698:	9a 85       	ldd	r25, Y+10	; 0x0a
    269a:	20 e0       	ldi	r18, 0x00	; 0
    269c:	30 e0       	ldi	r19, 0x00	; 0
    269e:	40 e8       	ldi	r20, 0x80	; 128
    26a0:	5f e3       	ldi	r21, 0x3F	; 63
    26a2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    26a6:	88 23       	and	r24, r24
    26a8:	2c f4       	brge	.+10     	; 0x26b4 <HCLCD_VidWriteCommand_4Bits+0x9c>
		__ticks = 1;
    26aa:	81 e0       	ldi	r24, 0x01	; 1
    26ac:	90 e0       	ldi	r25, 0x00	; 0
    26ae:	9e 83       	std	Y+6, r25	; 0x06
    26b0:	8d 83       	std	Y+5, r24	; 0x05
    26b2:	3f c0       	rjmp	.+126    	; 0x2732 <HCLCD_VidWriteCommand_4Bits+0x11a>
	else if (__tmp > 65535)
    26b4:	6f 81       	ldd	r22, Y+7	; 0x07
    26b6:	78 85       	ldd	r23, Y+8	; 0x08
    26b8:	89 85       	ldd	r24, Y+9	; 0x09
    26ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    26bc:	20 e0       	ldi	r18, 0x00	; 0
    26be:	3f ef       	ldi	r19, 0xFF	; 255
    26c0:	4f e7       	ldi	r20, 0x7F	; 127
    26c2:	57 e4       	ldi	r21, 0x47	; 71
    26c4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    26c8:	18 16       	cp	r1, r24
    26ca:	4c f5       	brge	.+82     	; 0x271e <HCLCD_VidWriteCommand_4Bits+0x106>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    26cc:	6b 85       	ldd	r22, Y+11	; 0x0b
    26ce:	7c 85       	ldd	r23, Y+12	; 0x0c
    26d0:	8d 85       	ldd	r24, Y+13	; 0x0d
    26d2:	9e 85       	ldd	r25, Y+14	; 0x0e
    26d4:	20 e0       	ldi	r18, 0x00	; 0
    26d6:	30 e0       	ldi	r19, 0x00	; 0
    26d8:	40 e2       	ldi	r20, 0x20	; 32
    26da:	51 e4       	ldi	r21, 0x41	; 65
    26dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26e0:	dc 01       	movw	r26, r24
    26e2:	cb 01       	movw	r24, r22
    26e4:	bc 01       	movw	r22, r24
    26e6:	cd 01       	movw	r24, r26
    26e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26ec:	dc 01       	movw	r26, r24
    26ee:	cb 01       	movw	r24, r22
    26f0:	9e 83       	std	Y+6, r25	; 0x06
    26f2:	8d 83       	std	Y+5, r24	; 0x05
    26f4:	0f c0       	rjmp	.+30     	; 0x2714 <HCLCD_VidWriteCommand_4Bits+0xfc>
    26f6:	88 ec       	ldi	r24, 0xC8	; 200
    26f8:	90 e0       	ldi	r25, 0x00	; 0
    26fa:	9c 83       	std	Y+4, r25	; 0x04
    26fc:	8b 83       	std	Y+3, r24	; 0x03
    26fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2700:	9c 81       	ldd	r25, Y+4	; 0x04
    2702:	01 97       	sbiw	r24, 0x01	; 1
    2704:	f1 f7       	brne	.-4      	; 0x2702 <HCLCD_VidWriteCommand_4Bits+0xea>
    2706:	9c 83       	std	Y+4, r25	; 0x04
    2708:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    270a:	8d 81       	ldd	r24, Y+5	; 0x05
    270c:	9e 81       	ldd	r25, Y+6	; 0x06
    270e:	01 97       	sbiw	r24, 0x01	; 1
    2710:	9e 83       	std	Y+6, r25	; 0x06
    2712:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2714:	8d 81       	ldd	r24, Y+5	; 0x05
    2716:	9e 81       	ldd	r25, Y+6	; 0x06
    2718:	00 97       	sbiw	r24, 0x00	; 0
    271a:	69 f7       	brne	.-38     	; 0x26f6 <HCLCD_VidWriteCommand_4Bits+0xde>
    271c:	14 c0       	rjmp	.+40     	; 0x2746 <HCLCD_VidWriteCommand_4Bits+0x12e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    271e:	6f 81       	ldd	r22, Y+7	; 0x07
    2720:	78 85       	ldd	r23, Y+8	; 0x08
    2722:	89 85       	ldd	r24, Y+9	; 0x09
    2724:	9a 85       	ldd	r25, Y+10	; 0x0a
    2726:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    272a:	dc 01       	movw	r26, r24
    272c:	cb 01       	movw	r24, r22
    272e:	9e 83       	std	Y+6, r25	; 0x06
    2730:	8d 83       	std	Y+5, r24	; 0x05
    2732:	8d 81       	ldd	r24, Y+5	; 0x05
    2734:	9e 81       	ldd	r25, Y+6	; 0x06
    2736:	9a 83       	std	Y+2, r25	; 0x02
    2738:	89 83       	std	Y+1, r24	; 0x01
    273a:	89 81       	ldd	r24, Y+1	; 0x01
    273c:	9a 81       	ldd	r25, Y+2	; 0x02
    273e:	01 97       	sbiw	r24, 0x01	; 1
    2740:	f1 f7       	brne	.-4      	; 0x273e <HCLCD_VidWriteCommand_4Bits+0x126>
    2742:	9a 83       	std	Y+2, r25	; 0x02
    2744:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    2746:	82 e0       	ldi	r24, 0x02	; 2
    2748:	60 e0       	ldi	r22, 0x00	; 0
    274a:	40 e0       	ldi	r20, 0x00	; 0
    274c:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
}
    2750:	60 96       	adiw	r28, 0x10	; 16
    2752:	0f b6       	in	r0, 0x3f	; 63
    2754:	f8 94       	cli
    2756:	de bf       	out	0x3e, r29	; 62
    2758:	0f be       	out	0x3f, r0	; 63
    275a:	cd bf       	out	0x3d, r28	; 61
    275c:	cf 91       	pop	r28
    275e:	df 91       	pop	r29
    2760:	08 95       	ret

00002762 <HCLCD_Vid4Bits_Init>:
void HCLCD_Vid4Bits_Init(void)
{
    2762:	df 93       	push	r29
    2764:	cf 93       	push	r28
    2766:	cd b7       	in	r28, 0x3d	; 61
    2768:	de b7       	in	r29, 0x3e	; 62
    276a:	e9 97       	sbiw	r28, 0x39	; 57
    276c:	0f b6       	in	r0, 0x3f	; 63
    276e:	f8 94       	cli
    2770:	de bf       	out	0x3e, r29	; 62
    2772:	0f be       	out	0x3f, r0	; 63
    2774:	cd bf       	out	0x3d, r28	; 61
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    2776:	86 e0       	ldi	r24, 0x06	; 6
    2778:	89 af       	std	Y+57, r24	; 0x39
    277a:	08 c0       	rjmp	.+16     	; 0x278c <HCLCD_Vid4Bits_Init+0x2a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
    277c:	89 ad       	ldd	r24, Y+57	; 0x39
    277e:	60 e0       	ldi	r22, 0x00	; 0
    2780:	41 e0       	ldi	r20, 0x01	; 1
    2782:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
}
void HCLCD_Vid4Bits_Init(void)
{
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    2786:	89 ad       	ldd	r24, Y+57	; 0x39
    2788:	81 50       	subi	r24, 0x01	; 1
    278a:	89 af       	std	Y+57, r24	; 0x39
    278c:	89 ad       	ldd	r24, Y+57	; 0x39
    278e:	83 30       	cpi	r24, 0x03	; 3
    2790:	ac f7       	brge	.-22     	; 0x277c <HCLCD_Vid4Bits_Init+0x1a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
	}
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    2792:	81 e0       	ldi	r24, 0x01	; 1
    2794:	60 e0       	ldi	r22, 0x00	; 0
    2796:	41 e0       	ldi	r20, 0x01	; 1
    2798:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    279c:	82 e0       	ldi	r24, 0x02	; 2
    279e:	60 e0       	ldi	r22, 0x00	; 0
    27a0:	41 e0       	ldi	r20, 0x01	; 1
    27a2:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
    27a6:	80 e0       	ldi	r24, 0x00	; 0
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	a0 ef       	ldi	r26, 0xF0	; 240
    27ac:	b1 e4       	ldi	r27, 0x41	; 65
    27ae:	8d ab       	std	Y+53, r24	; 0x35
    27b0:	9e ab       	std	Y+54, r25	; 0x36
    27b2:	af ab       	std	Y+55, r26	; 0x37
    27b4:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27b6:	6d a9       	ldd	r22, Y+53	; 0x35
    27b8:	7e a9       	ldd	r23, Y+54	; 0x36
    27ba:	8f a9       	ldd	r24, Y+55	; 0x37
    27bc:	98 ad       	ldd	r25, Y+56	; 0x38
    27be:	20 e0       	ldi	r18, 0x00	; 0
    27c0:	30 e0       	ldi	r19, 0x00	; 0
    27c2:	4a ef       	ldi	r20, 0xFA	; 250
    27c4:	54 e4       	ldi	r21, 0x44	; 68
    27c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27ca:	dc 01       	movw	r26, r24
    27cc:	cb 01       	movw	r24, r22
    27ce:	89 ab       	std	Y+49, r24	; 0x31
    27d0:	9a ab       	std	Y+50, r25	; 0x32
    27d2:	ab ab       	std	Y+51, r26	; 0x33
    27d4:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    27d6:	69 a9       	ldd	r22, Y+49	; 0x31
    27d8:	7a a9       	ldd	r23, Y+50	; 0x32
    27da:	8b a9       	ldd	r24, Y+51	; 0x33
    27dc:	9c a9       	ldd	r25, Y+52	; 0x34
    27de:	20 e0       	ldi	r18, 0x00	; 0
    27e0:	30 e0       	ldi	r19, 0x00	; 0
    27e2:	40 e8       	ldi	r20, 0x80	; 128
    27e4:	5f e3       	ldi	r21, 0x3F	; 63
    27e6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    27ea:	88 23       	and	r24, r24
    27ec:	2c f4       	brge	.+10     	; 0x27f8 <HCLCD_Vid4Bits_Init+0x96>
		__ticks = 1;
    27ee:	81 e0       	ldi	r24, 0x01	; 1
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	98 ab       	std	Y+48, r25	; 0x30
    27f4:	8f a7       	std	Y+47, r24	; 0x2f
    27f6:	3f c0       	rjmp	.+126    	; 0x2876 <HCLCD_Vid4Bits_Init+0x114>
	else if (__tmp > 65535)
    27f8:	69 a9       	ldd	r22, Y+49	; 0x31
    27fa:	7a a9       	ldd	r23, Y+50	; 0x32
    27fc:	8b a9       	ldd	r24, Y+51	; 0x33
    27fe:	9c a9       	ldd	r25, Y+52	; 0x34
    2800:	20 e0       	ldi	r18, 0x00	; 0
    2802:	3f ef       	ldi	r19, 0xFF	; 255
    2804:	4f e7       	ldi	r20, 0x7F	; 127
    2806:	57 e4       	ldi	r21, 0x47	; 71
    2808:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    280c:	18 16       	cp	r1, r24
    280e:	4c f5       	brge	.+82     	; 0x2862 <HCLCD_Vid4Bits_Init+0x100>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2810:	6d a9       	ldd	r22, Y+53	; 0x35
    2812:	7e a9       	ldd	r23, Y+54	; 0x36
    2814:	8f a9       	ldd	r24, Y+55	; 0x37
    2816:	98 ad       	ldd	r25, Y+56	; 0x38
    2818:	20 e0       	ldi	r18, 0x00	; 0
    281a:	30 e0       	ldi	r19, 0x00	; 0
    281c:	40 e2       	ldi	r20, 0x20	; 32
    281e:	51 e4       	ldi	r21, 0x41	; 65
    2820:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2824:	dc 01       	movw	r26, r24
    2826:	cb 01       	movw	r24, r22
    2828:	bc 01       	movw	r22, r24
    282a:	cd 01       	movw	r24, r26
    282c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2830:	dc 01       	movw	r26, r24
    2832:	cb 01       	movw	r24, r22
    2834:	98 ab       	std	Y+48, r25	; 0x30
    2836:	8f a7       	std	Y+47, r24	; 0x2f
    2838:	0f c0       	rjmp	.+30     	; 0x2858 <HCLCD_Vid4Bits_Init+0xf6>
    283a:	88 ec       	ldi	r24, 0xC8	; 200
    283c:	90 e0       	ldi	r25, 0x00	; 0
    283e:	9e a7       	std	Y+46, r25	; 0x2e
    2840:	8d a7       	std	Y+45, r24	; 0x2d
    2842:	8d a5       	ldd	r24, Y+45	; 0x2d
    2844:	9e a5       	ldd	r25, Y+46	; 0x2e
    2846:	01 97       	sbiw	r24, 0x01	; 1
    2848:	f1 f7       	brne	.-4      	; 0x2846 <HCLCD_Vid4Bits_Init+0xe4>
    284a:	9e a7       	std	Y+46, r25	; 0x2e
    284c:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    284e:	8f a5       	ldd	r24, Y+47	; 0x2f
    2850:	98 a9       	ldd	r25, Y+48	; 0x30
    2852:	01 97       	sbiw	r24, 0x01	; 1
    2854:	98 ab       	std	Y+48, r25	; 0x30
    2856:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2858:	8f a5       	ldd	r24, Y+47	; 0x2f
    285a:	98 a9       	ldd	r25, Y+48	; 0x30
    285c:	00 97       	sbiw	r24, 0x00	; 0
    285e:	69 f7       	brne	.-38     	; 0x283a <HCLCD_Vid4Bits_Init+0xd8>
    2860:	14 c0       	rjmp	.+40     	; 0x288a <HCLCD_Vid4Bits_Init+0x128>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2862:	69 a9       	ldd	r22, Y+49	; 0x31
    2864:	7a a9       	ldd	r23, Y+50	; 0x32
    2866:	8b a9       	ldd	r24, Y+51	; 0x33
    2868:	9c a9       	ldd	r25, Y+52	; 0x34
    286a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    286e:	dc 01       	movw	r26, r24
    2870:	cb 01       	movw	r24, r22
    2872:	98 ab       	std	Y+48, r25	; 0x30
    2874:	8f a7       	std	Y+47, r24	; 0x2f
    2876:	8f a5       	ldd	r24, Y+47	; 0x2f
    2878:	98 a9       	ldd	r25, Y+48	; 0x30
    287a:	9c a7       	std	Y+44, r25	; 0x2c
    287c:	8b a7       	std	Y+43, r24	; 0x2b
    287e:	8b a5       	ldd	r24, Y+43	; 0x2b
    2880:	9c a5       	ldd	r25, Y+44	; 0x2c
    2882:	01 97       	sbiw	r24, 0x01	; 1
    2884:	f1 f7       	brne	.-4      	; 0x2882 <HCLCD_Vid4Bits_Init+0x120>
    2886:	9c a7       	std	Y+44, r25	; 0x2c
    2888:	8b a7       	std	Y+43, r24	; 0x2b
	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    288a:	82 e0       	ldi	r24, 0x02	; 2
    288c:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    2890:	82 e0       	ldi	r24, 0x02	; 2
    2892:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET);
    2896:	88 e2       	ldi	r24, 0x28	; 40
    2898:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
    289c:	80 e0       	ldi	r24, 0x00	; 0
    289e:	90 e0       	ldi	r25, 0x00	; 0
    28a0:	a0 e8       	ldi	r26, 0x80	; 128
    28a2:	bf e3       	ldi	r27, 0x3F	; 63
    28a4:	8f a3       	std	Y+39, r24	; 0x27
    28a6:	98 a7       	std	Y+40, r25	; 0x28
    28a8:	a9 a7       	std	Y+41, r26	; 0x29
    28aa:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    28ac:	6f a1       	ldd	r22, Y+39	; 0x27
    28ae:	78 a5       	ldd	r23, Y+40	; 0x28
    28b0:	89 a5       	ldd	r24, Y+41	; 0x29
    28b2:	9a a5       	ldd	r25, Y+42	; 0x2a
    28b4:	20 e0       	ldi	r18, 0x00	; 0
    28b6:	30 e0       	ldi	r19, 0x00	; 0
    28b8:	4a ef       	ldi	r20, 0xFA	; 250
    28ba:	54 e4       	ldi	r21, 0x44	; 68
    28bc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28c0:	dc 01       	movw	r26, r24
    28c2:	cb 01       	movw	r24, r22
    28c4:	8b a3       	std	Y+35, r24	; 0x23
    28c6:	9c a3       	std	Y+36, r25	; 0x24
    28c8:	ad a3       	std	Y+37, r26	; 0x25
    28ca:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    28cc:	6b a1       	ldd	r22, Y+35	; 0x23
    28ce:	7c a1       	ldd	r23, Y+36	; 0x24
    28d0:	8d a1       	ldd	r24, Y+37	; 0x25
    28d2:	9e a1       	ldd	r25, Y+38	; 0x26
    28d4:	20 e0       	ldi	r18, 0x00	; 0
    28d6:	30 e0       	ldi	r19, 0x00	; 0
    28d8:	40 e8       	ldi	r20, 0x80	; 128
    28da:	5f e3       	ldi	r21, 0x3F	; 63
    28dc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    28e0:	88 23       	and	r24, r24
    28e2:	2c f4       	brge	.+10     	; 0x28ee <HCLCD_Vid4Bits_Init+0x18c>
		__ticks = 1;
    28e4:	81 e0       	ldi	r24, 0x01	; 1
    28e6:	90 e0       	ldi	r25, 0x00	; 0
    28e8:	9a a3       	std	Y+34, r25	; 0x22
    28ea:	89 a3       	std	Y+33, r24	; 0x21
    28ec:	3f c0       	rjmp	.+126    	; 0x296c <HCLCD_Vid4Bits_Init+0x20a>
	else if (__tmp > 65535)
    28ee:	6b a1       	ldd	r22, Y+35	; 0x23
    28f0:	7c a1       	ldd	r23, Y+36	; 0x24
    28f2:	8d a1       	ldd	r24, Y+37	; 0x25
    28f4:	9e a1       	ldd	r25, Y+38	; 0x26
    28f6:	20 e0       	ldi	r18, 0x00	; 0
    28f8:	3f ef       	ldi	r19, 0xFF	; 255
    28fa:	4f e7       	ldi	r20, 0x7F	; 127
    28fc:	57 e4       	ldi	r21, 0x47	; 71
    28fe:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2902:	18 16       	cp	r1, r24
    2904:	4c f5       	brge	.+82     	; 0x2958 <HCLCD_Vid4Bits_Init+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2906:	6f a1       	ldd	r22, Y+39	; 0x27
    2908:	78 a5       	ldd	r23, Y+40	; 0x28
    290a:	89 a5       	ldd	r24, Y+41	; 0x29
    290c:	9a a5       	ldd	r25, Y+42	; 0x2a
    290e:	20 e0       	ldi	r18, 0x00	; 0
    2910:	30 e0       	ldi	r19, 0x00	; 0
    2912:	40 e2       	ldi	r20, 0x20	; 32
    2914:	51 e4       	ldi	r21, 0x41	; 65
    2916:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    291a:	dc 01       	movw	r26, r24
    291c:	cb 01       	movw	r24, r22
    291e:	bc 01       	movw	r22, r24
    2920:	cd 01       	movw	r24, r26
    2922:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2926:	dc 01       	movw	r26, r24
    2928:	cb 01       	movw	r24, r22
    292a:	9a a3       	std	Y+34, r25	; 0x22
    292c:	89 a3       	std	Y+33, r24	; 0x21
    292e:	0f c0       	rjmp	.+30     	; 0x294e <HCLCD_Vid4Bits_Init+0x1ec>
    2930:	88 ec       	ldi	r24, 0xC8	; 200
    2932:	90 e0       	ldi	r25, 0x00	; 0
    2934:	98 a3       	std	Y+32, r25	; 0x20
    2936:	8f 8f       	std	Y+31, r24	; 0x1f
    2938:	8f 8d       	ldd	r24, Y+31	; 0x1f
    293a:	98 a1       	ldd	r25, Y+32	; 0x20
    293c:	01 97       	sbiw	r24, 0x01	; 1
    293e:	f1 f7       	brne	.-4      	; 0x293c <HCLCD_Vid4Bits_Init+0x1da>
    2940:	98 a3       	std	Y+32, r25	; 0x20
    2942:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2944:	89 a1       	ldd	r24, Y+33	; 0x21
    2946:	9a a1       	ldd	r25, Y+34	; 0x22
    2948:	01 97       	sbiw	r24, 0x01	; 1
    294a:	9a a3       	std	Y+34, r25	; 0x22
    294c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    294e:	89 a1       	ldd	r24, Y+33	; 0x21
    2950:	9a a1       	ldd	r25, Y+34	; 0x22
    2952:	00 97       	sbiw	r24, 0x00	; 0
    2954:	69 f7       	brne	.-38     	; 0x2930 <HCLCD_Vid4Bits_Init+0x1ce>
    2956:	14 c0       	rjmp	.+40     	; 0x2980 <HCLCD_Vid4Bits_Init+0x21e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2958:	6b a1       	ldd	r22, Y+35	; 0x23
    295a:	7c a1       	ldd	r23, Y+36	; 0x24
    295c:	8d a1       	ldd	r24, Y+37	; 0x25
    295e:	9e a1       	ldd	r25, Y+38	; 0x26
    2960:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2964:	dc 01       	movw	r26, r24
    2966:	cb 01       	movw	r24, r22
    2968:	9a a3       	std	Y+34, r25	; 0x22
    296a:	89 a3       	std	Y+33, r24	; 0x21
    296c:	89 a1       	ldd	r24, Y+33	; 0x21
    296e:	9a a1       	ldd	r25, Y+34	; 0x22
    2970:	9e 8f       	std	Y+30, r25	; 0x1e
    2972:	8d 8f       	std	Y+29, r24	; 0x1d
    2974:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2976:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2978:	01 97       	sbiw	r24, 0x01	; 1
    297a:	f1 f7       	brne	.-4      	; 0x2978 <HCLCD_Vid4Bits_Init+0x216>
    297c:	9e 8f       	std	Y+30, r25	; 0x1e
    297e:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF>>4);
    2980:	80 e0       	ldi	r24, 0x00	; 0
    2982:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF);
    2986:	8c e0       	ldi	r24, 0x0C	; 12
    2988:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
    298c:	80 e0       	ldi	r24, 0x00	; 0
    298e:	90 e0       	ldi	r25, 0x00	; 0
    2990:	a0 e8       	ldi	r26, 0x80	; 128
    2992:	bf e3       	ldi	r27, 0x3F	; 63
    2994:	89 8f       	std	Y+25, r24	; 0x19
    2996:	9a 8f       	std	Y+26, r25	; 0x1a
    2998:	ab 8f       	std	Y+27, r26	; 0x1b
    299a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    299c:	69 8d       	ldd	r22, Y+25	; 0x19
    299e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    29a0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    29a2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    29a4:	20 e0       	ldi	r18, 0x00	; 0
    29a6:	30 e0       	ldi	r19, 0x00	; 0
    29a8:	4a ef       	ldi	r20, 0xFA	; 250
    29aa:	54 e4       	ldi	r21, 0x44	; 68
    29ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29b0:	dc 01       	movw	r26, r24
    29b2:	cb 01       	movw	r24, r22
    29b4:	8d 8b       	std	Y+21, r24	; 0x15
    29b6:	9e 8b       	std	Y+22, r25	; 0x16
    29b8:	af 8b       	std	Y+23, r26	; 0x17
    29ba:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    29bc:	6d 89       	ldd	r22, Y+21	; 0x15
    29be:	7e 89       	ldd	r23, Y+22	; 0x16
    29c0:	8f 89       	ldd	r24, Y+23	; 0x17
    29c2:	98 8d       	ldd	r25, Y+24	; 0x18
    29c4:	20 e0       	ldi	r18, 0x00	; 0
    29c6:	30 e0       	ldi	r19, 0x00	; 0
    29c8:	40 e8       	ldi	r20, 0x80	; 128
    29ca:	5f e3       	ldi	r21, 0x3F	; 63
    29cc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    29d0:	88 23       	and	r24, r24
    29d2:	2c f4       	brge	.+10     	; 0x29de <HCLCD_Vid4Bits_Init+0x27c>
		__ticks = 1;
    29d4:	81 e0       	ldi	r24, 0x01	; 1
    29d6:	90 e0       	ldi	r25, 0x00	; 0
    29d8:	9c 8b       	std	Y+20, r25	; 0x14
    29da:	8b 8b       	std	Y+19, r24	; 0x13
    29dc:	3f c0       	rjmp	.+126    	; 0x2a5c <HCLCD_Vid4Bits_Init+0x2fa>
	else if (__tmp > 65535)
    29de:	6d 89       	ldd	r22, Y+21	; 0x15
    29e0:	7e 89       	ldd	r23, Y+22	; 0x16
    29e2:	8f 89       	ldd	r24, Y+23	; 0x17
    29e4:	98 8d       	ldd	r25, Y+24	; 0x18
    29e6:	20 e0       	ldi	r18, 0x00	; 0
    29e8:	3f ef       	ldi	r19, 0xFF	; 255
    29ea:	4f e7       	ldi	r20, 0x7F	; 127
    29ec:	57 e4       	ldi	r21, 0x47	; 71
    29ee:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    29f2:	18 16       	cp	r1, r24
    29f4:	4c f5       	brge	.+82     	; 0x2a48 <HCLCD_Vid4Bits_Init+0x2e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    29f6:	69 8d       	ldd	r22, Y+25	; 0x19
    29f8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    29fa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    29fc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    29fe:	20 e0       	ldi	r18, 0x00	; 0
    2a00:	30 e0       	ldi	r19, 0x00	; 0
    2a02:	40 e2       	ldi	r20, 0x20	; 32
    2a04:	51 e4       	ldi	r21, 0x41	; 65
    2a06:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2a0a:	dc 01       	movw	r26, r24
    2a0c:	cb 01       	movw	r24, r22
    2a0e:	bc 01       	movw	r22, r24
    2a10:	cd 01       	movw	r24, r26
    2a12:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a16:	dc 01       	movw	r26, r24
    2a18:	cb 01       	movw	r24, r22
    2a1a:	9c 8b       	std	Y+20, r25	; 0x14
    2a1c:	8b 8b       	std	Y+19, r24	; 0x13
    2a1e:	0f c0       	rjmp	.+30     	; 0x2a3e <HCLCD_Vid4Bits_Init+0x2dc>
    2a20:	88 ec       	ldi	r24, 0xC8	; 200
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	9a 8b       	std	Y+18, r25	; 0x12
    2a26:	89 8b       	std	Y+17, r24	; 0x11
    2a28:	89 89       	ldd	r24, Y+17	; 0x11
    2a2a:	9a 89       	ldd	r25, Y+18	; 0x12
    2a2c:	01 97       	sbiw	r24, 0x01	; 1
    2a2e:	f1 f7       	brne	.-4      	; 0x2a2c <HCLCD_Vid4Bits_Init+0x2ca>
    2a30:	9a 8b       	std	Y+18, r25	; 0x12
    2a32:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a34:	8b 89       	ldd	r24, Y+19	; 0x13
    2a36:	9c 89       	ldd	r25, Y+20	; 0x14
    2a38:	01 97       	sbiw	r24, 0x01	; 1
    2a3a:	9c 8b       	std	Y+20, r25	; 0x14
    2a3c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a3e:	8b 89       	ldd	r24, Y+19	; 0x13
    2a40:	9c 89       	ldd	r25, Y+20	; 0x14
    2a42:	00 97       	sbiw	r24, 0x00	; 0
    2a44:	69 f7       	brne	.-38     	; 0x2a20 <HCLCD_Vid4Bits_Init+0x2be>
    2a46:	14 c0       	rjmp	.+40     	; 0x2a70 <HCLCD_Vid4Bits_Init+0x30e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a48:	6d 89       	ldd	r22, Y+21	; 0x15
    2a4a:	7e 89       	ldd	r23, Y+22	; 0x16
    2a4c:	8f 89       	ldd	r24, Y+23	; 0x17
    2a4e:	98 8d       	ldd	r25, Y+24	; 0x18
    2a50:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a54:	dc 01       	movw	r26, r24
    2a56:	cb 01       	movw	r24, r22
    2a58:	9c 8b       	std	Y+20, r25	; 0x14
    2a5a:	8b 8b       	std	Y+19, r24	; 0x13
    2a5c:	8b 89       	ldd	r24, Y+19	; 0x13
    2a5e:	9c 89       	ldd	r25, Y+20	; 0x14
    2a60:	98 8b       	std	Y+16, r25	; 0x10
    2a62:	8f 87       	std	Y+15, r24	; 0x0f
    2a64:	8f 85       	ldd	r24, Y+15	; 0x0f
    2a66:	98 89       	ldd	r25, Y+16	; 0x10
    2a68:	01 97       	sbiw	r24, 0x01	; 1
    2a6a:	f1 f7       	brne	.-4      	; 0x2a68 <HCLCD_Vid4Bits_Init+0x306>
    2a6c:	98 8b       	std	Y+16, r25	; 0x10
    2a6e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR>>4);
    2a70:	80 e0       	ldi	r24, 0x00	; 0
    2a72:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR);
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
    2a7c:	80 e0       	ldi	r24, 0x00	; 0
    2a7e:	90 e0       	ldi	r25, 0x00	; 0
    2a80:	a0 e0       	ldi	r26, 0x00	; 0
    2a82:	b0 e4       	ldi	r27, 0x40	; 64
    2a84:	8b 87       	std	Y+11, r24	; 0x0b
    2a86:	9c 87       	std	Y+12, r25	; 0x0c
    2a88:	ad 87       	std	Y+13, r26	; 0x0d
    2a8a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2a8c:	6b 85       	ldd	r22, Y+11	; 0x0b
    2a8e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2a90:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a92:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a94:	20 e0       	ldi	r18, 0x00	; 0
    2a96:	30 e0       	ldi	r19, 0x00	; 0
    2a98:	4a ef       	ldi	r20, 0xFA	; 250
    2a9a:	54 e4       	ldi	r21, 0x44	; 68
    2a9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2aa0:	dc 01       	movw	r26, r24
    2aa2:	cb 01       	movw	r24, r22
    2aa4:	8f 83       	std	Y+7, r24	; 0x07
    2aa6:	98 87       	std	Y+8, r25	; 0x08
    2aa8:	a9 87       	std	Y+9, r26	; 0x09
    2aaa:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2aac:	6f 81       	ldd	r22, Y+7	; 0x07
    2aae:	78 85       	ldd	r23, Y+8	; 0x08
    2ab0:	89 85       	ldd	r24, Y+9	; 0x09
    2ab2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ab4:	20 e0       	ldi	r18, 0x00	; 0
    2ab6:	30 e0       	ldi	r19, 0x00	; 0
    2ab8:	40 e8       	ldi	r20, 0x80	; 128
    2aba:	5f e3       	ldi	r21, 0x3F	; 63
    2abc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2ac0:	88 23       	and	r24, r24
    2ac2:	2c f4       	brge	.+10     	; 0x2ace <HCLCD_Vid4Bits_Init+0x36c>
		__ticks = 1;
    2ac4:	81 e0       	ldi	r24, 0x01	; 1
    2ac6:	90 e0       	ldi	r25, 0x00	; 0
    2ac8:	9e 83       	std	Y+6, r25	; 0x06
    2aca:	8d 83       	std	Y+5, r24	; 0x05
    2acc:	3f c0       	rjmp	.+126    	; 0x2b4c <HCLCD_Vid4Bits_Init+0x3ea>
	else if (__tmp > 65535)
    2ace:	6f 81       	ldd	r22, Y+7	; 0x07
    2ad0:	78 85       	ldd	r23, Y+8	; 0x08
    2ad2:	89 85       	ldd	r24, Y+9	; 0x09
    2ad4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ad6:	20 e0       	ldi	r18, 0x00	; 0
    2ad8:	3f ef       	ldi	r19, 0xFF	; 255
    2ada:	4f e7       	ldi	r20, 0x7F	; 127
    2adc:	57 e4       	ldi	r21, 0x47	; 71
    2ade:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2ae2:	18 16       	cp	r1, r24
    2ae4:	4c f5       	brge	.+82     	; 0x2b38 <HCLCD_Vid4Bits_Init+0x3d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2ae6:	6b 85       	ldd	r22, Y+11	; 0x0b
    2ae8:	7c 85       	ldd	r23, Y+12	; 0x0c
    2aea:	8d 85       	ldd	r24, Y+13	; 0x0d
    2aec:	9e 85       	ldd	r25, Y+14	; 0x0e
    2aee:	20 e0       	ldi	r18, 0x00	; 0
    2af0:	30 e0       	ldi	r19, 0x00	; 0
    2af2:	40 e2       	ldi	r20, 0x20	; 32
    2af4:	51 e4       	ldi	r21, 0x41	; 65
    2af6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2afa:	dc 01       	movw	r26, r24
    2afc:	cb 01       	movw	r24, r22
    2afe:	bc 01       	movw	r22, r24
    2b00:	cd 01       	movw	r24, r26
    2b02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b06:	dc 01       	movw	r26, r24
    2b08:	cb 01       	movw	r24, r22
    2b0a:	9e 83       	std	Y+6, r25	; 0x06
    2b0c:	8d 83       	std	Y+5, r24	; 0x05
    2b0e:	0f c0       	rjmp	.+30     	; 0x2b2e <HCLCD_Vid4Bits_Init+0x3cc>
    2b10:	88 ec       	ldi	r24, 0xC8	; 200
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	9c 83       	std	Y+4, r25	; 0x04
    2b16:	8b 83       	std	Y+3, r24	; 0x03
    2b18:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b1c:	01 97       	sbiw	r24, 0x01	; 1
    2b1e:	f1 f7       	brne	.-4      	; 0x2b1c <HCLCD_Vid4Bits_Init+0x3ba>
    2b20:	9c 83       	std	Y+4, r25	; 0x04
    2b22:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b24:	8d 81       	ldd	r24, Y+5	; 0x05
    2b26:	9e 81       	ldd	r25, Y+6	; 0x06
    2b28:	01 97       	sbiw	r24, 0x01	; 1
    2b2a:	9e 83       	std	Y+6, r25	; 0x06
    2b2c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2b2e:	8d 81       	ldd	r24, Y+5	; 0x05
    2b30:	9e 81       	ldd	r25, Y+6	; 0x06
    2b32:	00 97       	sbiw	r24, 0x00	; 0
    2b34:	69 f7       	brne	.-38     	; 0x2b10 <HCLCD_Vid4Bits_Init+0x3ae>
    2b36:	14 c0       	rjmp	.+40     	; 0x2b60 <HCLCD_Vid4Bits_Init+0x3fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2b38:	6f 81       	ldd	r22, Y+7	; 0x07
    2b3a:	78 85       	ldd	r23, Y+8	; 0x08
    2b3c:	89 85       	ldd	r24, Y+9	; 0x09
    2b3e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b44:	dc 01       	movw	r26, r24
    2b46:	cb 01       	movw	r24, r22
    2b48:	9e 83       	std	Y+6, r25	; 0x06
    2b4a:	8d 83       	std	Y+5, r24	; 0x05
    2b4c:	8d 81       	ldd	r24, Y+5	; 0x05
    2b4e:	9e 81       	ldd	r25, Y+6	; 0x06
    2b50:	9a 83       	std	Y+2, r25	; 0x02
    2b52:	89 83       	std	Y+1, r24	; 0x01
    2b54:	89 81       	ldd	r24, Y+1	; 0x01
    2b56:	9a 81       	ldd	r25, Y+2	; 0x02
    2b58:	01 97       	sbiw	r24, 0x01	; 1
    2b5a:	f1 f7       	brne	.-4      	; 0x2b58 <HCLCD_Vid4Bits_Init+0x3f6>
    2b5c:	9a 83       	std	Y+2, r25	; 0x02
    2b5e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET>>4);
    2b60:	80 e0       	ldi	r24, 0x00	; 0
    2b62:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET);
    2b66:	86 e0       	ldi	r24, 0x06	; 6
    2b68:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
}
    2b6c:	e9 96       	adiw	r28, 0x39	; 57
    2b6e:	0f b6       	in	r0, 0x3f	; 63
    2b70:	f8 94       	cli
    2b72:	de bf       	out	0x3e, r29	; 62
    2b74:	0f be       	out	0x3f, r0	; 63
    2b76:	cd bf       	out	0x3d, r28	; 61
    2b78:	cf 91       	pop	r28
    2b7a:	df 91       	pop	r29
    2b7c:	08 95       	ret

00002b7e <HCLCD_VidWriteChar_4Bits>:
void HCLCD_VidWriteChar_4Bits(u8 Copy_u8Data)
{
    2b7e:	df 93       	push	r29
    2b80:	cf 93       	push	r28
    2b82:	cd b7       	in	r28, 0x3d	; 61
    2b84:	de b7       	in	r29, 0x3e	; 62
    2b86:	60 97       	sbiw	r28, 0x10	; 16
    2b88:	0f b6       	in	r0, 0x3f	; 63
    2b8a:	f8 94       	cli
    2b8c:	de bf       	out	0x3e, r29	; 62
    2b8e:	0f be       	out	0x3f, r0	; 63
    2b90:	cd bf       	out	0x3d, r28	; 61
    2b92:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyData;
	/*select Data register--> Write One on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    2b94:	81 e0       	ldi	r24, 0x01	; 1
    2b96:	60 e0       	ldi	r22, 0x00	; 0
    2b98:	41 e0       	ldi	r20, 0x01	; 1
    2b9a:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Data*/
	LOC_u8CopyData=(Copy_u8Data&0x0F)<<HCLCD_PINSTART;
    2b9e:	88 89       	ldd	r24, Y+16	; 0x10
    2ba0:	8f 70       	andi	r24, 0x0F	; 15
    2ba2:	88 0f       	add	r24, r24
    2ba4:	88 0f       	add	r24, r24
    2ba6:	88 0f       	add	r24, r24
    2ba8:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyData);
    2baa:	83 e0       	ldi	r24, 0x03	; 3
    2bac:	60 e0       	ldi	r22, 0x00	; 0
    2bae:	4f 85       	ldd	r20, Y+15	; 0x0f
    2bb0:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    2bb4:	82 e0       	ldi	r24, 0x02	; 2
    2bb6:	60 e0       	ldi	r22, 0x00	; 0
    2bb8:	41 e0       	ldi	r20, 0x01	; 1
    2bba:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
    2bbe:	80 e0       	ldi	r24, 0x00	; 0
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	a0 e0       	ldi	r26, 0x00	; 0
    2bc4:	b0 e4       	ldi	r27, 0x40	; 64
    2bc6:	8b 87       	std	Y+11, r24	; 0x0b
    2bc8:	9c 87       	std	Y+12, r25	; 0x0c
    2bca:	ad 87       	std	Y+13, r26	; 0x0d
    2bcc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2bce:	6b 85       	ldd	r22, Y+11	; 0x0b
    2bd0:	7c 85       	ldd	r23, Y+12	; 0x0c
    2bd2:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bd4:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bd6:	20 e0       	ldi	r18, 0x00	; 0
    2bd8:	30 e0       	ldi	r19, 0x00	; 0
    2bda:	4a ef       	ldi	r20, 0xFA	; 250
    2bdc:	54 e4       	ldi	r21, 0x44	; 68
    2bde:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2be2:	dc 01       	movw	r26, r24
    2be4:	cb 01       	movw	r24, r22
    2be6:	8f 83       	std	Y+7, r24	; 0x07
    2be8:	98 87       	std	Y+8, r25	; 0x08
    2bea:	a9 87       	std	Y+9, r26	; 0x09
    2bec:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2bee:	6f 81       	ldd	r22, Y+7	; 0x07
    2bf0:	78 85       	ldd	r23, Y+8	; 0x08
    2bf2:	89 85       	ldd	r24, Y+9	; 0x09
    2bf4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bf6:	20 e0       	ldi	r18, 0x00	; 0
    2bf8:	30 e0       	ldi	r19, 0x00	; 0
    2bfa:	40 e8       	ldi	r20, 0x80	; 128
    2bfc:	5f e3       	ldi	r21, 0x3F	; 63
    2bfe:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2c02:	88 23       	and	r24, r24
    2c04:	2c f4       	brge	.+10     	; 0x2c10 <HCLCD_VidWriteChar_4Bits+0x92>
		__ticks = 1;
    2c06:	81 e0       	ldi	r24, 0x01	; 1
    2c08:	90 e0       	ldi	r25, 0x00	; 0
    2c0a:	9e 83       	std	Y+6, r25	; 0x06
    2c0c:	8d 83       	std	Y+5, r24	; 0x05
    2c0e:	3f c0       	rjmp	.+126    	; 0x2c8e <HCLCD_VidWriteChar_4Bits+0x110>
	else if (__tmp > 65535)
    2c10:	6f 81       	ldd	r22, Y+7	; 0x07
    2c12:	78 85       	ldd	r23, Y+8	; 0x08
    2c14:	89 85       	ldd	r24, Y+9	; 0x09
    2c16:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c18:	20 e0       	ldi	r18, 0x00	; 0
    2c1a:	3f ef       	ldi	r19, 0xFF	; 255
    2c1c:	4f e7       	ldi	r20, 0x7F	; 127
    2c1e:	57 e4       	ldi	r21, 0x47	; 71
    2c20:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2c24:	18 16       	cp	r1, r24
    2c26:	4c f5       	brge	.+82     	; 0x2c7a <HCLCD_VidWriteChar_4Bits+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c28:	6b 85       	ldd	r22, Y+11	; 0x0b
    2c2a:	7c 85       	ldd	r23, Y+12	; 0x0c
    2c2c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c2e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c30:	20 e0       	ldi	r18, 0x00	; 0
    2c32:	30 e0       	ldi	r19, 0x00	; 0
    2c34:	40 e2       	ldi	r20, 0x20	; 32
    2c36:	51 e4       	ldi	r21, 0x41	; 65
    2c38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c3c:	dc 01       	movw	r26, r24
    2c3e:	cb 01       	movw	r24, r22
    2c40:	bc 01       	movw	r22, r24
    2c42:	cd 01       	movw	r24, r26
    2c44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c48:	dc 01       	movw	r26, r24
    2c4a:	cb 01       	movw	r24, r22
    2c4c:	9e 83       	std	Y+6, r25	; 0x06
    2c4e:	8d 83       	std	Y+5, r24	; 0x05
    2c50:	0f c0       	rjmp	.+30     	; 0x2c70 <HCLCD_VidWriteChar_4Bits+0xf2>
    2c52:	88 ec       	ldi	r24, 0xC8	; 200
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	9c 83       	std	Y+4, r25	; 0x04
    2c58:	8b 83       	std	Y+3, r24	; 0x03
    2c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5e:	01 97       	sbiw	r24, 0x01	; 1
    2c60:	f1 f7       	brne	.-4      	; 0x2c5e <HCLCD_VidWriteChar_4Bits+0xe0>
    2c62:	9c 83       	std	Y+4, r25	; 0x04
    2c64:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2c66:	8d 81       	ldd	r24, Y+5	; 0x05
    2c68:	9e 81       	ldd	r25, Y+6	; 0x06
    2c6a:	01 97       	sbiw	r24, 0x01	; 1
    2c6c:	9e 83       	std	Y+6, r25	; 0x06
    2c6e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2c70:	8d 81       	ldd	r24, Y+5	; 0x05
    2c72:	9e 81       	ldd	r25, Y+6	; 0x06
    2c74:	00 97       	sbiw	r24, 0x00	; 0
    2c76:	69 f7       	brne	.-38     	; 0x2c52 <HCLCD_VidWriteChar_4Bits+0xd4>
    2c78:	14 c0       	rjmp	.+40     	; 0x2ca2 <HCLCD_VidWriteChar_4Bits+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2c7a:	6f 81       	ldd	r22, Y+7	; 0x07
    2c7c:	78 85       	ldd	r23, Y+8	; 0x08
    2c7e:	89 85       	ldd	r24, Y+9	; 0x09
    2c80:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c82:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c86:	dc 01       	movw	r26, r24
    2c88:	cb 01       	movw	r24, r22
    2c8a:	9e 83       	std	Y+6, r25	; 0x06
    2c8c:	8d 83       	std	Y+5, r24	; 0x05
    2c8e:	8d 81       	ldd	r24, Y+5	; 0x05
    2c90:	9e 81       	ldd	r25, Y+6	; 0x06
    2c92:	9a 83       	std	Y+2, r25	; 0x02
    2c94:	89 83       	std	Y+1, r24	; 0x01
    2c96:	89 81       	ldd	r24, Y+1	; 0x01
    2c98:	9a 81       	ldd	r25, Y+2	; 0x02
    2c9a:	01 97       	sbiw	r24, 0x01	; 1
    2c9c:	f1 f7       	brne	.-4      	; 0x2c9a <HCLCD_VidWriteChar_4Bits+0x11c>
    2c9e:	9a 83       	std	Y+2, r25	; 0x02
    2ca0:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    2ca2:	82 e0       	ldi	r24, 0x02	; 2
    2ca4:	60 e0       	ldi	r22, 0x00	; 0
    2ca6:	40 e0       	ldi	r20, 0x00	; 0
    2ca8:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
}
    2cac:	60 96       	adiw	r28, 0x10	; 16
    2cae:	0f b6       	in	r0, 0x3f	; 63
    2cb0:	f8 94       	cli
    2cb2:	de bf       	out	0x3e, r29	; 62
    2cb4:	0f be       	out	0x3f, r0	; 63
    2cb6:	cd bf       	out	0x3d, r28	; 61
    2cb8:	cf 91       	pop	r28
    2cba:	df 91       	pop	r29
    2cbc:	08 95       	ret

00002cbe <HCLCD_VidSendChar_4Bits>:
void HCLCD_VidSendChar_4Bits(u8 Copy_u8Data)
{
    2cbe:	df 93       	push	r29
    2cc0:	cf 93       	push	r28
    2cc2:	0f 92       	push	r0
    2cc4:	cd b7       	in	r28, 0x3d	; 61
    2cc6:	de b7       	in	r29, 0x3e	; 62
    2cc8:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data>>4);
    2cca:	89 81       	ldd	r24, Y+1	; 0x01
    2ccc:	82 95       	swap	r24
    2cce:	8f 70       	andi	r24, 0x0F	; 15
    2cd0:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <HCLCD_VidWriteChar_4Bits>
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
    2cd4:	89 81       	ldd	r24, Y+1	; 0x01
    2cd6:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <HCLCD_VidWriteChar_4Bits>
}
    2cda:	0f 90       	pop	r0
    2cdc:	cf 91       	pop	r28
    2cde:	df 91       	pop	r29
    2ce0:	08 95       	ret

00002ce2 <HCLCD_VidWriteString_4Bits>:
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
    2ce2:	df 93       	push	r29
    2ce4:	cf 93       	push	r28
    2ce6:	00 d0       	rcall	.+0      	; 0x2ce8 <HCLCD_VidWriteString_4Bits+0x6>
    2ce8:	0f 92       	push	r0
    2cea:	cd b7       	in	r28, 0x3d	; 61
    2cec:	de b7       	in	r29, 0x3e	; 62
    2cee:	9b 83       	std	Y+3, r25	; 0x03
    2cf0:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    2cf2:	19 82       	std	Y+1, r1	; 0x01
    2cf4:	0e c0       	rjmp	.+28     	; 0x2d12 <HCLCD_VidWriteString_4Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
    2cf6:	89 81       	ldd	r24, Y+1	; 0x01
    2cf8:	28 2f       	mov	r18, r24
    2cfa:	30 e0       	ldi	r19, 0x00	; 0
    2cfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2cfe:	9b 81       	ldd	r25, Y+3	; 0x03
    2d00:	fc 01       	movw	r30, r24
    2d02:	e2 0f       	add	r30, r18
    2d04:	f3 1f       	adc	r31, r19
    2d06:	80 81       	ld	r24, Z
    2d08:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <HCLCD_VidSendChar_4Bits>
		Loc_u8Count++;
    2d0c:	89 81       	ldd	r24, Y+1	; 0x01
    2d0e:	8f 5f       	subi	r24, 0xFF	; 255
    2d10:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
}
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    2d12:	89 81       	ldd	r24, Y+1	; 0x01
    2d14:	28 2f       	mov	r18, r24
    2d16:	30 e0       	ldi	r19, 0x00	; 0
    2d18:	8a 81       	ldd	r24, Y+2	; 0x02
    2d1a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	e2 0f       	add	r30, r18
    2d20:	f3 1f       	adc	r31, r19
    2d22:	80 81       	ld	r24, Z
    2d24:	88 23       	and	r24, r24
    2d26:	39 f7       	brne	.-50     	; 0x2cf6 <HCLCD_VidWriteString_4Bits+0x14>
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    2d28:	0f 90       	pop	r0
    2d2a:	0f 90       	pop	r0
    2d2c:	0f 90       	pop	r0
    2d2e:	cf 91       	pop	r28
    2d30:	df 91       	pop	r29
    2d32:	08 95       	ret

00002d34 <HCLCD_VidWriteNumber_4Bits>:
void HCLCD_VidWriteNumber_4Bits(u32 Copy_u8Number)
{
    2d34:	0f 93       	push	r16
    2d36:	1f 93       	push	r17
    2d38:	df 93       	push	r29
    2d3a:	cf 93       	push	r28
    2d3c:	cd b7       	in	r28, 0x3d	; 61
    2d3e:	de b7       	in	r29, 0x3e	; 62
    2d40:	60 97       	sbiw	r28, 0x10	; 16
    2d42:	0f b6       	in	r0, 0x3f	; 63
    2d44:	f8 94       	cli
    2d46:	de bf       	out	0x3e, r29	; 62
    2d48:	0f be       	out	0x3f, r0	; 63
    2d4a:	cd bf       	out	0x3d, r28	; 61
    2d4c:	6d 87       	std	Y+13, r22	; 0x0d
    2d4e:	7e 87       	std	Y+14, r23	; 0x0e
    2d50:	8f 87       	std	Y+15, r24	; 0x0f
    2d52:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    2d54:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    2d56:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d58:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d5a:	af 85       	ldd	r26, Y+15	; 0x0f
    2d5c:	b8 89       	ldd	r27, Y+16	; 0x10
    2d5e:	00 97       	sbiw	r24, 0x00	; 0
    2d60:	a1 05       	cpc	r26, r1
    2d62:	b1 05       	cpc	r27, r1
    2d64:	09 f4       	brne	.+2      	; 0x2d68 <HCLCD_VidWriteNumber_4Bits+0x34>
    2d66:	4f c0       	rjmp	.+158    	; 0x2e06 <HCLCD_VidWriteNumber_4Bits+0xd2>
    2d68:	2d c0       	rjmp	.+90     	; 0x2dc4 <HCLCD_VidWriteNumber_4Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    2d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d6c:	08 2f       	mov	r16, r24
    2d6e:	10 e0       	ldi	r17, 0x00	; 0
    2d70:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d72:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d74:	af 85       	ldd	r26, Y+15	; 0x0f
    2d76:	b8 89       	ldd	r27, Y+16	; 0x10
    2d78:	2a e0       	ldi	r18, 0x0A	; 10
    2d7a:	30 e0       	ldi	r19, 0x00	; 0
    2d7c:	40 e0       	ldi	r20, 0x00	; 0
    2d7e:	50 e0       	ldi	r21, 0x00	; 0
    2d80:	bc 01       	movw	r22, r24
    2d82:	cd 01       	movw	r24, r26
    2d84:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__udivmodsi4>
    2d88:	dc 01       	movw	r26, r24
    2d8a:	cb 01       	movw	r24, r22
    2d8c:	28 2f       	mov	r18, r24
    2d8e:	ce 01       	movw	r24, r28
    2d90:	03 96       	adiw	r24, 0x03	; 3
    2d92:	fc 01       	movw	r30, r24
    2d94:	e0 0f       	add	r30, r16
    2d96:	f1 1f       	adc	r31, r17
    2d98:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    2d9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d9e:	af 85       	ldd	r26, Y+15	; 0x0f
    2da0:	b8 89       	ldd	r27, Y+16	; 0x10
    2da2:	2a e0       	ldi	r18, 0x0A	; 10
    2da4:	30 e0       	ldi	r19, 0x00	; 0
    2da6:	40 e0       	ldi	r20, 0x00	; 0
    2da8:	50 e0       	ldi	r21, 0x00	; 0
    2daa:	bc 01       	movw	r22, r24
    2dac:	cd 01       	movw	r24, r26
    2dae:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__udivmodsi4>
    2db2:	da 01       	movw	r26, r20
    2db4:	c9 01       	movw	r24, r18
    2db6:	8d 87       	std	Y+13, r24	; 0x0d
    2db8:	9e 87       	std	Y+14, r25	; 0x0e
    2dba:	af 87       	std	Y+15, r26	; 0x0f
    2dbc:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    2dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    2dc0:	8f 5f       	subi	r24, 0xFF	; 255
    2dc2:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    2dc4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2dc6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2dc8:	af 85       	ldd	r26, Y+15	; 0x0f
    2dca:	b8 89       	ldd	r27, Y+16	; 0x10
    2dcc:	00 97       	sbiw	r24, 0x00	; 0
    2dce:	a1 05       	cpc	r26, r1
    2dd0:	b1 05       	cpc	r27, r1
    2dd2:	59 f6       	brne	.-106    	; 0x2d6a <HCLCD_VidWriteNumber_4Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    2dd4:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd6:	81 50       	subi	r24, 0x01	; 1
    2dd8:	89 83       	std	Y+1, r24	; 0x01
    2dda:	11 c0       	rjmp	.+34     	; 0x2dfe <HCLCD_VidWriteNumber_4Bits+0xca>
		{
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
    2ddc:	89 81       	ldd	r24, Y+1	; 0x01
    2dde:	28 2f       	mov	r18, r24
    2de0:	33 27       	eor	r19, r19
    2de2:	27 fd       	sbrc	r18, 7
    2de4:	30 95       	com	r19
    2de6:	ce 01       	movw	r24, r28
    2de8:	03 96       	adiw	r24, 0x03	; 3
    2dea:	fc 01       	movw	r30, r24
    2dec:	e2 0f       	add	r30, r18
    2dee:	f3 1f       	adc	r31, r19
    2df0:	80 81       	ld	r24, Z
    2df2:	80 5d       	subi	r24, 0xD0	; 208
    2df4:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <HCLCD_VidSendChar_4Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    2df8:	89 81       	ldd	r24, Y+1	; 0x01
    2dfa:	81 50       	subi	r24, 0x01	; 1
    2dfc:	89 83       	std	Y+1, r24	; 0x01
    2dfe:	89 81       	ldd	r24, Y+1	; 0x01
    2e00:	88 23       	and	r24, r24
    2e02:	64 f7       	brge	.-40     	; 0x2ddc <HCLCD_VidWriteNumber_4Bits+0xa8>
    2e04:	03 c0       	rjmp	.+6      	; 0x2e0c <HCLCD_VidWriteNumber_4Bits+0xd8>
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    2e06:	80 e3       	ldi	r24, 0x30	; 48
    2e08:	0e 94 36 11 	call	0x226c	; 0x226c <HCLCD_VidWriteChar_8Bits>
	}
}
    2e0c:	60 96       	adiw	r28, 0x10	; 16
    2e0e:	0f b6       	in	r0, 0x3f	; 63
    2e10:	f8 94       	cli
    2e12:	de bf       	out	0x3e, r29	; 62
    2e14:	0f be       	out	0x3f, r0	; 63
    2e16:	cd bf       	out	0x3d, r28	; 61
    2e18:	cf 91       	pop	r28
    2e1a:	df 91       	pop	r29
    2e1c:	1f 91       	pop	r17
    2e1e:	0f 91       	pop	r16
    2e20:	08 95       	ret

00002e22 <HCLCD_VidSetPosition_4BitsMode>:
void HCLCD_VidSetPosition_4BitsMode(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    2e22:	df 93       	push	r29
    2e24:	cf 93       	push	r28
    2e26:	00 d0       	rcall	.+0      	; 0x2e28 <HCLCD_VidSetPosition_4BitsMode+0x6>
    2e28:	cd b7       	in	r28, 0x3d	; 61
    2e2a:	de b7       	in	r29, 0x3e	; 62
    2e2c:	89 83       	std	Y+1, r24	; 0x01
    2e2e:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2e30:	89 81       	ldd	r24, Y+1	; 0x01
    2e32:	81 30       	cpi	r24, 0x01	; 1
    2e34:	b9 f4       	brne	.+46     	; 0x2e64 <HCLCD_VidSetPosition_4BitsMode+0x42>
    2e36:	8a 81       	ldd	r24, Y+2	; 0x02
    2e38:	80 31       	cpi	r24, 0x10	; 16
    2e3a:	a0 f4       	brcc	.+40     	; 0x2e64 <HCLCD_VidSetPosition_4BitsMode+0x42>
	{
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    2e3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e3e:	88 2f       	mov	r24, r24
    2e40:	90 e0       	ldi	r25, 0x00	; 0
    2e42:	80 58       	subi	r24, 0x80	; 128
    2e44:	9f 4f       	sbci	r25, 0xFF	; 255
    2e46:	95 95       	asr	r25
    2e48:	87 95       	ror	r24
    2e4a:	95 95       	asr	r25
    2e4c:	87 95       	ror	r24
    2e4e:	95 95       	asr	r25
    2e50:	87 95       	ror	r24
    2e52:	95 95       	asr	r25
    2e54:	87 95       	ror	r24
    2e56:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2e5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e5c:	80 58       	subi	r24, 0x80	; 128
    2e5e:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
    2e62:	19 c0       	rjmp	.+50     	; 0x2e96 <HCLCD_VidSetPosition_4BitsMode+0x74>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2e64:	89 81       	ldd	r24, Y+1	; 0x01
    2e66:	82 30       	cpi	r24, 0x02	; 2
    2e68:	b1 f4       	brne	.+44     	; 0x2e96 <HCLCD_VidSetPosition_4BitsMode+0x74>
    2e6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e6c:	80 31       	cpi	r24, 0x10	; 16
    2e6e:	98 f4       	brcc	.+38     	; 0x2e96 <HCLCD_VidSetPosition_4BitsMode+0x74>
	{
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    2e70:	8a 81       	ldd	r24, Y+2	; 0x02
    2e72:	88 2f       	mov	r24, r24
    2e74:	90 e0       	ldi	r25, 0x00	; 0
    2e76:	80 54       	subi	r24, 0x40	; 64
    2e78:	9f 4f       	sbci	r25, 0xFF	; 255
    2e7a:	95 95       	asr	r25
    2e7c:	87 95       	ror	r24
    2e7e:	95 95       	asr	r25
    2e80:	87 95       	ror	r24
    2e82:	95 95       	asr	r25
    2e84:	87 95       	ror	r24
    2e86:	95 95       	asr	r25
    2e88:	87 95       	ror	r24
    2e8a:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e90:	80 54       	subi	r24, 0x40	; 64
    2e92:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    2e96:	0f 90       	pop	r0
    2e98:	0f 90       	pop	r0
    2e9a:	cf 91       	pop	r28
    2e9c:	df 91       	pop	r29
    2e9e:	08 95       	ret

00002ea0 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2ea0:	df 93       	push	r29
    2ea2:	cf 93       	push	r28
    2ea4:	cd b7       	in	r28, 0x3d	; 61
    2ea6:	de b7       	in	r29, 0x3e	; 62
    2ea8:	27 97       	sbiw	r28, 0x07	; 7
    2eaa:	0f b6       	in	r0, 0x3f	; 63
    2eac:	f8 94       	cli
    2eae:	de bf       	out	0x3e, r29	; 62
    2eb0:	0f be       	out	0x3f, r0	; 63
    2eb2:	cd bf       	out	0x3d, r28	; 61
    2eb4:	9d 83       	std	Y+5, r25	; 0x05
    2eb6:	8c 83       	std	Y+4, r24	; 0x04
    2eb8:	6e 83       	std	Y+6, r22	; 0x06
    2eba:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2ebc:	8a e1       	ldi	r24, 0x1A	; 26
    2ebe:	90 e0       	ldi	r25, 0x00	; 0
    2ec0:	0e 94 28 1a 	call	0x3450	; 0x3450 <pvPortMalloc>
    2ec4:	9a 83       	std	Y+2, r25	; 0x02
    2ec6:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    2ec8:	89 81       	ldd	r24, Y+1	; 0x01
    2eca:	9a 81       	ldd	r25, Y+2	; 0x02
    2ecc:	00 97       	sbiw	r24, 0x00	; 0
    2ece:	09 f4       	brne	.+2      	; 0x2ed2 <xCoRoutineCreate+0x32>
    2ed0:	6f c0       	rjmp	.+222    	; 0x2fb0 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2ed2:	80 91 d8 01 	lds	r24, 0x01D8
    2ed6:	90 91 d9 01 	lds	r25, 0x01D9
    2eda:	00 97       	sbiw	r24, 0x00	; 0
    2edc:	41 f4       	brne	.+16     	; 0x2eee <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2ede:	89 81       	ldd	r24, Y+1	; 0x01
    2ee0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ee2:	90 93 d9 01 	sts	0x01D9, r25
    2ee6:	80 93 d8 01 	sts	0x01D8, r24
			prvInitialiseCoRoutineLists();
    2eea:	0e 94 b7 19 	call	0x336e	; 0x336e <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2eee:	8e 81       	ldd	r24, Y+6	; 0x06
    2ef0:	82 30       	cpi	r24, 0x02	; 2
    2ef2:	10 f0       	brcs	.+4      	; 0x2ef8 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2ef4:	81 e0       	ldi	r24, 0x01	; 1
    2ef6:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2ef8:	e9 81       	ldd	r30, Y+1	; 0x01
    2efa:	fa 81       	ldd	r31, Y+2	; 0x02
    2efc:	11 8e       	std	Z+25, r1	; 0x19
    2efe:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2f00:	e9 81       	ldd	r30, Y+1	; 0x01
    2f02:	fa 81       	ldd	r31, Y+2	; 0x02
    2f04:	8e 81       	ldd	r24, Y+6	; 0x06
    2f06:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2f08:	e9 81       	ldd	r30, Y+1	; 0x01
    2f0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f0c:	8f 81       	ldd	r24, Y+7	; 0x07
    2f0e:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2f10:	e9 81       	ldd	r30, Y+1	; 0x01
    2f12:	fa 81       	ldd	r31, Y+2	; 0x02
    2f14:	8c 81       	ldd	r24, Y+4	; 0x04
    2f16:	9d 81       	ldd	r25, Y+5	; 0x05
    2f18:	91 83       	std	Z+1, r25	; 0x01
    2f1a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2f1c:	89 81       	ldd	r24, Y+1	; 0x01
    2f1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f20:	02 96       	adiw	r24, 0x02	; 2
    2f22:	0e 94 be 1a 	call	0x357c	; 0x357c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2f26:	89 81       	ldd	r24, Y+1	; 0x01
    2f28:	9a 81       	ldd	r25, Y+2	; 0x02
    2f2a:	0c 96       	adiw	r24, 0x0c	; 12
    2f2c:	0e 94 be 1a 	call	0x357c	; 0x357c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2f30:	e9 81       	ldd	r30, Y+1	; 0x01
    2f32:	fa 81       	ldd	r31, Y+2	; 0x02
    2f34:	89 81       	ldd	r24, Y+1	; 0x01
    2f36:	9a 81       	ldd	r25, Y+2	; 0x02
    2f38:	91 87       	std	Z+9, r25	; 0x09
    2f3a:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f40:	89 81       	ldd	r24, Y+1	; 0x01
    2f42:	9a 81       	ldd	r25, Y+2	; 0x02
    2f44:	93 8b       	std	Z+19, r25	; 0x13
    2f46:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2f48:	8e 81       	ldd	r24, Y+6	; 0x06
    2f4a:	28 2f       	mov	r18, r24
    2f4c:	30 e0       	ldi	r19, 0x00	; 0
    2f4e:	87 e0       	ldi	r24, 0x07	; 7
    2f50:	90 e0       	ldi	r25, 0x00	; 0
    2f52:	82 1b       	sub	r24, r18
    2f54:	93 0b       	sbc	r25, r19
    2f56:	e9 81       	ldd	r30, Y+1	; 0x01
    2f58:	fa 81       	ldd	r31, Y+2	; 0x02
    2f5a:	95 87       	std	Z+13, r25	; 0x0d
    2f5c:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f60:	fa 81       	ldd	r31, Y+2	; 0x02
    2f62:	96 89       	ldd	r25, Z+22	; 0x16
    2f64:	80 91 da 01 	lds	r24, 0x01DA
    2f68:	89 17       	cp	r24, r25
    2f6a:	28 f4       	brcc	.+10     	; 0x2f76 <xCoRoutineCreate+0xd6>
    2f6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f70:	86 89       	ldd	r24, Z+22	; 0x16
    2f72:	80 93 da 01 	sts	0x01DA, r24
    2f76:	e9 81       	ldd	r30, Y+1	; 0x01
    2f78:	fa 81       	ldd	r31, Y+2	; 0x02
    2f7a:	86 89       	ldd	r24, Z+22	; 0x16
    2f7c:	28 2f       	mov	r18, r24
    2f7e:	30 e0       	ldi	r19, 0x00	; 0
    2f80:	c9 01       	movw	r24, r18
    2f82:	88 0f       	add	r24, r24
    2f84:	99 1f       	adc	r25, r25
    2f86:	88 0f       	add	r24, r24
    2f88:	99 1f       	adc	r25, r25
    2f8a:	88 0f       	add	r24, r24
    2f8c:	99 1f       	adc	r25, r25
    2f8e:	82 0f       	add	r24, r18
    2f90:	93 1f       	adc	r25, r19
    2f92:	ac 01       	movw	r20, r24
    2f94:	4f 51       	subi	r20, 0x1F	; 31
    2f96:	5e 4f       	sbci	r21, 0xFE	; 254
    2f98:	89 81       	ldd	r24, Y+1	; 0x01
    2f9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f9c:	9c 01       	movw	r18, r24
    2f9e:	2e 5f       	subi	r18, 0xFE	; 254
    2fa0:	3f 4f       	sbci	r19, 0xFF	; 255
    2fa2:	ca 01       	movw	r24, r20
    2fa4:	b9 01       	movw	r22, r18
    2fa6:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>

		xReturn = pdPASS;
    2faa:	81 e0       	ldi	r24, 0x01	; 1
    2fac:	8b 83       	std	Y+3, r24	; 0x03
    2fae:	02 c0       	rjmp	.+4      	; 0x2fb4 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2fb0:	8f ef       	ldi	r24, 0xFF	; 255
    2fb2:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    2fb4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2fb6:	27 96       	adiw	r28, 0x07	; 7
    2fb8:	0f b6       	in	r0, 0x3f	; 63
    2fba:	f8 94       	cli
    2fbc:	de bf       	out	0x3e, r29	; 62
    2fbe:	0f be       	out	0x3f, r0	; 63
    2fc0:	cd bf       	out	0x3d, r28	; 61
    2fc2:	cf 91       	pop	r28
    2fc4:	df 91       	pop	r29
    2fc6:	08 95       	ret

00002fc8 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    2fc8:	df 93       	push	r29
    2fca:	cf 93       	push	r28
    2fcc:	00 d0       	rcall	.+0      	; 0x2fce <vCoRoutineAddToDelayedList+0x6>
    2fce:	00 d0       	rcall	.+0      	; 0x2fd0 <vCoRoutineAddToDelayedList+0x8>
    2fd0:	00 d0       	rcall	.+0      	; 0x2fd2 <vCoRoutineAddToDelayedList+0xa>
    2fd2:	cd b7       	in	r28, 0x3d	; 61
    2fd4:	de b7       	in	r29, 0x3e	; 62
    2fd6:	9c 83       	std	Y+4, r25	; 0x04
    2fd8:	8b 83       	std	Y+3, r24	; 0x03
    2fda:	7e 83       	std	Y+6, r23	; 0x06
    2fdc:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2fde:	20 91 db 01 	lds	r18, 0x01DB
    2fe2:	30 91 dc 01 	lds	r19, 0x01DC
    2fe6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fea:	82 0f       	add	r24, r18
    2fec:	93 1f       	adc	r25, r19
    2fee:	9a 83       	std	Y+2, r25	; 0x02
    2ff0:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2ff2:	80 91 d8 01 	lds	r24, 0x01D8
    2ff6:	90 91 d9 01 	lds	r25, 0x01D9
    2ffa:	02 96       	adiw	r24, 0x02	; 2
    2ffc:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    3000:	e0 91 d8 01 	lds	r30, 0x01D8
    3004:	f0 91 d9 01 	lds	r31, 0x01D9
    3008:	89 81       	ldd	r24, Y+1	; 0x01
    300a:	9a 81       	ldd	r25, Y+2	; 0x02
    300c:	93 83       	std	Z+3, r25	; 0x03
    300e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    3010:	20 91 db 01 	lds	r18, 0x01DB
    3014:	30 91 dc 01 	lds	r19, 0x01DC
    3018:	89 81       	ldd	r24, Y+1	; 0x01
    301a:	9a 81       	ldd	r25, Y+2	; 0x02
    301c:	82 17       	cp	r24, r18
    301e:	93 07       	cpc	r25, r19
    3020:	70 f4       	brcc	.+28     	; 0x303e <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3022:	80 91 07 02 	lds	r24, 0x0207
    3026:	90 91 08 02 	lds	r25, 0x0208
    302a:	20 91 d8 01 	lds	r18, 0x01D8
    302e:	30 91 d9 01 	lds	r19, 0x01D9
    3032:	2e 5f       	subi	r18, 0xFE	; 254
    3034:	3f 4f       	sbci	r19, 0xFF	; 255
    3036:	b9 01       	movw	r22, r18
    3038:	0e 94 1a 1b 	call	0x3634	; 0x3634 <vListInsert>
    303c:	0d c0       	rjmp	.+26     	; 0x3058 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    303e:	80 91 05 02 	lds	r24, 0x0205
    3042:	90 91 06 02 	lds	r25, 0x0206
    3046:	20 91 d8 01 	lds	r18, 0x01D8
    304a:	30 91 d9 01 	lds	r19, 0x01D9
    304e:	2e 5f       	subi	r18, 0xFE	; 254
    3050:	3f 4f       	sbci	r19, 0xFF	; 255
    3052:	b9 01       	movw	r22, r18
    3054:	0e 94 1a 1b 	call	0x3634	; 0x3634 <vListInsert>
	}

	if( pxEventList )
    3058:	8d 81       	ldd	r24, Y+5	; 0x05
    305a:	9e 81       	ldd	r25, Y+6	; 0x06
    305c:	00 97       	sbiw	r24, 0x00	; 0
    305e:	61 f0       	breq	.+24     	; 0x3078 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    3060:	80 91 d8 01 	lds	r24, 0x01D8
    3064:	90 91 d9 01 	lds	r25, 0x01D9
    3068:	9c 01       	movw	r18, r24
    306a:	24 5f       	subi	r18, 0xF4	; 244
    306c:	3f 4f       	sbci	r19, 0xFF	; 255
    306e:	8d 81       	ldd	r24, Y+5	; 0x05
    3070:	9e 81       	ldd	r25, Y+6	; 0x06
    3072:	b9 01       	movw	r22, r18
    3074:	0e 94 1a 1b 	call	0x3634	; 0x3634 <vListInsert>
	}
}
    3078:	26 96       	adiw	r28, 0x06	; 6
    307a:	0f b6       	in	r0, 0x3f	; 63
    307c:	f8 94       	cli
    307e:	de bf       	out	0x3e, r29	; 62
    3080:	0f be       	out	0x3f, r0	; 63
    3082:	cd bf       	out	0x3d, r28	; 61
    3084:	cf 91       	pop	r28
    3086:	df 91       	pop	r29
    3088:	08 95       	ret

0000308a <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    308a:	df 93       	push	r29
    308c:	cf 93       	push	r28
    308e:	00 d0       	rcall	.+0      	; 0x3090 <prvCheckPendingReadyList+0x6>
    3090:	cd b7       	in	r28, 0x3d	; 61
    3092:	de b7       	in	r29, 0x3e	; 62
    3094:	3a c0       	rjmp	.+116    	; 0x310a <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    3096:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    3098:	e0 91 0e 02 	lds	r30, 0x020E
    309c:	f0 91 0f 02 	lds	r31, 0x020F
    30a0:	86 81       	ldd	r24, Z+6	; 0x06
    30a2:	97 81       	ldd	r25, Z+7	; 0x07
    30a4:	9a 83       	std	Y+2, r25	; 0x02
    30a6:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    30a8:	89 81       	ldd	r24, Y+1	; 0x01
    30aa:	9a 81       	ldd	r25, Y+2	; 0x02
    30ac:	0c 96       	adiw	r24, 0x0c	; 12
    30ae:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
		}
		portENABLE_INTERRUPTS();
    30b2:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    30b4:	89 81       	ldd	r24, Y+1	; 0x01
    30b6:	9a 81       	ldd	r25, Y+2	; 0x02
    30b8:	02 96       	adiw	r24, 0x02	; 2
    30ba:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    30be:	e9 81       	ldd	r30, Y+1	; 0x01
    30c0:	fa 81       	ldd	r31, Y+2	; 0x02
    30c2:	96 89       	ldd	r25, Z+22	; 0x16
    30c4:	80 91 da 01 	lds	r24, 0x01DA
    30c8:	89 17       	cp	r24, r25
    30ca:	28 f4       	brcc	.+10     	; 0x30d6 <prvCheckPendingReadyList+0x4c>
    30cc:	e9 81       	ldd	r30, Y+1	; 0x01
    30ce:	fa 81       	ldd	r31, Y+2	; 0x02
    30d0:	86 89       	ldd	r24, Z+22	; 0x16
    30d2:	80 93 da 01 	sts	0x01DA, r24
    30d6:	e9 81       	ldd	r30, Y+1	; 0x01
    30d8:	fa 81       	ldd	r31, Y+2	; 0x02
    30da:	86 89       	ldd	r24, Z+22	; 0x16
    30dc:	28 2f       	mov	r18, r24
    30de:	30 e0       	ldi	r19, 0x00	; 0
    30e0:	c9 01       	movw	r24, r18
    30e2:	88 0f       	add	r24, r24
    30e4:	99 1f       	adc	r25, r25
    30e6:	88 0f       	add	r24, r24
    30e8:	99 1f       	adc	r25, r25
    30ea:	88 0f       	add	r24, r24
    30ec:	99 1f       	adc	r25, r25
    30ee:	82 0f       	add	r24, r18
    30f0:	93 1f       	adc	r25, r19
    30f2:	ac 01       	movw	r20, r24
    30f4:	4f 51       	subi	r20, 0x1F	; 31
    30f6:	5e 4f       	sbci	r21, 0xFE	; 254
    30f8:	89 81       	ldd	r24, Y+1	; 0x01
    30fa:	9a 81       	ldd	r25, Y+2	; 0x02
    30fc:	9c 01       	movw	r18, r24
    30fe:	2e 5f       	subi	r18, 0xFE	; 254
    3100:	3f 4f       	sbci	r19, 0xFF	; 255
    3102:	ca 01       	movw	r24, r20
    3104:	b9 01       	movw	r22, r18
    3106:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    310a:	80 91 09 02 	lds	r24, 0x0209
    310e:	88 23       	and	r24, r24
    3110:	09 f0       	breq	.+2      	; 0x3114 <prvCheckPendingReadyList+0x8a>
    3112:	c1 cf       	rjmp	.-126    	; 0x3096 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    3114:	0f 90       	pop	r0
    3116:	0f 90       	pop	r0
    3118:	cf 91       	pop	r28
    311a:	df 91       	pop	r29
    311c:	08 95       	ret

0000311e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    311e:	df 93       	push	r29
    3120:	cf 93       	push	r28
    3122:	00 d0       	rcall	.+0      	; 0x3124 <prvCheckDelayedList+0x6>
    3124:	00 d0       	rcall	.+0      	; 0x3126 <prvCheckDelayedList+0x8>
    3126:	cd b7       	in	r28, 0x3d	; 61
    3128:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    312a:	0e 94 08 27 	call	0x4e10	; 0x4e10 <xTaskGetTickCount>
    312e:	20 91 dd 01 	lds	r18, 0x01DD
    3132:	30 91 de 01 	lds	r19, 0x01DE
    3136:	82 1b       	sub	r24, r18
    3138:	93 0b       	sbc	r25, r19
    313a:	90 93 e0 01 	sts	0x01E0, r25
    313e:	80 93 df 01 	sts	0x01DF, r24
    3142:	85 c0       	rjmp	.+266    	; 0x324e <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    3144:	80 91 db 01 	lds	r24, 0x01DB
    3148:	90 91 dc 01 	lds	r25, 0x01DC
    314c:	01 96       	adiw	r24, 0x01	; 1
    314e:	90 93 dc 01 	sts	0x01DC, r25
    3152:	80 93 db 01 	sts	0x01DB, r24
		xPassedTicks--;
    3156:	80 91 df 01 	lds	r24, 0x01DF
    315a:	90 91 e0 01 	lds	r25, 0x01E0
    315e:	01 97       	sbiw	r24, 0x01	; 1
    3160:	90 93 e0 01 	sts	0x01E0, r25
    3164:	80 93 df 01 	sts	0x01DF, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    3168:	80 91 db 01 	lds	r24, 0x01DB
    316c:	90 91 dc 01 	lds	r25, 0x01DC
    3170:	00 97       	sbiw	r24, 0x00	; 0
    3172:	09 f0       	breq	.+2      	; 0x3176 <prvCheckDelayedList+0x58>
    3174:	64 c0       	rjmp	.+200    	; 0x323e <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    3176:	80 91 05 02 	lds	r24, 0x0205
    317a:	90 91 06 02 	lds	r25, 0x0206
    317e:	9a 83       	std	Y+2, r25	; 0x02
    3180:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    3182:	80 91 07 02 	lds	r24, 0x0207
    3186:	90 91 08 02 	lds	r25, 0x0208
    318a:	90 93 06 02 	sts	0x0206, r25
    318e:	80 93 05 02 	sts	0x0205, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    3192:	89 81       	ldd	r24, Y+1	; 0x01
    3194:	9a 81       	ldd	r25, Y+2	; 0x02
    3196:	90 93 08 02 	sts	0x0208, r25
    319a:	80 93 07 02 	sts	0x0207, r24
    319e:	4f c0       	rjmp	.+158    	; 0x323e <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    31a0:	e0 91 05 02 	lds	r30, 0x0205
    31a4:	f0 91 06 02 	lds	r31, 0x0206
    31a8:	05 80       	ldd	r0, Z+5	; 0x05
    31aa:	f6 81       	ldd	r31, Z+6	; 0x06
    31ac:	e0 2d       	mov	r30, r0
    31ae:	86 81       	ldd	r24, Z+6	; 0x06
    31b0:	97 81       	ldd	r25, Z+7	; 0x07
    31b2:	9c 83       	std	Y+4, r25	; 0x04
    31b4:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    31b6:	eb 81       	ldd	r30, Y+3	; 0x03
    31b8:	fc 81       	ldd	r31, Y+4	; 0x04
    31ba:	22 81       	ldd	r18, Z+2	; 0x02
    31bc:	33 81       	ldd	r19, Z+3	; 0x03
    31be:	80 91 db 01 	lds	r24, 0x01DB
    31c2:	90 91 dc 01 	lds	r25, 0x01DC
    31c6:	82 17       	cp	r24, r18
    31c8:	93 07       	cpc	r25, r19
    31ca:	08 f4       	brcc	.+2      	; 0x31ce <prvCheckDelayedList+0xb0>
    31cc:	40 c0       	rjmp	.+128    	; 0x324e <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    31ce:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    31d0:	8b 81       	ldd	r24, Y+3	; 0x03
    31d2:	9c 81       	ldd	r25, Y+4	; 0x04
    31d4:	02 96       	adiw	r24, 0x02	; 2
    31d6:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    31da:	eb 81       	ldd	r30, Y+3	; 0x03
    31dc:	fc 81       	ldd	r31, Y+4	; 0x04
    31de:	84 89       	ldd	r24, Z+20	; 0x14
    31e0:	95 89       	ldd	r25, Z+21	; 0x15
    31e2:	00 97       	sbiw	r24, 0x00	; 0
    31e4:	29 f0       	breq	.+10     	; 0x31f0 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    31e6:	8b 81       	ldd	r24, Y+3	; 0x03
    31e8:	9c 81       	ldd	r25, Y+4	; 0x04
    31ea:	0c 96       	adiw	r24, 0x0c	; 12
    31ec:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    31f0:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    31f2:	eb 81       	ldd	r30, Y+3	; 0x03
    31f4:	fc 81       	ldd	r31, Y+4	; 0x04
    31f6:	96 89       	ldd	r25, Z+22	; 0x16
    31f8:	80 91 da 01 	lds	r24, 0x01DA
    31fc:	89 17       	cp	r24, r25
    31fe:	28 f4       	brcc	.+10     	; 0x320a <prvCheckDelayedList+0xec>
    3200:	eb 81       	ldd	r30, Y+3	; 0x03
    3202:	fc 81       	ldd	r31, Y+4	; 0x04
    3204:	86 89       	ldd	r24, Z+22	; 0x16
    3206:	80 93 da 01 	sts	0x01DA, r24
    320a:	eb 81       	ldd	r30, Y+3	; 0x03
    320c:	fc 81       	ldd	r31, Y+4	; 0x04
    320e:	86 89       	ldd	r24, Z+22	; 0x16
    3210:	28 2f       	mov	r18, r24
    3212:	30 e0       	ldi	r19, 0x00	; 0
    3214:	c9 01       	movw	r24, r18
    3216:	88 0f       	add	r24, r24
    3218:	99 1f       	adc	r25, r25
    321a:	88 0f       	add	r24, r24
    321c:	99 1f       	adc	r25, r25
    321e:	88 0f       	add	r24, r24
    3220:	99 1f       	adc	r25, r25
    3222:	82 0f       	add	r24, r18
    3224:	93 1f       	adc	r25, r19
    3226:	ac 01       	movw	r20, r24
    3228:	4f 51       	subi	r20, 0x1F	; 31
    322a:	5e 4f       	sbci	r21, 0xFE	; 254
    322c:	8b 81       	ldd	r24, Y+3	; 0x03
    322e:	9c 81       	ldd	r25, Y+4	; 0x04
    3230:	9c 01       	movw	r18, r24
    3232:	2e 5f       	subi	r18, 0xFE	; 254
    3234:	3f 4f       	sbci	r19, 0xFF	; 255
    3236:	ca 01       	movw	r24, r20
    3238:	b9 01       	movw	r22, r18
    323a:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    323e:	e0 91 05 02 	lds	r30, 0x0205
    3242:	f0 91 06 02 	lds	r31, 0x0206
    3246:	80 81       	ld	r24, Z
    3248:	88 23       	and	r24, r24
    324a:	09 f0       	breq	.+2      	; 0x324e <prvCheckDelayedList+0x130>
    324c:	a9 cf       	rjmp	.-174    	; 0x31a0 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    324e:	80 91 df 01 	lds	r24, 0x01DF
    3252:	90 91 e0 01 	lds	r25, 0x01E0
    3256:	00 97       	sbiw	r24, 0x00	; 0
    3258:	09 f0       	breq	.+2      	; 0x325c <prvCheckDelayedList+0x13e>
    325a:	74 cf       	rjmp	.-280    	; 0x3144 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    325c:	80 91 db 01 	lds	r24, 0x01DB
    3260:	90 91 dc 01 	lds	r25, 0x01DC
    3264:	90 93 de 01 	sts	0x01DE, r25
    3268:	80 93 dd 01 	sts	0x01DD, r24
}
    326c:	0f 90       	pop	r0
    326e:	0f 90       	pop	r0
    3270:	0f 90       	pop	r0
    3272:	0f 90       	pop	r0
    3274:	cf 91       	pop	r28
    3276:	df 91       	pop	r29
    3278:	08 95       	ret

0000327a <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    327a:	df 93       	push	r29
    327c:	cf 93       	push	r28
    327e:	00 d0       	rcall	.+0      	; 0x3280 <vCoRoutineSchedule+0x6>
    3280:	cd b7       	in	r28, 0x3d	; 61
    3282:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    3284:	0e 94 45 18 	call	0x308a	; 0x308a <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    3288:	0e 94 8f 18 	call	0x311e	; 0x311e <prvCheckDelayedList>
    328c:	0a c0       	rjmp	.+20     	; 0x32a2 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    328e:	80 91 da 01 	lds	r24, 0x01DA
    3292:	88 23       	and	r24, r24
    3294:	09 f4       	brne	.+2      	; 0x3298 <vCoRoutineSchedule+0x1e>
    3296:	66 c0       	rjmp	.+204    	; 0x3364 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    3298:	80 91 da 01 	lds	r24, 0x01DA
    329c:	81 50       	subi	r24, 0x01	; 1
    329e:	80 93 da 01 	sts	0x01DA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    32a2:	80 91 da 01 	lds	r24, 0x01DA
    32a6:	28 2f       	mov	r18, r24
    32a8:	30 e0       	ldi	r19, 0x00	; 0
    32aa:	c9 01       	movw	r24, r18
    32ac:	88 0f       	add	r24, r24
    32ae:	99 1f       	adc	r25, r25
    32b0:	88 0f       	add	r24, r24
    32b2:	99 1f       	adc	r25, r25
    32b4:	88 0f       	add	r24, r24
    32b6:	99 1f       	adc	r25, r25
    32b8:	82 0f       	add	r24, r18
    32ba:	93 1f       	adc	r25, r19
    32bc:	fc 01       	movw	r30, r24
    32be:	ef 51       	subi	r30, 0x1F	; 31
    32c0:	fe 4f       	sbci	r31, 0xFE	; 254
    32c2:	80 81       	ld	r24, Z
    32c4:	88 23       	and	r24, r24
    32c6:	19 f3       	breq	.-58     	; 0x328e <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    32c8:	80 91 da 01 	lds	r24, 0x01DA
    32cc:	28 2f       	mov	r18, r24
    32ce:	30 e0       	ldi	r19, 0x00	; 0
    32d0:	c9 01       	movw	r24, r18
    32d2:	88 0f       	add	r24, r24
    32d4:	99 1f       	adc	r25, r25
    32d6:	88 0f       	add	r24, r24
    32d8:	99 1f       	adc	r25, r25
    32da:	88 0f       	add	r24, r24
    32dc:	99 1f       	adc	r25, r25
    32de:	82 0f       	add	r24, r18
    32e0:	93 1f       	adc	r25, r19
    32e2:	8f 51       	subi	r24, 0x1F	; 31
    32e4:	9e 4f       	sbci	r25, 0xFE	; 254
    32e6:	9a 83       	std	Y+2, r25	; 0x02
    32e8:	89 83       	std	Y+1, r24	; 0x01
    32ea:	e9 81       	ldd	r30, Y+1	; 0x01
    32ec:	fa 81       	ldd	r31, Y+2	; 0x02
    32ee:	01 80       	ldd	r0, Z+1	; 0x01
    32f0:	f2 81       	ldd	r31, Z+2	; 0x02
    32f2:	e0 2d       	mov	r30, r0
    32f4:	82 81       	ldd	r24, Z+2	; 0x02
    32f6:	93 81       	ldd	r25, Z+3	; 0x03
    32f8:	e9 81       	ldd	r30, Y+1	; 0x01
    32fa:	fa 81       	ldd	r31, Y+2	; 0x02
    32fc:	92 83       	std	Z+2, r25	; 0x02
    32fe:	81 83       	std	Z+1, r24	; 0x01
    3300:	e9 81       	ldd	r30, Y+1	; 0x01
    3302:	fa 81       	ldd	r31, Y+2	; 0x02
    3304:	21 81       	ldd	r18, Z+1	; 0x01
    3306:	32 81       	ldd	r19, Z+2	; 0x02
    3308:	89 81       	ldd	r24, Y+1	; 0x01
    330a:	9a 81       	ldd	r25, Y+2	; 0x02
    330c:	03 96       	adiw	r24, 0x03	; 3
    330e:	28 17       	cp	r18, r24
    3310:	39 07       	cpc	r19, r25
    3312:	59 f4       	brne	.+22     	; 0x332a <vCoRoutineSchedule+0xb0>
    3314:	e9 81       	ldd	r30, Y+1	; 0x01
    3316:	fa 81       	ldd	r31, Y+2	; 0x02
    3318:	01 80       	ldd	r0, Z+1	; 0x01
    331a:	f2 81       	ldd	r31, Z+2	; 0x02
    331c:	e0 2d       	mov	r30, r0
    331e:	82 81       	ldd	r24, Z+2	; 0x02
    3320:	93 81       	ldd	r25, Z+3	; 0x03
    3322:	e9 81       	ldd	r30, Y+1	; 0x01
    3324:	fa 81       	ldd	r31, Y+2	; 0x02
    3326:	92 83       	std	Z+2, r25	; 0x02
    3328:	81 83       	std	Z+1, r24	; 0x01
    332a:	e9 81       	ldd	r30, Y+1	; 0x01
    332c:	fa 81       	ldd	r31, Y+2	; 0x02
    332e:	01 80       	ldd	r0, Z+1	; 0x01
    3330:	f2 81       	ldd	r31, Z+2	; 0x02
    3332:	e0 2d       	mov	r30, r0
    3334:	86 81       	ldd	r24, Z+6	; 0x06
    3336:	97 81       	ldd	r25, Z+7	; 0x07
    3338:	90 93 d9 01 	sts	0x01D9, r25
    333c:	80 93 d8 01 	sts	0x01D8, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    3340:	e0 91 d8 01 	lds	r30, 0x01D8
    3344:	f0 91 d9 01 	lds	r31, 0x01D9
    3348:	40 81       	ld	r20, Z
    334a:	51 81       	ldd	r21, Z+1	; 0x01
    334c:	80 91 d8 01 	lds	r24, 0x01D8
    3350:	90 91 d9 01 	lds	r25, 0x01D9
    3354:	e0 91 d8 01 	lds	r30, 0x01D8
    3358:	f0 91 d9 01 	lds	r31, 0x01D9
    335c:	27 89       	ldd	r18, Z+23	; 0x17
    335e:	62 2f       	mov	r22, r18
    3360:	fa 01       	movw	r30, r20
    3362:	09 95       	icall

	return;
}
    3364:	0f 90       	pop	r0
    3366:	0f 90       	pop	r0
    3368:	cf 91       	pop	r28
    336a:	df 91       	pop	r29
    336c:	08 95       	ret

0000336e <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    336e:	df 93       	push	r29
    3370:	cf 93       	push	r28
    3372:	0f 92       	push	r0
    3374:	cd b7       	in	r28, 0x3d	; 61
    3376:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    3378:	19 82       	std	Y+1, r1	; 0x01
    337a:	13 c0       	rjmp	.+38     	; 0x33a2 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    337c:	89 81       	ldd	r24, Y+1	; 0x01
    337e:	28 2f       	mov	r18, r24
    3380:	30 e0       	ldi	r19, 0x00	; 0
    3382:	c9 01       	movw	r24, r18
    3384:	88 0f       	add	r24, r24
    3386:	99 1f       	adc	r25, r25
    3388:	88 0f       	add	r24, r24
    338a:	99 1f       	adc	r25, r25
    338c:	88 0f       	add	r24, r24
    338e:	99 1f       	adc	r25, r25
    3390:	82 0f       	add	r24, r18
    3392:	93 1f       	adc	r25, r19
    3394:	8f 51       	subi	r24, 0x1F	; 31
    3396:	9e 4f       	sbci	r25, 0xFE	; 254
    3398:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    339c:	89 81       	ldd	r24, Y+1	; 0x01
    339e:	8f 5f       	subi	r24, 0xFF	; 255
    33a0:	89 83       	std	Y+1, r24	; 0x01
    33a2:	89 81       	ldd	r24, Y+1	; 0x01
    33a4:	82 30       	cpi	r24, 0x02	; 2
    33a6:	50 f3       	brcs	.-44     	; 0x337c <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    33a8:	83 ef       	ldi	r24, 0xF3	; 243
    33aa:	91 e0       	ldi	r25, 0x01	; 1
    33ac:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    33b0:	8c ef       	ldi	r24, 0xFC	; 252
    33b2:	91 e0       	ldi	r25, 0x01	; 1
    33b4:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    33b8:	89 e0       	ldi	r24, 0x09	; 9
    33ba:	92 e0       	ldi	r25, 0x02	; 2
    33bc:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    33c0:	83 ef       	ldi	r24, 0xF3	; 243
    33c2:	91 e0       	ldi	r25, 0x01	; 1
    33c4:	90 93 06 02 	sts	0x0206, r25
    33c8:	80 93 05 02 	sts	0x0205, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    33cc:	8c ef       	ldi	r24, 0xFC	; 252
    33ce:	91 e0       	ldi	r25, 0x01	; 1
    33d0:	90 93 08 02 	sts	0x0208, r25
    33d4:	80 93 07 02 	sts	0x0207, r24
}
    33d8:	0f 90       	pop	r0
    33da:	cf 91       	pop	r28
    33dc:	df 91       	pop	r29
    33de:	08 95       	ret

000033e0 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    33e0:	df 93       	push	r29
    33e2:	cf 93       	push	r28
    33e4:	00 d0       	rcall	.+0      	; 0x33e6 <xCoRoutineRemoveFromEventList+0x6>
    33e6:	00 d0       	rcall	.+0      	; 0x33e8 <xCoRoutineRemoveFromEventList+0x8>
    33e8:	0f 92       	push	r0
    33ea:	cd b7       	in	r28, 0x3d	; 61
    33ec:	de b7       	in	r29, 0x3e	; 62
    33ee:	9d 83       	std	Y+5, r25	; 0x05
    33f0:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    33f2:	ec 81       	ldd	r30, Y+4	; 0x04
    33f4:	fd 81       	ldd	r31, Y+5	; 0x05
    33f6:	05 80       	ldd	r0, Z+5	; 0x05
    33f8:	f6 81       	ldd	r31, Z+6	; 0x06
    33fa:	e0 2d       	mov	r30, r0
    33fc:	86 81       	ldd	r24, Z+6	; 0x06
    33fe:	97 81       	ldd	r25, Z+7	; 0x07
    3400:	9b 83       	std	Y+3, r25	; 0x03
    3402:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    3404:	8a 81       	ldd	r24, Y+2	; 0x02
    3406:	9b 81       	ldd	r25, Y+3	; 0x03
    3408:	0c 96       	adiw	r24, 0x0c	; 12
    340a:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    340e:	8a 81       	ldd	r24, Y+2	; 0x02
    3410:	9b 81       	ldd	r25, Y+3	; 0x03
    3412:	9c 01       	movw	r18, r24
    3414:	24 5f       	subi	r18, 0xF4	; 244
    3416:	3f 4f       	sbci	r19, 0xFF	; 255
    3418:	89 e0       	ldi	r24, 0x09	; 9
    341a:	92 e0       	ldi	r25, 0x02	; 2
    341c:	b9 01       	movw	r22, r18
    341e:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    3422:	ea 81       	ldd	r30, Y+2	; 0x02
    3424:	fb 81       	ldd	r31, Y+3	; 0x03
    3426:	96 89       	ldd	r25, Z+22	; 0x16
    3428:	e0 91 d8 01 	lds	r30, 0x01D8
    342c:	f0 91 d9 01 	lds	r31, 0x01D9
    3430:	86 89       	ldd	r24, Z+22	; 0x16
    3432:	98 17       	cp	r25, r24
    3434:	18 f0       	brcs	.+6      	; 0x343c <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    3436:	81 e0       	ldi	r24, 0x01	; 1
    3438:	89 83       	std	Y+1, r24	; 0x01
    343a:	01 c0       	rjmp	.+2      	; 0x343e <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    343c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    343e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3440:	0f 90       	pop	r0
    3442:	0f 90       	pop	r0
    3444:	0f 90       	pop	r0
    3446:	0f 90       	pop	r0
    3448:	0f 90       	pop	r0
    344a:	cf 91       	pop	r28
    344c:	df 91       	pop	r29
    344e:	08 95       	ret

00003450 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3450:	df 93       	push	r29
    3452:	cf 93       	push	r28
    3454:	00 d0       	rcall	.+0      	; 0x3456 <pvPortMalloc+0x6>
    3456:	00 d0       	rcall	.+0      	; 0x3458 <pvPortMalloc+0x8>
    3458:	cd b7       	in	r28, 0x3d	; 61
    345a:	de b7       	in	r29, 0x3e	; 62
    345c:	9c 83       	std	Y+4, r25	; 0x04
    345e:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    3460:	1a 82       	std	Y+2, r1	; 0x02
    3462:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    3464:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3468:	80 91 12 02 	lds	r24, 0x0212
    346c:	90 91 13 02 	lds	r25, 0x0213
    3470:	2b 81       	ldd	r18, Y+3	; 0x03
    3472:	3c 81       	ldd	r19, Y+4	; 0x04
    3474:	82 0f       	add	r24, r18
    3476:	93 1f       	adc	r25, r19
    3478:	24 e0       	ldi	r18, 0x04	; 4
    347a:	80 3b       	cpi	r24, 0xB0	; 176
    347c:	92 07       	cpc	r25, r18
    347e:	18 f5       	brcc	.+70     	; 0x34c6 <pvPortMalloc+0x76>
    3480:	20 91 12 02 	lds	r18, 0x0212
    3484:	30 91 13 02 	lds	r19, 0x0213
    3488:	8b 81       	ldd	r24, Y+3	; 0x03
    348a:	9c 81       	ldd	r25, Y+4	; 0x04
    348c:	28 0f       	add	r18, r24
    348e:	39 1f       	adc	r19, r25
    3490:	80 91 12 02 	lds	r24, 0x0212
    3494:	90 91 13 02 	lds	r25, 0x0213
    3498:	82 17       	cp	r24, r18
    349a:	93 07       	cpc	r25, r19
    349c:	a0 f4       	brcc	.+40     	; 0x34c6 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    349e:	80 91 12 02 	lds	r24, 0x0212
    34a2:	90 91 13 02 	lds	r25, 0x0213
    34a6:	8c 5e       	subi	r24, 0xEC	; 236
    34a8:	9d 4f       	sbci	r25, 0xFD	; 253
    34aa:	9a 83       	std	Y+2, r25	; 0x02
    34ac:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    34ae:	20 91 12 02 	lds	r18, 0x0212
    34b2:	30 91 13 02 	lds	r19, 0x0213
    34b6:	8b 81       	ldd	r24, Y+3	; 0x03
    34b8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ba:	82 0f       	add	r24, r18
    34bc:	93 1f       	adc	r25, r19
    34be:	90 93 13 02 	sts	0x0213, r25
    34c2:	80 93 12 02 	sts	0x0212, r24
		}	
	}
	xTaskResumeAll();
    34c6:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    34ca:	89 81       	ldd	r24, Y+1	; 0x01
    34cc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    34ce:	0f 90       	pop	r0
    34d0:	0f 90       	pop	r0
    34d2:	0f 90       	pop	r0
    34d4:	0f 90       	pop	r0
    34d6:	cf 91       	pop	r28
    34d8:	df 91       	pop	r29
    34da:	08 95       	ret

000034dc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    34dc:	df 93       	push	r29
    34de:	cf 93       	push	r28
    34e0:	00 d0       	rcall	.+0      	; 0x34e2 <vPortFree+0x6>
    34e2:	cd b7       	in	r28, 0x3d	; 61
    34e4:	de b7       	in	r29, 0x3e	; 62
    34e6:	9a 83       	std	Y+2, r25	; 0x02
    34e8:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    34ea:	0f 90       	pop	r0
    34ec:	0f 90       	pop	r0
    34ee:	cf 91       	pop	r28
    34f0:	df 91       	pop	r29
    34f2:	08 95       	ret

000034f4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    34f4:	df 93       	push	r29
    34f6:	cf 93       	push	r28
    34f8:	cd b7       	in	r28, 0x3d	; 61
    34fa:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    34fc:	10 92 13 02 	sts	0x0213, r1
    3500:	10 92 12 02 	sts	0x0212, r1
}
    3504:	cf 91       	pop	r28
    3506:	df 91       	pop	r29
    3508:	08 95       	ret

0000350a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    350a:	df 93       	push	r29
    350c:	cf 93       	push	r28
    350e:	cd b7       	in	r28, 0x3d	; 61
    3510:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    3512:	20 91 12 02 	lds	r18, 0x0212
    3516:	30 91 13 02 	lds	r19, 0x0213
    351a:	80 eb       	ldi	r24, 0xB0	; 176
    351c:	94 e0       	ldi	r25, 0x04	; 4
    351e:	82 1b       	sub	r24, r18
    3520:	93 0b       	sbc	r25, r19
}
    3522:	cf 91       	pop	r28
    3524:	df 91       	pop	r29
    3526:	08 95       	ret

00003528 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    3528:	df 93       	push	r29
    352a:	cf 93       	push	r28
    352c:	00 d0       	rcall	.+0      	; 0x352e <vListInitialise+0x6>
    352e:	cd b7       	in	r28, 0x3d	; 61
    3530:	de b7       	in	r29, 0x3e	; 62
    3532:	9a 83       	std	Y+2, r25	; 0x02
    3534:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    3536:	89 81       	ldd	r24, Y+1	; 0x01
    3538:	9a 81       	ldd	r25, Y+2	; 0x02
    353a:	03 96       	adiw	r24, 0x03	; 3
    353c:	e9 81       	ldd	r30, Y+1	; 0x01
    353e:	fa 81       	ldd	r31, Y+2	; 0x02
    3540:	92 83       	std	Z+2, r25	; 0x02
    3542:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    3544:	e9 81       	ldd	r30, Y+1	; 0x01
    3546:	fa 81       	ldd	r31, Y+2	; 0x02
    3548:	8f ef       	ldi	r24, 0xFF	; 255
    354a:	9f ef       	ldi	r25, 0xFF	; 255
    354c:	94 83       	std	Z+4, r25	; 0x04
    354e:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    3550:	89 81       	ldd	r24, Y+1	; 0x01
    3552:	9a 81       	ldd	r25, Y+2	; 0x02
    3554:	03 96       	adiw	r24, 0x03	; 3
    3556:	e9 81       	ldd	r30, Y+1	; 0x01
    3558:	fa 81       	ldd	r31, Y+2	; 0x02
    355a:	96 83       	std	Z+6, r25	; 0x06
    355c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    355e:	89 81       	ldd	r24, Y+1	; 0x01
    3560:	9a 81       	ldd	r25, Y+2	; 0x02
    3562:	03 96       	adiw	r24, 0x03	; 3
    3564:	e9 81       	ldd	r30, Y+1	; 0x01
    3566:	fa 81       	ldd	r31, Y+2	; 0x02
    3568:	90 87       	std	Z+8, r25	; 0x08
    356a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    356c:	e9 81       	ldd	r30, Y+1	; 0x01
    356e:	fa 81       	ldd	r31, Y+2	; 0x02
    3570:	10 82       	st	Z, r1
}
    3572:	0f 90       	pop	r0
    3574:	0f 90       	pop	r0
    3576:	cf 91       	pop	r28
    3578:	df 91       	pop	r29
    357a:	08 95       	ret

0000357c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    357c:	df 93       	push	r29
    357e:	cf 93       	push	r28
    3580:	00 d0       	rcall	.+0      	; 0x3582 <vListInitialiseItem+0x6>
    3582:	cd b7       	in	r28, 0x3d	; 61
    3584:	de b7       	in	r29, 0x3e	; 62
    3586:	9a 83       	std	Y+2, r25	; 0x02
    3588:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    358a:	e9 81       	ldd	r30, Y+1	; 0x01
    358c:	fa 81       	ldd	r31, Y+2	; 0x02
    358e:	11 86       	std	Z+9, r1	; 0x09
    3590:	10 86       	std	Z+8, r1	; 0x08
}
    3592:	0f 90       	pop	r0
    3594:	0f 90       	pop	r0
    3596:	cf 91       	pop	r28
    3598:	df 91       	pop	r29
    359a:	08 95       	ret

0000359c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    359c:	df 93       	push	r29
    359e:	cf 93       	push	r28
    35a0:	00 d0       	rcall	.+0      	; 0x35a2 <vListInsertEnd+0x6>
    35a2:	00 d0       	rcall	.+0      	; 0x35a4 <vListInsertEnd+0x8>
    35a4:	00 d0       	rcall	.+0      	; 0x35a6 <vListInsertEnd+0xa>
    35a6:	cd b7       	in	r28, 0x3d	; 61
    35a8:	de b7       	in	r29, 0x3e	; 62
    35aa:	9c 83       	std	Y+4, r25	; 0x04
    35ac:	8b 83       	std	Y+3, r24	; 0x03
    35ae:	7e 83       	std	Y+6, r23	; 0x06
    35b0:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    35b2:	eb 81       	ldd	r30, Y+3	; 0x03
    35b4:	fc 81       	ldd	r31, Y+4	; 0x04
    35b6:	81 81       	ldd	r24, Z+1	; 0x01
    35b8:	92 81       	ldd	r25, Z+2	; 0x02
    35ba:	9a 83       	std	Y+2, r25	; 0x02
    35bc:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    35be:	e9 81       	ldd	r30, Y+1	; 0x01
    35c0:	fa 81       	ldd	r31, Y+2	; 0x02
    35c2:	82 81       	ldd	r24, Z+2	; 0x02
    35c4:	93 81       	ldd	r25, Z+3	; 0x03
    35c6:	ed 81       	ldd	r30, Y+5	; 0x05
    35c8:	fe 81       	ldd	r31, Y+6	; 0x06
    35ca:	93 83       	std	Z+3, r25	; 0x03
    35cc:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    35ce:	eb 81       	ldd	r30, Y+3	; 0x03
    35d0:	fc 81       	ldd	r31, Y+4	; 0x04
    35d2:	81 81       	ldd	r24, Z+1	; 0x01
    35d4:	92 81       	ldd	r25, Z+2	; 0x02
    35d6:	ed 81       	ldd	r30, Y+5	; 0x05
    35d8:	fe 81       	ldd	r31, Y+6	; 0x06
    35da:	95 83       	std	Z+5, r25	; 0x05
    35dc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    35de:	e9 81       	ldd	r30, Y+1	; 0x01
    35e0:	fa 81       	ldd	r31, Y+2	; 0x02
    35e2:	02 80       	ldd	r0, Z+2	; 0x02
    35e4:	f3 81       	ldd	r31, Z+3	; 0x03
    35e6:	e0 2d       	mov	r30, r0
    35e8:	8d 81       	ldd	r24, Y+5	; 0x05
    35ea:	9e 81       	ldd	r25, Y+6	; 0x06
    35ec:	95 83       	std	Z+5, r25	; 0x05
    35ee:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    35f0:	8d 81       	ldd	r24, Y+5	; 0x05
    35f2:	9e 81       	ldd	r25, Y+6	; 0x06
    35f4:	e9 81       	ldd	r30, Y+1	; 0x01
    35f6:	fa 81       	ldd	r31, Y+2	; 0x02
    35f8:	93 83       	std	Z+3, r25	; 0x03
    35fa:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    35fc:	8d 81       	ldd	r24, Y+5	; 0x05
    35fe:	9e 81       	ldd	r25, Y+6	; 0x06
    3600:	eb 81       	ldd	r30, Y+3	; 0x03
    3602:	fc 81       	ldd	r31, Y+4	; 0x04
    3604:	92 83       	std	Z+2, r25	; 0x02
    3606:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3608:	ed 81       	ldd	r30, Y+5	; 0x05
    360a:	fe 81       	ldd	r31, Y+6	; 0x06
    360c:	8b 81       	ldd	r24, Y+3	; 0x03
    360e:	9c 81       	ldd	r25, Y+4	; 0x04
    3610:	91 87       	std	Z+9, r25	; 0x09
    3612:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3614:	eb 81       	ldd	r30, Y+3	; 0x03
    3616:	fc 81       	ldd	r31, Y+4	; 0x04
    3618:	80 81       	ld	r24, Z
    361a:	8f 5f       	subi	r24, 0xFF	; 255
    361c:	eb 81       	ldd	r30, Y+3	; 0x03
    361e:	fc 81       	ldd	r31, Y+4	; 0x04
    3620:	80 83       	st	Z, r24
}
    3622:	26 96       	adiw	r28, 0x06	; 6
    3624:	0f b6       	in	r0, 0x3f	; 63
    3626:	f8 94       	cli
    3628:	de bf       	out	0x3e, r29	; 62
    362a:	0f be       	out	0x3f, r0	; 63
    362c:	cd bf       	out	0x3d, r28	; 61
    362e:	cf 91       	pop	r28
    3630:	df 91       	pop	r29
    3632:	08 95       	ret

00003634 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    3634:	df 93       	push	r29
    3636:	cf 93       	push	r28
    3638:	cd b7       	in	r28, 0x3d	; 61
    363a:	de b7       	in	r29, 0x3e	; 62
    363c:	28 97       	sbiw	r28, 0x08	; 8
    363e:	0f b6       	in	r0, 0x3f	; 63
    3640:	f8 94       	cli
    3642:	de bf       	out	0x3e, r29	; 62
    3644:	0f be       	out	0x3f, r0	; 63
    3646:	cd bf       	out	0x3d, r28	; 61
    3648:	9e 83       	std	Y+6, r25	; 0x06
    364a:	8d 83       	std	Y+5, r24	; 0x05
    364c:	78 87       	std	Y+8, r23	; 0x08
    364e:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    3650:	ef 81       	ldd	r30, Y+7	; 0x07
    3652:	f8 85       	ldd	r31, Y+8	; 0x08
    3654:	80 81       	ld	r24, Z
    3656:	91 81       	ldd	r25, Z+1	; 0x01
    3658:	9a 83       	std	Y+2, r25	; 0x02
    365a:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    365c:	89 81       	ldd	r24, Y+1	; 0x01
    365e:	9a 81       	ldd	r25, Y+2	; 0x02
    3660:	2f ef       	ldi	r18, 0xFF	; 255
    3662:	8f 3f       	cpi	r24, 0xFF	; 255
    3664:	92 07       	cpc	r25, r18
    3666:	39 f4       	brne	.+14     	; 0x3676 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3668:	ed 81       	ldd	r30, Y+5	; 0x05
    366a:	fe 81       	ldd	r31, Y+6	; 0x06
    366c:	87 81       	ldd	r24, Z+7	; 0x07
    366e:	90 85       	ldd	r25, Z+8	; 0x08
    3670:	9c 83       	std	Y+4, r25	; 0x04
    3672:	8b 83       	std	Y+3, r24	; 0x03
    3674:	18 c0       	rjmp	.+48     	; 0x36a6 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    3676:	8d 81       	ldd	r24, Y+5	; 0x05
    3678:	9e 81       	ldd	r25, Y+6	; 0x06
    367a:	03 96       	adiw	r24, 0x03	; 3
    367c:	9c 83       	std	Y+4, r25	; 0x04
    367e:	8b 83       	std	Y+3, r24	; 0x03
    3680:	06 c0       	rjmp	.+12     	; 0x368e <vListInsert+0x5a>
    3682:	eb 81       	ldd	r30, Y+3	; 0x03
    3684:	fc 81       	ldd	r31, Y+4	; 0x04
    3686:	82 81       	ldd	r24, Z+2	; 0x02
    3688:	93 81       	ldd	r25, Z+3	; 0x03
    368a:	9c 83       	std	Y+4, r25	; 0x04
    368c:	8b 83       	std	Y+3, r24	; 0x03
    368e:	eb 81       	ldd	r30, Y+3	; 0x03
    3690:	fc 81       	ldd	r31, Y+4	; 0x04
    3692:	02 80       	ldd	r0, Z+2	; 0x02
    3694:	f3 81       	ldd	r31, Z+3	; 0x03
    3696:	e0 2d       	mov	r30, r0
    3698:	20 81       	ld	r18, Z
    369a:	31 81       	ldd	r19, Z+1	; 0x01
    369c:	89 81       	ldd	r24, Y+1	; 0x01
    369e:	9a 81       	ldd	r25, Y+2	; 0x02
    36a0:	82 17       	cp	r24, r18
    36a2:	93 07       	cpc	r25, r19
    36a4:	70 f7       	brcc	.-36     	; 0x3682 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    36a6:	eb 81       	ldd	r30, Y+3	; 0x03
    36a8:	fc 81       	ldd	r31, Y+4	; 0x04
    36aa:	82 81       	ldd	r24, Z+2	; 0x02
    36ac:	93 81       	ldd	r25, Z+3	; 0x03
    36ae:	ef 81       	ldd	r30, Y+7	; 0x07
    36b0:	f8 85       	ldd	r31, Y+8	; 0x08
    36b2:	93 83       	std	Z+3, r25	; 0x03
    36b4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    36b6:	ef 81       	ldd	r30, Y+7	; 0x07
    36b8:	f8 85       	ldd	r31, Y+8	; 0x08
    36ba:	02 80       	ldd	r0, Z+2	; 0x02
    36bc:	f3 81       	ldd	r31, Z+3	; 0x03
    36be:	e0 2d       	mov	r30, r0
    36c0:	8f 81       	ldd	r24, Y+7	; 0x07
    36c2:	98 85       	ldd	r25, Y+8	; 0x08
    36c4:	95 83       	std	Z+5, r25	; 0x05
    36c6:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    36c8:	ef 81       	ldd	r30, Y+7	; 0x07
    36ca:	f8 85       	ldd	r31, Y+8	; 0x08
    36cc:	8b 81       	ldd	r24, Y+3	; 0x03
    36ce:	9c 81       	ldd	r25, Y+4	; 0x04
    36d0:	95 83       	std	Z+5, r25	; 0x05
    36d2:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    36d4:	8f 81       	ldd	r24, Y+7	; 0x07
    36d6:	98 85       	ldd	r25, Y+8	; 0x08
    36d8:	eb 81       	ldd	r30, Y+3	; 0x03
    36da:	fc 81       	ldd	r31, Y+4	; 0x04
    36dc:	93 83       	std	Z+3, r25	; 0x03
    36de:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    36e0:	ef 81       	ldd	r30, Y+7	; 0x07
    36e2:	f8 85       	ldd	r31, Y+8	; 0x08
    36e4:	8d 81       	ldd	r24, Y+5	; 0x05
    36e6:	9e 81       	ldd	r25, Y+6	; 0x06
    36e8:	91 87       	std	Z+9, r25	; 0x09
    36ea:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    36ec:	ed 81       	ldd	r30, Y+5	; 0x05
    36ee:	fe 81       	ldd	r31, Y+6	; 0x06
    36f0:	80 81       	ld	r24, Z
    36f2:	8f 5f       	subi	r24, 0xFF	; 255
    36f4:	ed 81       	ldd	r30, Y+5	; 0x05
    36f6:	fe 81       	ldd	r31, Y+6	; 0x06
    36f8:	80 83       	st	Z, r24
}
    36fa:	28 96       	adiw	r28, 0x08	; 8
    36fc:	0f b6       	in	r0, 0x3f	; 63
    36fe:	f8 94       	cli
    3700:	de bf       	out	0x3e, r29	; 62
    3702:	0f be       	out	0x3f, r0	; 63
    3704:	cd bf       	out	0x3d, r28	; 61
    3706:	cf 91       	pop	r28
    3708:	df 91       	pop	r29
    370a:	08 95       	ret

0000370c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    370c:	df 93       	push	r29
    370e:	cf 93       	push	r28
    3710:	00 d0       	rcall	.+0      	; 0x3712 <vListRemove+0x6>
    3712:	00 d0       	rcall	.+0      	; 0x3714 <vListRemove+0x8>
    3714:	cd b7       	in	r28, 0x3d	; 61
    3716:	de b7       	in	r29, 0x3e	; 62
    3718:	9c 83       	std	Y+4, r25	; 0x04
    371a:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    371c:	eb 81       	ldd	r30, Y+3	; 0x03
    371e:	fc 81       	ldd	r31, Y+4	; 0x04
    3720:	a2 81       	ldd	r26, Z+2	; 0x02
    3722:	b3 81       	ldd	r27, Z+3	; 0x03
    3724:	eb 81       	ldd	r30, Y+3	; 0x03
    3726:	fc 81       	ldd	r31, Y+4	; 0x04
    3728:	84 81       	ldd	r24, Z+4	; 0x04
    372a:	95 81       	ldd	r25, Z+5	; 0x05
    372c:	15 96       	adiw	r26, 0x05	; 5
    372e:	9c 93       	st	X, r25
    3730:	8e 93       	st	-X, r24
    3732:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3734:	eb 81       	ldd	r30, Y+3	; 0x03
    3736:	fc 81       	ldd	r31, Y+4	; 0x04
    3738:	a4 81       	ldd	r26, Z+4	; 0x04
    373a:	b5 81       	ldd	r27, Z+5	; 0x05
    373c:	eb 81       	ldd	r30, Y+3	; 0x03
    373e:	fc 81       	ldd	r31, Y+4	; 0x04
    3740:	82 81       	ldd	r24, Z+2	; 0x02
    3742:	93 81       	ldd	r25, Z+3	; 0x03
    3744:	13 96       	adiw	r26, 0x03	; 3
    3746:	9c 93       	st	X, r25
    3748:	8e 93       	st	-X, r24
    374a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    374c:	eb 81       	ldd	r30, Y+3	; 0x03
    374e:	fc 81       	ldd	r31, Y+4	; 0x04
    3750:	80 85       	ldd	r24, Z+8	; 0x08
    3752:	91 85       	ldd	r25, Z+9	; 0x09
    3754:	9a 83       	std	Y+2, r25	; 0x02
    3756:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3758:	e9 81       	ldd	r30, Y+1	; 0x01
    375a:	fa 81       	ldd	r31, Y+2	; 0x02
    375c:	21 81       	ldd	r18, Z+1	; 0x01
    375e:	32 81       	ldd	r19, Z+2	; 0x02
    3760:	8b 81       	ldd	r24, Y+3	; 0x03
    3762:	9c 81       	ldd	r25, Y+4	; 0x04
    3764:	28 17       	cp	r18, r24
    3766:	39 07       	cpc	r19, r25
    3768:	41 f4       	brne	.+16     	; 0x377a <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    376a:	eb 81       	ldd	r30, Y+3	; 0x03
    376c:	fc 81       	ldd	r31, Y+4	; 0x04
    376e:	84 81       	ldd	r24, Z+4	; 0x04
    3770:	95 81       	ldd	r25, Z+5	; 0x05
    3772:	e9 81       	ldd	r30, Y+1	; 0x01
    3774:	fa 81       	ldd	r31, Y+2	; 0x02
    3776:	92 83       	std	Z+2, r25	; 0x02
    3778:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    377a:	eb 81       	ldd	r30, Y+3	; 0x03
    377c:	fc 81       	ldd	r31, Y+4	; 0x04
    377e:	11 86       	std	Z+9, r1	; 0x09
    3780:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3782:	e9 81       	ldd	r30, Y+1	; 0x01
    3784:	fa 81       	ldd	r31, Y+2	; 0x02
    3786:	80 81       	ld	r24, Z
    3788:	81 50       	subi	r24, 0x01	; 1
    378a:	e9 81       	ldd	r30, Y+1	; 0x01
    378c:	fa 81       	ldd	r31, Y+2	; 0x02
    378e:	80 83       	st	Z, r24
}
    3790:	0f 90       	pop	r0
    3792:	0f 90       	pop	r0
    3794:	0f 90       	pop	r0
    3796:	0f 90       	pop	r0
    3798:	cf 91       	pop	r28
    379a:	df 91       	pop	r29
    379c:	08 95       	ret

0000379e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    379e:	df 93       	push	r29
    37a0:	cf 93       	push	r28
    37a2:	cd b7       	in	r28, 0x3d	; 61
    37a4:	de b7       	in	r29, 0x3e	; 62
    37a6:	28 97       	sbiw	r28, 0x08	; 8
    37a8:	0f b6       	in	r0, 0x3f	; 63
    37aa:	f8 94       	cli
    37ac:	de bf       	out	0x3e, r29	; 62
    37ae:	0f be       	out	0x3f, r0	; 63
    37b0:	cd bf       	out	0x3d, r28	; 61
    37b2:	9c 83       	std	Y+4, r25	; 0x04
    37b4:	8b 83       	std	Y+3, r24	; 0x03
    37b6:	7e 83       	std	Y+6, r23	; 0x06
    37b8:	6d 83       	std	Y+5, r22	; 0x05
    37ba:	58 87       	std	Y+8, r21	; 0x08
    37bc:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    37be:	eb 81       	ldd	r30, Y+3	; 0x03
    37c0:	fc 81       	ldd	r31, Y+4	; 0x04
    37c2:	81 e1       	ldi	r24, 0x11	; 17
    37c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    37c6:	8b 81       	ldd	r24, Y+3	; 0x03
    37c8:	9c 81       	ldd	r25, Y+4	; 0x04
    37ca:	01 97       	sbiw	r24, 0x01	; 1
    37cc:	9c 83       	std	Y+4, r25	; 0x04
    37ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    37d0:	eb 81       	ldd	r30, Y+3	; 0x03
    37d2:	fc 81       	ldd	r31, Y+4	; 0x04
    37d4:	82 e2       	ldi	r24, 0x22	; 34
    37d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    37d8:	8b 81       	ldd	r24, Y+3	; 0x03
    37da:	9c 81       	ldd	r25, Y+4	; 0x04
    37dc:	01 97       	sbiw	r24, 0x01	; 1
    37de:	9c 83       	std	Y+4, r25	; 0x04
    37e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    37e2:	eb 81       	ldd	r30, Y+3	; 0x03
    37e4:	fc 81       	ldd	r31, Y+4	; 0x04
    37e6:	83 e3       	ldi	r24, 0x33	; 51
    37e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    37ea:	8b 81       	ldd	r24, Y+3	; 0x03
    37ec:	9c 81       	ldd	r25, Y+4	; 0x04
    37ee:	01 97       	sbiw	r24, 0x01	; 1
    37f0:	9c 83       	std	Y+4, r25	; 0x04
    37f2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    37f4:	8d 81       	ldd	r24, Y+5	; 0x05
    37f6:	9e 81       	ldd	r25, Y+6	; 0x06
    37f8:	9a 83       	std	Y+2, r25	; 0x02
    37fa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    37fc:	89 81       	ldd	r24, Y+1	; 0x01
    37fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3800:	fc 81       	ldd	r31, Y+4	; 0x04
    3802:	80 83       	st	Z, r24
	pxTopOfStack--;
    3804:	8b 81       	ldd	r24, Y+3	; 0x03
    3806:	9c 81       	ldd	r25, Y+4	; 0x04
    3808:	01 97       	sbiw	r24, 0x01	; 1
    380a:	9c 83       	std	Y+4, r25	; 0x04
    380c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    380e:	89 81       	ldd	r24, Y+1	; 0x01
    3810:	9a 81       	ldd	r25, Y+2	; 0x02
    3812:	89 2f       	mov	r24, r25
    3814:	99 27       	eor	r25, r25
    3816:	9a 83       	std	Y+2, r25	; 0x02
    3818:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    381a:	89 81       	ldd	r24, Y+1	; 0x01
    381c:	eb 81       	ldd	r30, Y+3	; 0x03
    381e:	fc 81       	ldd	r31, Y+4	; 0x04
    3820:	80 83       	st	Z, r24
	pxTopOfStack--;
    3822:	8b 81       	ldd	r24, Y+3	; 0x03
    3824:	9c 81       	ldd	r25, Y+4	; 0x04
    3826:	01 97       	sbiw	r24, 0x01	; 1
    3828:	9c 83       	std	Y+4, r25	; 0x04
    382a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    382c:	eb 81       	ldd	r30, Y+3	; 0x03
    382e:	fc 81       	ldd	r31, Y+4	; 0x04
    3830:	10 82       	st	Z, r1
	pxTopOfStack--;
    3832:	8b 81       	ldd	r24, Y+3	; 0x03
    3834:	9c 81       	ldd	r25, Y+4	; 0x04
    3836:	01 97       	sbiw	r24, 0x01	; 1
    3838:	9c 83       	std	Y+4, r25	; 0x04
    383a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    383c:	eb 81       	ldd	r30, Y+3	; 0x03
    383e:	fc 81       	ldd	r31, Y+4	; 0x04
    3840:	80 e8       	ldi	r24, 0x80	; 128
    3842:	80 83       	st	Z, r24
	pxTopOfStack--;
    3844:	8b 81       	ldd	r24, Y+3	; 0x03
    3846:	9c 81       	ldd	r25, Y+4	; 0x04
    3848:	01 97       	sbiw	r24, 0x01	; 1
    384a:	9c 83       	std	Y+4, r25	; 0x04
    384c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    384e:	eb 81       	ldd	r30, Y+3	; 0x03
    3850:	fc 81       	ldd	r31, Y+4	; 0x04
    3852:	10 82       	st	Z, r1
	pxTopOfStack--;
    3854:	8b 81       	ldd	r24, Y+3	; 0x03
    3856:	9c 81       	ldd	r25, Y+4	; 0x04
    3858:	01 97       	sbiw	r24, 0x01	; 1
    385a:	9c 83       	std	Y+4, r25	; 0x04
    385c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    385e:	eb 81       	ldd	r30, Y+3	; 0x03
    3860:	fc 81       	ldd	r31, Y+4	; 0x04
    3862:	82 e0       	ldi	r24, 0x02	; 2
    3864:	80 83       	st	Z, r24
	pxTopOfStack--;
    3866:	8b 81       	ldd	r24, Y+3	; 0x03
    3868:	9c 81       	ldd	r25, Y+4	; 0x04
    386a:	01 97       	sbiw	r24, 0x01	; 1
    386c:	9c 83       	std	Y+4, r25	; 0x04
    386e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3870:	eb 81       	ldd	r30, Y+3	; 0x03
    3872:	fc 81       	ldd	r31, Y+4	; 0x04
    3874:	83 e0       	ldi	r24, 0x03	; 3
    3876:	80 83       	st	Z, r24
	pxTopOfStack--;
    3878:	8b 81       	ldd	r24, Y+3	; 0x03
    387a:	9c 81       	ldd	r25, Y+4	; 0x04
    387c:	01 97       	sbiw	r24, 0x01	; 1
    387e:	9c 83       	std	Y+4, r25	; 0x04
    3880:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    3882:	eb 81       	ldd	r30, Y+3	; 0x03
    3884:	fc 81       	ldd	r31, Y+4	; 0x04
    3886:	84 e0       	ldi	r24, 0x04	; 4
    3888:	80 83       	st	Z, r24
	pxTopOfStack--;
    388a:	8b 81       	ldd	r24, Y+3	; 0x03
    388c:	9c 81       	ldd	r25, Y+4	; 0x04
    388e:	01 97       	sbiw	r24, 0x01	; 1
    3890:	9c 83       	std	Y+4, r25	; 0x04
    3892:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3894:	eb 81       	ldd	r30, Y+3	; 0x03
    3896:	fc 81       	ldd	r31, Y+4	; 0x04
    3898:	85 e0       	ldi	r24, 0x05	; 5
    389a:	80 83       	st	Z, r24
	pxTopOfStack--;
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    389e:	9c 81       	ldd	r25, Y+4	; 0x04
    38a0:	01 97       	sbiw	r24, 0x01	; 1
    38a2:	9c 83       	std	Y+4, r25	; 0x04
    38a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    38a6:	eb 81       	ldd	r30, Y+3	; 0x03
    38a8:	fc 81       	ldd	r31, Y+4	; 0x04
    38aa:	86 e0       	ldi	r24, 0x06	; 6
    38ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    38ae:	8b 81       	ldd	r24, Y+3	; 0x03
    38b0:	9c 81       	ldd	r25, Y+4	; 0x04
    38b2:	01 97       	sbiw	r24, 0x01	; 1
    38b4:	9c 83       	std	Y+4, r25	; 0x04
    38b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    38b8:	eb 81       	ldd	r30, Y+3	; 0x03
    38ba:	fc 81       	ldd	r31, Y+4	; 0x04
    38bc:	87 e0       	ldi	r24, 0x07	; 7
    38be:	80 83       	st	Z, r24
	pxTopOfStack--;
    38c0:	8b 81       	ldd	r24, Y+3	; 0x03
    38c2:	9c 81       	ldd	r25, Y+4	; 0x04
    38c4:	01 97       	sbiw	r24, 0x01	; 1
    38c6:	9c 83       	std	Y+4, r25	; 0x04
    38c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    38ca:	eb 81       	ldd	r30, Y+3	; 0x03
    38cc:	fc 81       	ldd	r31, Y+4	; 0x04
    38ce:	88 e0       	ldi	r24, 0x08	; 8
    38d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    38d2:	8b 81       	ldd	r24, Y+3	; 0x03
    38d4:	9c 81       	ldd	r25, Y+4	; 0x04
    38d6:	01 97       	sbiw	r24, 0x01	; 1
    38d8:	9c 83       	std	Y+4, r25	; 0x04
    38da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    38dc:	eb 81       	ldd	r30, Y+3	; 0x03
    38de:	fc 81       	ldd	r31, Y+4	; 0x04
    38e0:	89 e0       	ldi	r24, 0x09	; 9
    38e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    38e4:	8b 81       	ldd	r24, Y+3	; 0x03
    38e6:	9c 81       	ldd	r25, Y+4	; 0x04
    38e8:	01 97       	sbiw	r24, 0x01	; 1
    38ea:	9c 83       	std	Y+4, r25	; 0x04
    38ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    38ee:	eb 81       	ldd	r30, Y+3	; 0x03
    38f0:	fc 81       	ldd	r31, Y+4	; 0x04
    38f2:	80 e1       	ldi	r24, 0x10	; 16
    38f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    38f6:	8b 81       	ldd	r24, Y+3	; 0x03
    38f8:	9c 81       	ldd	r25, Y+4	; 0x04
    38fa:	01 97       	sbiw	r24, 0x01	; 1
    38fc:	9c 83       	std	Y+4, r25	; 0x04
    38fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3900:	eb 81       	ldd	r30, Y+3	; 0x03
    3902:	fc 81       	ldd	r31, Y+4	; 0x04
    3904:	81 e1       	ldi	r24, 0x11	; 17
    3906:	80 83       	st	Z, r24
	pxTopOfStack--;
    3908:	8b 81       	ldd	r24, Y+3	; 0x03
    390a:	9c 81       	ldd	r25, Y+4	; 0x04
    390c:	01 97       	sbiw	r24, 0x01	; 1
    390e:	9c 83       	std	Y+4, r25	; 0x04
    3910:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    3912:	eb 81       	ldd	r30, Y+3	; 0x03
    3914:	fc 81       	ldd	r31, Y+4	; 0x04
    3916:	82 e1       	ldi	r24, 0x12	; 18
    3918:	80 83       	st	Z, r24
	pxTopOfStack--;
    391a:	8b 81       	ldd	r24, Y+3	; 0x03
    391c:	9c 81       	ldd	r25, Y+4	; 0x04
    391e:	01 97       	sbiw	r24, 0x01	; 1
    3920:	9c 83       	std	Y+4, r25	; 0x04
    3922:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    3924:	eb 81       	ldd	r30, Y+3	; 0x03
    3926:	fc 81       	ldd	r31, Y+4	; 0x04
    3928:	83 e1       	ldi	r24, 0x13	; 19
    392a:	80 83       	st	Z, r24
	pxTopOfStack--;
    392c:	8b 81       	ldd	r24, Y+3	; 0x03
    392e:	9c 81       	ldd	r25, Y+4	; 0x04
    3930:	01 97       	sbiw	r24, 0x01	; 1
    3932:	9c 83       	std	Y+4, r25	; 0x04
    3934:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    3936:	eb 81       	ldd	r30, Y+3	; 0x03
    3938:	fc 81       	ldd	r31, Y+4	; 0x04
    393a:	84 e1       	ldi	r24, 0x14	; 20
    393c:	80 83       	st	Z, r24
	pxTopOfStack--;
    393e:	8b 81       	ldd	r24, Y+3	; 0x03
    3940:	9c 81       	ldd	r25, Y+4	; 0x04
    3942:	01 97       	sbiw	r24, 0x01	; 1
    3944:	9c 83       	std	Y+4, r25	; 0x04
    3946:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3948:	eb 81       	ldd	r30, Y+3	; 0x03
    394a:	fc 81       	ldd	r31, Y+4	; 0x04
    394c:	85 e1       	ldi	r24, 0x15	; 21
    394e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3950:	8b 81       	ldd	r24, Y+3	; 0x03
    3952:	9c 81       	ldd	r25, Y+4	; 0x04
    3954:	01 97       	sbiw	r24, 0x01	; 1
    3956:	9c 83       	std	Y+4, r25	; 0x04
    3958:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    395a:	eb 81       	ldd	r30, Y+3	; 0x03
    395c:	fc 81       	ldd	r31, Y+4	; 0x04
    395e:	86 e1       	ldi	r24, 0x16	; 22
    3960:	80 83       	st	Z, r24
	pxTopOfStack--;
    3962:	8b 81       	ldd	r24, Y+3	; 0x03
    3964:	9c 81       	ldd	r25, Y+4	; 0x04
    3966:	01 97       	sbiw	r24, 0x01	; 1
    3968:	9c 83       	std	Y+4, r25	; 0x04
    396a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    396c:	eb 81       	ldd	r30, Y+3	; 0x03
    396e:	fc 81       	ldd	r31, Y+4	; 0x04
    3970:	87 e1       	ldi	r24, 0x17	; 23
    3972:	80 83       	st	Z, r24
	pxTopOfStack--;
    3974:	8b 81       	ldd	r24, Y+3	; 0x03
    3976:	9c 81       	ldd	r25, Y+4	; 0x04
    3978:	01 97       	sbiw	r24, 0x01	; 1
    397a:	9c 83       	std	Y+4, r25	; 0x04
    397c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    397e:	eb 81       	ldd	r30, Y+3	; 0x03
    3980:	fc 81       	ldd	r31, Y+4	; 0x04
    3982:	88 e1       	ldi	r24, 0x18	; 24
    3984:	80 83       	st	Z, r24
	pxTopOfStack--;
    3986:	8b 81       	ldd	r24, Y+3	; 0x03
    3988:	9c 81       	ldd	r25, Y+4	; 0x04
    398a:	01 97       	sbiw	r24, 0x01	; 1
    398c:	9c 83       	std	Y+4, r25	; 0x04
    398e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3990:	eb 81       	ldd	r30, Y+3	; 0x03
    3992:	fc 81       	ldd	r31, Y+4	; 0x04
    3994:	89 e1       	ldi	r24, 0x19	; 25
    3996:	80 83       	st	Z, r24
	pxTopOfStack--;
    3998:	8b 81       	ldd	r24, Y+3	; 0x03
    399a:	9c 81       	ldd	r25, Y+4	; 0x04
    399c:	01 97       	sbiw	r24, 0x01	; 1
    399e:	9c 83       	std	Y+4, r25	; 0x04
    39a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    39a2:	eb 81       	ldd	r30, Y+3	; 0x03
    39a4:	fc 81       	ldd	r31, Y+4	; 0x04
    39a6:	80 e2       	ldi	r24, 0x20	; 32
    39a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    39aa:	8b 81       	ldd	r24, Y+3	; 0x03
    39ac:	9c 81       	ldd	r25, Y+4	; 0x04
    39ae:	01 97       	sbiw	r24, 0x01	; 1
    39b0:	9c 83       	std	Y+4, r25	; 0x04
    39b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    39b4:	eb 81       	ldd	r30, Y+3	; 0x03
    39b6:	fc 81       	ldd	r31, Y+4	; 0x04
    39b8:	81 e2       	ldi	r24, 0x21	; 33
    39ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    39bc:	8b 81       	ldd	r24, Y+3	; 0x03
    39be:	9c 81       	ldd	r25, Y+4	; 0x04
    39c0:	01 97       	sbiw	r24, 0x01	; 1
    39c2:	9c 83       	std	Y+4, r25	; 0x04
    39c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    39c6:	eb 81       	ldd	r30, Y+3	; 0x03
    39c8:	fc 81       	ldd	r31, Y+4	; 0x04
    39ca:	82 e2       	ldi	r24, 0x22	; 34
    39cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    39ce:	8b 81       	ldd	r24, Y+3	; 0x03
    39d0:	9c 81       	ldd	r25, Y+4	; 0x04
    39d2:	01 97       	sbiw	r24, 0x01	; 1
    39d4:	9c 83       	std	Y+4, r25	; 0x04
    39d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    39d8:	eb 81       	ldd	r30, Y+3	; 0x03
    39da:	fc 81       	ldd	r31, Y+4	; 0x04
    39dc:	83 e2       	ldi	r24, 0x23	; 35
    39de:	80 83       	st	Z, r24
	pxTopOfStack--;
    39e0:	8b 81       	ldd	r24, Y+3	; 0x03
    39e2:	9c 81       	ldd	r25, Y+4	; 0x04
    39e4:	01 97       	sbiw	r24, 0x01	; 1
    39e6:	9c 83       	std	Y+4, r25	; 0x04
    39e8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    39ea:	8f 81       	ldd	r24, Y+7	; 0x07
    39ec:	98 85       	ldd	r25, Y+8	; 0x08
    39ee:	9a 83       	std	Y+2, r25	; 0x02
    39f0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    39f2:	89 81       	ldd	r24, Y+1	; 0x01
    39f4:	eb 81       	ldd	r30, Y+3	; 0x03
    39f6:	fc 81       	ldd	r31, Y+4	; 0x04
    39f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    39fa:	8b 81       	ldd	r24, Y+3	; 0x03
    39fc:	9c 81       	ldd	r25, Y+4	; 0x04
    39fe:	01 97       	sbiw	r24, 0x01	; 1
    3a00:	9c 83       	std	Y+4, r25	; 0x04
    3a02:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3a04:	89 81       	ldd	r24, Y+1	; 0x01
    3a06:	9a 81       	ldd	r25, Y+2	; 0x02
    3a08:	89 2f       	mov	r24, r25
    3a0a:	99 27       	eor	r25, r25
    3a0c:	9a 83       	std	Y+2, r25	; 0x02
    3a0e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3a10:	89 81       	ldd	r24, Y+1	; 0x01
    3a12:	eb 81       	ldd	r30, Y+3	; 0x03
    3a14:	fc 81       	ldd	r31, Y+4	; 0x04
    3a16:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a18:	8b 81       	ldd	r24, Y+3	; 0x03
    3a1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a1c:	01 97       	sbiw	r24, 0x01	; 1
    3a1e:	9c 83       	std	Y+4, r25	; 0x04
    3a20:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3a22:	eb 81       	ldd	r30, Y+3	; 0x03
    3a24:	fc 81       	ldd	r31, Y+4	; 0x04
    3a26:	86 e2       	ldi	r24, 0x26	; 38
    3a28:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a2e:	01 97       	sbiw	r24, 0x01	; 1
    3a30:	9c 83       	std	Y+4, r25	; 0x04
    3a32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    3a34:	eb 81       	ldd	r30, Y+3	; 0x03
    3a36:	fc 81       	ldd	r31, Y+4	; 0x04
    3a38:	87 e2       	ldi	r24, 0x27	; 39
    3a3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a40:	01 97       	sbiw	r24, 0x01	; 1
    3a42:	9c 83       	std	Y+4, r25	; 0x04
    3a44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    3a46:	eb 81       	ldd	r30, Y+3	; 0x03
    3a48:	fc 81       	ldd	r31, Y+4	; 0x04
    3a4a:	88 e2       	ldi	r24, 0x28	; 40
    3a4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a50:	9c 81       	ldd	r25, Y+4	; 0x04
    3a52:	01 97       	sbiw	r24, 0x01	; 1
    3a54:	9c 83       	std	Y+4, r25	; 0x04
    3a56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    3a58:	eb 81       	ldd	r30, Y+3	; 0x03
    3a5a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a5c:	89 e2       	ldi	r24, 0x29	; 41
    3a5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a60:	8b 81       	ldd	r24, Y+3	; 0x03
    3a62:	9c 81       	ldd	r25, Y+4	; 0x04
    3a64:	01 97       	sbiw	r24, 0x01	; 1
    3a66:	9c 83       	std	Y+4, r25	; 0x04
    3a68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a6e:	80 e3       	ldi	r24, 0x30	; 48
    3a70:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a72:	8b 81       	ldd	r24, Y+3	; 0x03
    3a74:	9c 81       	ldd	r25, Y+4	; 0x04
    3a76:	01 97       	sbiw	r24, 0x01	; 1
    3a78:	9c 83       	std	Y+4, r25	; 0x04
    3a7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a80:	81 e3       	ldi	r24, 0x31	; 49
    3a82:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a84:	8b 81       	ldd	r24, Y+3	; 0x03
    3a86:	9c 81       	ldd	r25, Y+4	; 0x04
    3a88:	01 97       	sbiw	r24, 0x01	; 1
    3a8a:	9c 83       	std	Y+4, r25	; 0x04
    3a8c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a90:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3a92:	28 96       	adiw	r28, 0x08	; 8
    3a94:	0f b6       	in	r0, 0x3f	; 63
    3a96:	f8 94       	cli
    3a98:	de bf       	out	0x3e, r29	; 62
    3a9a:	0f be       	out	0x3f, r0	; 63
    3a9c:	cd bf       	out	0x3d, r28	; 61
    3a9e:	cf 91       	pop	r28
    3aa0:	df 91       	pop	r29
    3aa2:	08 95       	ret

00003aa4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3aa4:	df 93       	push	r29
    3aa6:	cf 93       	push	r28
    3aa8:	cd b7       	in	r28, 0x3d	; 61
    3aaa:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3aac:	0e 94 42 1e 	call	0x3c84	; 0x3c84 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3ab0:	a0 91 c4 06 	lds	r26, 0x06C4
    3ab4:	b0 91 c5 06 	lds	r27, 0x06C5
    3ab8:	cd 91       	ld	r28, X+
    3aba:	cd bf       	out	0x3d, r28	; 61
    3abc:	dd 91       	ld	r29, X+
    3abe:	de bf       	out	0x3e, r29	; 62
    3ac0:	ff 91       	pop	r31
    3ac2:	ef 91       	pop	r30
    3ac4:	df 91       	pop	r29
    3ac6:	cf 91       	pop	r28
    3ac8:	bf 91       	pop	r27
    3aca:	af 91       	pop	r26
    3acc:	9f 91       	pop	r25
    3ace:	8f 91       	pop	r24
    3ad0:	7f 91       	pop	r23
    3ad2:	6f 91       	pop	r22
    3ad4:	5f 91       	pop	r21
    3ad6:	4f 91       	pop	r20
    3ad8:	3f 91       	pop	r19
    3ada:	2f 91       	pop	r18
    3adc:	1f 91       	pop	r17
    3ade:	0f 91       	pop	r16
    3ae0:	ff 90       	pop	r15
    3ae2:	ef 90       	pop	r14
    3ae4:	df 90       	pop	r13
    3ae6:	cf 90       	pop	r12
    3ae8:	bf 90       	pop	r11
    3aea:	af 90       	pop	r10
    3aec:	9f 90       	pop	r9
    3aee:	8f 90       	pop	r8
    3af0:	7f 90       	pop	r7
    3af2:	6f 90       	pop	r6
    3af4:	5f 90       	pop	r5
    3af6:	4f 90       	pop	r4
    3af8:	3f 90       	pop	r3
    3afa:	2f 90       	pop	r2
    3afc:	1f 90       	pop	r1
    3afe:	0f 90       	pop	r0
    3b00:	0f be       	out	0x3f, r0	; 63
    3b02:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3b04:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3b06:	81 e0       	ldi	r24, 0x01	; 1
}
    3b08:	cf 91       	pop	r28
    3b0a:	df 91       	pop	r29
    3b0c:	08 95       	ret

00003b0e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3b0e:	df 93       	push	r29
    3b10:	cf 93       	push	r28
    3b12:	cd b7       	in	r28, 0x3d	; 61
    3b14:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3b16:	cf 91       	pop	r28
    3b18:	df 91       	pop	r29
    3b1a:	08 95       	ret

00003b1c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3b1c:	0f 92       	push	r0
    3b1e:	0f b6       	in	r0, 0x3f	; 63
    3b20:	f8 94       	cli
    3b22:	0f 92       	push	r0
    3b24:	1f 92       	push	r1
    3b26:	11 24       	eor	r1, r1
    3b28:	2f 92       	push	r2
    3b2a:	3f 92       	push	r3
    3b2c:	4f 92       	push	r4
    3b2e:	5f 92       	push	r5
    3b30:	6f 92       	push	r6
    3b32:	7f 92       	push	r7
    3b34:	8f 92       	push	r8
    3b36:	9f 92       	push	r9
    3b38:	af 92       	push	r10
    3b3a:	bf 92       	push	r11
    3b3c:	cf 92       	push	r12
    3b3e:	df 92       	push	r13
    3b40:	ef 92       	push	r14
    3b42:	ff 92       	push	r15
    3b44:	0f 93       	push	r16
    3b46:	1f 93       	push	r17
    3b48:	2f 93       	push	r18
    3b4a:	3f 93       	push	r19
    3b4c:	4f 93       	push	r20
    3b4e:	5f 93       	push	r21
    3b50:	6f 93       	push	r22
    3b52:	7f 93       	push	r23
    3b54:	8f 93       	push	r24
    3b56:	9f 93       	push	r25
    3b58:	af 93       	push	r26
    3b5a:	bf 93       	push	r27
    3b5c:	cf 93       	push	r28
    3b5e:	df 93       	push	r29
    3b60:	ef 93       	push	r30
    3b62:	ff 93       	push	r31
    3b64:	a0 91 c4 06 	lds	r26, 0x06C4
    3b68:	b0 91 c5 06 	lds	r27, 0x06C5
    3b6c:	0d b6       	in	r0, 0x3d	; 61
    3b6e:	0d 92       	st	X+, r0
    3b70:	0e b6       	in	r0, 0x3e	; 62
    3b72:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3b74:	0e 94 12 28 	call	0x5024	; 0x5024 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3b78:	a0 91 c4 06 	lds	r26, 0x06C4
    3b7c:	b0 91 c5 06 	lds	r27, 0x06C5
    3b80:	cd 91       	ld	r28, X+
    3b82:	cd bf       	out	0x3d, r28	; 61
    3b84:	dd 91       	ld	r29, X+
    3b86:	de bf       	out	0x3e, r29	; 62
    3b88:	ff 91       	pop	r31
    3b8a:	ef 91       	pop	r30
    3b8c:	df 91       	pop	r29
    3b8e:	cf 91       	pop	r28
    3b90:	bf 91       	pop	r27
    3b92:	af 91       	pop	r26
    3b94:	9f 91       	pop	r25
    3b96:	8f 91       	pop	r24
    3b98:	7f 91       	pop	r23
    3b9a:	6f 91       	pop	r22
    3b9c:	5f 91       	pop	r21
    3b9e:	4f 91       	pop	r20
    3ba0:	3f 91       	pop	r19
    3ba2:	2f 91       	pop	r18
    3ba4:	1f 91       	pop	r17
    3ba6:	0f 91       	pop	r16
    3ba8:	ff 90       	pop	r15
    3baa:	ef 90       	pop	r14
    3bac:	df 90       	pop	r13
    3bae:	cf 90       	pop	r12
    3bb0:	bf 90       	pop	r11
    3bb2:	af 90       	pop	r10
    3bb4:	9f 90       	pop	r9
    3bb6:	8f 90       	pop	r8
    3bb8:	7f 90       	pop	r7
    3bba:	6f 90       	pop	r6
    3bbc:	5f 90       	pop	r5
    3bbe:	4f 90       	pop	r4
    3bc0:	3f 90       	pop	r3
    3bc2:	2f 90       	pop	r2
    3bc4:	1f 90       	pop	r1
    3bc6:	0f 90       	pop	r0
    3bc8:	0f be       	out	0x3f, r0	; 63
    3bca:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3bcc:	08 95       	ret

00003bce <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3bce:	0f 92       	push	r0
    3bd0:	0f b6       	in	r0, 0x3f	; 63
    3bd2:	f8 94       	cli
    3bd4:	0f 92       	push	r0
    3bd6:	1f 92       	push	r1
    3bd8:	11 24       	eor	r1, r1
    3bda:	2f 92       	push	r2
    3bdc:	3f 92       	push	r3
    3bde:	4f 92       	push	r4
    3be0:	5f 92       	push	r5
    3be2:	6f 92       	push	r6
    3be4:	7f 92       	push	r7
    3be6:	8f 92       	push	r8
    3be8:	9f 92       	push	r9
    3bea:	af 92       	push	r10
    3bec:	bf 92       	push	r11
    3bee:	cf 92       	push	r12
    3bf0:	df 92       	push	r13
    3bf2:	ef 92       	push	r14
    3bf4:	ff 92       	push	r15
    3bf6:	0f 93       	push	r16
    3bf8:	1f 93       	push	r17
    3bfa:	2f 93       	push	r18
    3bfc:	3f 93       	push	r19
    3bfe:	4f 93       	push	r20
    3c00:	5f 93       	push	r21
    3c02:	6f 93       	push	r22
    3c04:	7f 93       	push	r23
    3c06:	8f 93       	push	r24
    3c08:	9f 93       	push	r25
    3c0a:	af 93       	push	r26
    3c0c:	bf 93       	push	r27
    3c0e:	cf 93       	push	r28
    3c10:	df 93       	push	r29
    3c12:	ef 93       	push	r30
    3c14:	ff 93       	push	r31
    3c16:	a0 91 c4 06 	lds	r26, 0x06C4
    3c1a:	b0 91 c5 06 	lds	r27, 0x06C5
    3c1e:	0d b6       	in	r0, 0x3d	; 61
    3c20:	0d 92       	st	X+, r0
    3c22:	0e b6       	in	r0, 0x3e	; 62
    3c24:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3c26:	0e 94 3d 27 	call	0x4e7a	; 0x4e7a <vTaskIncrementTick>
	vTaskSwitchContext();
    3c2a:	0e 94 12 28 	call	0x5024	; 0x5024 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3c2e:	a0 91 c4 06 	lds	r26, 0x06C4
    3c32:	b0 91 c5 06 	lds	r27, 0x06C5
    3c36:	cd 91       	ld	r28, X+
    3c38:	cd bf       	out	0x3d, r28	; 61
    3c3a:	dd 91       	ld	r29, X+
    3c3c:	de bf       	out	0x3e, r29	; 62
    3c3e:	ff 91       	pop	r31
    3c40:	ef 91       	pop	r30
    3c42:	df 91       	pop	r29
    3c44:	cf 91       	pop	r28
    3c46:	bf 91       	pop	r27
    3c48:	af 91       	pop	r26
    3c4a:	9f 91       	pop	r25
    3c4c:	8f 91       	pop	r24
    3c4e:	7f 91       	pop	r23
    3c50:	6f 91       	pop	r22
    3c52:	5f 91       	pop	r21
    3c54:	4f 91       	pop	r20
    3c56:	3f 91       	pop	r19
    3c58:	2f 91       	pop	r18
    3c5a:	1f 91       	pop	r17
    3c5c:	0f 91       	pop	r16
    3c5e:	ff 90       	pop	r15
    3c60:	ef 90       	pop	r14
    3c62:	df 90       	pop	r13
    3c64:	cf 90       	pop	r12
    3c66:	bf 90       	pop	r11
    3c68:	af 90       	pop	r10
    3c6a:	9f 90       	pop	r9
    3c6c:	8f 90       	pop	r8
    3c6e:	7f 90       	pop	r7
    3c70:	6f 90       	pop	r6
    3c72:	5f 90       	pop	r5
    3c74:	4f 90       	pop	r4
    3c76:	3f 90       	pop	r3
    3c78:	2f 90       	pop	r2
    3c7a:	1f 90       	pop	r1
    3c7c:	0f 90       	pop	r0
    3c7e:	0f be       	out	0x3f, r0	; 63
    3c80:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3c82:	08 95       	ret

00003c84 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3c84:	df 93       	push	r29
    3c86:	cf 93       	push	r28
    3c88:	00 d0       	rcall	.+0      	; 0x3c8a <prvSetupTimerInterrupt+0x6>
    3c8a:	00 d0       	rcall	.+0      	; 0x3c8c <prvSetupTimerInterrupt+0x8>
    3c8c:	00 d0       	rcall	.+0      	; 0x3c8e <prvSetupTimerInterrupt+0xa>
    3c8e:	cd b7       	in	r28, 0x3d	; 61
    3c90:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3c92:	85 e1       	ldi	r24, 0x15	; 21
    3c94:	94 e3       	ldi	r25, 0x34	; 52
    3c96:	a0 e0       	ldi	r26, 0x00	; 0
    3c98:	b0 e0       	ldi	r27, 0x00	; 0
    3c9a:	8b 83       	std	Y+3, r24	; 0x03
    3c9c:	9c 83       	std	Y+4, r25	; 0x04
    3c9e:	ad 83       	std	Y+5, r26	; 0x05
    3ca0:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ca6:	ad 81       	ldd	r26, Y+5	; 0x05
    3ca8:	be 81       	ldd	r27, Y+6	; 0x06
    3caa:	68 94       	set
    3cac:	15 f8       	bld	r1, 5
    3cae:	b6 95       	lsr	r27
    3cb0:	a7 95       	ror	r26
    3cb2:	97 95       	ror	r25
    3cb4:	87 95       	ror	r24
    3cb6:	16 94       	lsr	r1
    3cb8:	d1 f7       	brne	.-12     	; 0x3cae <prvSetupTimerInterrupt+0x2a>
    3cba:	8b 83       	std	Y+3, r24	; 0x03
    3cbc:	9c 83       	std	Y+4, r25	; 0x04
    3cbe:	ad 83       	std	Y+5, r26	; 0x05
    3cc0:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    3cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc6:	ad 81       	ldd	r26, Y+5	; 0x05
    3cc8:	be 81       	ldd	r27, Y+6	; 0x06
    3cca:	01 97       	sbiw	r24, 0x01	; 1
    3ccc:	a1 09       	sbc	r26, r1
    3cce:	b1 09       	sbc	r27, r1
    3cd0:	8b 83       	std	Y+3, r24	; 0x03
    3cd2:	9c 83       	std	Y+4, r25	; 0x04
    3cd4:	ad 83       	std	Y+5, r26	; 0x05
    3cd6:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3cd8:	8b 81       	ldd	r24, Y+3	; 0x03
    3cda:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cde:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce0:	ad 81       	ldd	r26, Y+5	; 0x05
    3ce2:	be 81       	ldd	r27, Y+6	; 0x06
    3ce4:	89 2f       	mov	r24, r25
    3ce6:	9a 2f       	mov	r25, r26
    3ce8:	ab 2f       	mov	r26, r27
    3cea:	bb 27       	eor	r27, r27
    3cec:	8b 83       	std	Y+3, r24	; 0x03
    3cee:	9c 83       	std	Y+4, r25	; 0x04
    3cf0:	ad 83       	std	Y+5, r26	; 0x05
    3cf2:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf6:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3cf8:	eb e4       	ldi	r30, 0x4B	; 75
    3cfa:	f0 e0       	ldi	r31, 0x00	; 0
    3cfc:	8a 81       	ldd	r24, Y+2	; 0x02
    3cfe:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3d00:	ea e4       	ldi	r30, 0x4A	; 74
    3d02:	f0 e0       	ldi	r31, 0x00	; 0
    3d04:	89 81       	ldd	r24, Y+1	; 0x01
    3d06:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3d08:	8b e0       	ldi	r24, 0x0B	; 11
    3d0a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3d0c:	ee e4       	ldi	r30, 0x4E	; 78
    3d0e:	f0 e0       	ldi	r31, 0x00	; 0
    3d10:	89 81       	ldd	r24, Y+1	; 0x01
    3d12:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3d14:	e9 e5       	ldi	r30, 0x59	; 89
    3d16:	f0 e0       	ldi	r31, 0x00	; 0
    3d18:	80 81       	ld	r24, Z
    3d1a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3d1c:	89 81       	ldd	r24, Y+1	; 0x01
    3d1e:	80 61       	ori	r24, 0x10	; 16
    3d20:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3d22:	e9 e5       	ldi	r30, 0x59	; 89
    3d24:	f0 e0       	ldi	r31, 0x00	; 0
    3d26:	89 81       	ldd	r24, Y+1	; 0x01
    3d28:	80 83       	st	Z, r24
}
    3d2a:	26 96       	adiw	r28, 0x06	; 6
    3d2c:	0f b6       	in	r0, 0x3f	; 63
    3d2e:	f8 94       	cli
    3d30:	de bf       	out	0x3e, r29	; 62
    3d32:	0f be       	out	0x3f, r0	; 63
    3d34:	cd bf       	out	0x3d, r28	; 61
    3d36:	cf 91       	pop	r28
    3d38:	df 91       	pop	r29
    3d3a:	08 95       	ret

00003d3c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3d3c:	0e 94 e7 1d 	call	0x3bce	; 0x3bce <vPortYieldFromTick>
		asm volatile ( "reti" );
    3d40:	18 95       	reti

00003d42 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    3d42:	df 93       	push	r29
    3d44:	cf 93       	push	r28
    3d46:	cd b7       	in	r28, 0x3d	; 61
    3d48:	de b7       	in	r29, 0x3e	; 62
    3d4a:	28 97       	sbiw	r28, 0x08	; 8
    3d4c:	0f b6       	in	r0, 0x3f	; 63
    3d4e:	f8 94       	cli
    3d50:	de bf       	out	0x3e, r29	; 62
    3d52:	0f be       	out	0x3f, r0	; 63
    3d54:	cd bf       	out	0x3d, r28	; 61
    3d56:	8f 83       	std	Y+7, r24	; 0x07
    3d58:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    3d5a:	1a 82       	std	Y+2, r1	; 0x02
    3d5c:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3d5e:	8f 81       	ldd	r24, Y+7	; 0x07
    3d60:	88 23       	and	r24, r24
    3d62:	09 f4       	brne	.+2      	; 0x3d66 <xQueueCreate+0x24>
    3d64:	8c c0       	rjmp	.+280    	; 0x3e7e <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    3d66:	8f e1       	ldi	r24, 0x1F	; 31
    3d68:	90 e0       	ldi	r25, 0x00	; 0
    3d6a:	0e 94 28 1a 	call	0x3450	; 0x3450 <pvPortMalloc>
    3d6e:	9e 83       	std	Y+6, r25	; 0x06
    3d70:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3d72:	8d 81       	ldd	r24, Y+5	; 0x05
    3d74:	9e 81       	ldd	r25, Y+6	; 0x06
    3d76:	00 97       	sbiw	r24, 0x00	; 0
    3d78:	09 f4       	brne	.+2      	; 0x3d7c <xQueueCreate+0x3a>
    3d7a:	81 c0       	rjmp	.+258    	; 0x3e7e <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3d7c:	8f 81       	ldd	r24, Y+7	; 0x07
    3d7e:	28 2f       	mov	r18, r24
    3d80:	30 e0       	ldi	r19, 0x00	; 0
    3d82:	88 85       	ldd	r24, Y+8	; 0x08
    3d84:	88 2f       	mov	r24, r24
    3d86:	90 e0       	ldi	r25, 0x00	; 0
    3d88:	ac 01       	movw	r20, r24
    3d8a:	24 9f       	mul	r18, r20
    3d8c:	c0 01       	movw	r24, r0
    3d8e:	25 9f       	mul	r18, r21
    3d90:	90 0d       	add	r25, r0
    3d92:	34 9f       	mul	r19, r20
    3d94:	90 0d       	add	r25, r0
    3d96:	11 24       	eor	r1, r1
    3d98:	01 96       	adiw	r24, 0x01	; 1
    3d9a:	9c 83       	std	Y+4, r25	; 0x04
    3d9c:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    3d9e:	8b 81       	ldd	r24, Y+3	; 0x03
    3da0:	9c 81       	ldd	r25, Y+4	; 0x04
    3da2:	0e 94 28 1a 	call	0x3450	; 0x3450 <pvPortMalloc>
    3da6:	ed 81       	ldd	r30, Y+5	; 0x05
    3da8:	fe 81       	ldd	r31, Y+6	; 0x06
    3daa:	91 83       	std	Z+1, r25	; 0x01
    3dac:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3dae:	ed 81       	ldd	r30, Y+5	; 0x05
    3db0:	fe 81       	ldd	r31, Y+6	; 0x06
    3db2:	80 81       	ld	r24, Z
    3db4:	91 81       	ldd	r25, Z+1	; 0x01
    3db6:	00 97       	sbiw	r24, 0x00	; 0
    3db8:	09 f4       	brne	.+2      	; 0x3dbc <xQueueCreate+0x7a>
    3dba:	5d c0       	rjmp	.+186    	; 0x3e76 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    3dbc:	ed 81       	ldd	r30, Y+5	; 0x05
    3dbe:	fe 81       	ldd	r31, Y+6	; 0x06
    3dc0:	40 81       	ld	r20, Z
    3dc2:	51 81       	ldd	r21, Z+1	; 0x01
    3dc4:	8f 81       	ldd	r24, Y+7	; 0x07
    3dc6:	28 2f       	mov	r18, r24
    3dc8:	30 e0       	ldi	r19, 0x00	; 0
    3dca:	88 85       	ldd	r24, Y+8	; 0x08
    3dcc:	88 2f       	mov	r24, r24
    3dce:	90 e0       	ldi	r25, 0x00	; 0
    3dd0:	bc 01       	movw	r22, r24
    3dd2:	26 9f       	mul	r18, r22
    3dd4:	c0 01       	movw	r24, r0
    3dd6:	27 9f       	mul	r18, r23
    3dd8:	90 0d       	add	r25, r0
    3dda:	36 9f       	mul	r19, r22
    3ddc:	90 0d       	add	r25, r0
    3dde:	11 24       	eor	r1, r1
    3de0:	84 0f       	add	r24, r20
    3de2:	95 1f       	adc	r25, r21
    3de4:	ed 81       	ldd	r30, Y+5	; 0x05
    3de6:	fe 81       	ldd	r31, Y+6	; 0x06
    3de8:	93 83       	std	Z+3, r25	; 0x03
    3dea:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    3dec:	ed 81       	ldd	r30, Y+5	; 0x05
    3dee:	fe 81       	ldd	r31, Y+6	; 0x06
    3df0:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    3df2:	ed 81       	ldd	r30, Y+5	; 0x05
    3df4:	fe 81       	ldd	r31, Y+6	; 0x06
    3df6:	80 81       	ld	r24, Z
    3df8:	91 81       	ldd	r25, Z+1	; 0x01
    3dfa:	ed 81       	ldd	r30, Y+5	; 0x05
    3dfc:	fe 81       	ldd	r31, Y+6	; 0x06
    3dfe:	95 83       	std	Z+5, r25	; 0x05
    3e00:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    3e02:	ed 81       	ldd	r30, Y+5	; 0x05
    3e04:	fe 81       	ldd	r31, Y+6	; 0x06
    3e06:	40 81       	ld	r20, Z
    3e08:	51 81       	ldd	r21, Z+1	; 0x01
    3e0a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e0c:	88 2f       	mov	r24, r24
    3e0e:	90 e0       	ldi	r25, 0x00	; 0
    3e10:	9c 01       	movw	r18, r24
    3e12:	21 50       	subi	r18, 0x01	; 1
    3e14:	30 40       	sbci	r19, 0x00	; 0
    3e16:	88 85       	ldd	r24, Y+8	; 0x08
    3e18:	88 2f       	mov	r24, r24
    3e1a:	90 e0       	ldi	r25, 0x00	; 0
    3e1c:	bc 01       	movw	r22, r24
    3e1e:	26 9f       	mul	r18, r22
    3e20:	c0 01       	movw	r24, r0
    3e22:	27 9f       	mul	r18, r23
    3e24:	90 0d       	add	r25, r0
    3e26:	36 9f       	mul	r19, r22
    3e28:	90 0d       	add	r25, r0
    3e2a:	11 24       	eor	r1, r1
    3e2c:	84 0f       	add	r24, r20
    3e2e:	95 1f       	adc	r25, r21
    3e30:	ed 81       	ldd	r30, Y+5	; 0x05
    3e32:	fe 81       	ldd	r31, Y+6	; 0x06
    3e34:	97 83       	std	Z+7, r25	; 0x07
    3e36:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    3e38:	ed 81       	ldd	r30, Y+5	; 0x05
    3e3a:	fe 81       	ldd	r31, Y+6	; 0x06
    3e3c:	8f 81       	ldd	r24, Y+7	; 0x07
    3e3e:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3e40:	ed 81       	ldd	r30, Y+5	; 0x05
    3e42:	fe 81       	ldd	r31, Y+6	; 0x06
    3e44:	88 85       	ldd	r24, Y+8	; 0x08
    3e46:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    3e48:	ed 81       	ldd	r30, Y+5	; 0x05
    3e4a:	fe 81       	ldd	r31, Y+6	; 0x06
    3e4c:	8f ef       	ldi	r24, 0xFF	; 255
    3e4e:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3e50:	ed 81       	ldd	r30, Y+5	; 0x05
    3e52:	fe 81       	ldd	r31, Y+6	; 0x06
    3e54:	8f ef       	ldi	r24, 0xFF	; 255
    3e56:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3e58:	8d 81       	ldd	r24, Y+5	; 0x05
    3e5a:	9e 81       	ldd	r25, Y+6	; 0x06
    3e5c:	08 96       	adiw	r24, 0x08	; 8
    3e5e:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3e62:	8d 81       	ldd	r24, Y+5	; 0x05
    3e64:	9e 81       	ldd	r25, Y+6	; 0x06
    3e66:	41 96       	adiw	r24, 0x11	; 17
    3e68:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3e6c:	8d 81       	ldd	r24, Y+5	; 0x05
    3e6e:	9e 81       	ldd	r25, Y+6	; 0x06
    3e70:	9a 83       	std	Y+2, r25	; 0x02
    3e72:	89 83       	std	Y+1, r24	; 0x01
    3e74:	04 c0       	rjmp	.+8      	; 0x3e7e <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    3e76:	8d 81       	ldd	r24, Y+5	; 0x05
    3e78:	9e 81       	ldd	r25, Y+6	; 0x06
    3e7a:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3e7e:	89 81       	ldd	r24, Y+1	; 0x01
    3e80:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3e82:	28 96       	adiw	r28, 0x08	; 8
    3e84:	0f b6       	in	r0, 0x3f	; 63
    3e86:	f8 94       	cli
    3e88:	de bf       	out	0x3e, r29	; 62
    3e8a:	0f be       	out	0x3f, r0	; 63
    3e8c:	cd bf       	out	0x3d, r28	; 61
    3e8e:	cf 91       	pop	r28
    3e90:	df 91       	pop	r29
    3e92:	08 95       	ret

00003e94 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
    3e94:	df 93       	push	r29
    3e96:	cf 93       	push	r28
    3e98:	00 d0       	rcall	.+0      	; 0x3e9a <xQueueCreateMutex+0x6>
    3e9a:	cd b7       	in	r28, 0x3d	; 61
    3e9c:	de b7       	in	r29, 0x3e	; 62
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    3e9e:	8f e1       	ldi	r24, 0x1F	; 31
    3ea0:	90 e0       	ldi	r25, 0x00	; 0
    3ea2:	0e 94 28 1a 	call	0x3450	; 0x3450 <pvPortMalloc>
    3ea6:	9a 83       	std	Y+2, r25	; 0x02
    3ea8:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    3eaa:	89 81       	ldd	r24, Y+1	; 0x01
    3eac:	9a 81       	ldd	r25, Y+2	; 0x02
    3eae:	00 97       	sbiw	r24, 0x00	; 0
    3eb0:	a9 f1       	breq	.+106    	; 0x3f1c <xQueueCreateMutex+0x88>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    3eb2:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb4:	fa 81       	ldd	r31, Y+2	; 0x02
    3eb6:	13 82       	std	Z+3, r1	; 0x03
    3eb8:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    3eba:	e9 81       	ldd	r30, Y+1	; 0x01
    3ebc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ebe:	11 82       	std	Z+1, r1	; 0x01
    3ec0:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    3ec2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ec4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ec6:	15 82       	std	Z+5, r1	; 0x05
    3ec8:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    3eca:	e9 81       	ldd	r30, Y+1	; 0x01
    3ecc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ece:	17 82       	std	Z+7, r1	; 0x07
    3ed0:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    3ed2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ed4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed6:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    3ed8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eda:	fa 81       	ldd	r31, Y+2	; 0x02
    3edc:	81 e0       	ldi	r24, 0x01	; 1
    3ede:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    3ee0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ee2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ee4:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    3ee6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ee8:	fa 81       	ldd	r31, Y+2	; 0x02
    3eea:	8f ef       	ldi	r24, 0xFF	; 255
    3eec:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    3eee:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef2:	8f ef       	ldi	r24, 0xFF	; 255
    3ef4:	86 8f       	std	Z+30, r24	; 0x1e

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3ef6:	89 81       	ldd	r24, Y+1	; 0x01
    3ef8:	9a 81       	ldd	r25, Y+2	; 0x02
    3efa:	08 96       	adiw	r24, 0x08	; 8
    3efc:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3f00:	89 81       	ldd	r24, Y+1	; 0x01
    3f02:	9a 81       	ldd	r25, Y+2	; 0x02
    3f04:	41 96       	adiw	r24, 0x11	; 17
    3f06:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    3f0a:	89 81       	ldd	r24, Y+1	; 0x01
    3f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f0e:	60 e0       	ldi	r22, 0x00	; 0
    3f10:	70 e0       	ldi	r23, 0x00	; 0
    3f12:	40 e0       	ldi	r20, 0x00	; 0
    3f14:	50 e0       	ldi	r21, 0x00	; 0
    3f16:	20 e0       	ldi	r18, 0x00	; 0
    3f18:	0e 94 30 20 	call	0x4060	; 0x4060 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    3f1c:	89 81       	ldd	r24, Y+1	; 0x01
    3f1e:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3f20:	0f 90       	pop	r0
    3f22:	0f 90       	pop	r0
    3f24:	cf 91       	pop	r28
    3f26:	df 91       	pop	r29
    3f28:	08 95       	ret

00003f2a <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if configUSE_RECURSIVE_MUTEXES == 1

	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
	{
    3f2a:	0f 93       	push	r16
    3f2c:	1f 93       	push	r17
    3f2e:	df 93       	push	r29
    3f30:	cf 93       	push	r28
    3f32:	00 d0       	rcall	.+0      	; 0x3f34 <xQueueGiveMutexRecursive+0xa>
    3f34:	0f 92       	push	r0
    3f36:	cd b7       	in	r28, 0x3d	; 61
    3f38:	de b7       	in	r29, 0x3e	; 62
    3f3a:	9b 83       	std	Y+3, r25	; 0x03
    3f3c:	8a 83       	std	Y+2, r24	; 0x02
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
    3f3e:	ea 81       	ldd	r30, Y+2	; 0x02
    3f40:	fb 81       	ldd	r31, Y+3	; 0x03
    3f42:	02 81       	ldd	r16, Z+2	; 0x02
    3f44:	13 81       	ldd	r17, Z+3	; 0x03
    3f46:	0e 94 25 2b 	call	0x564a	; 0x564a <xTaskGetCurrentTaskHandle>
    3f4a:	08 17       	cp	r16, r24
    3f4c:	19 07       	cpc	r17, r25
    3f4e:	d9 f4       	brne	.+54     	; 0x3f86 <xQueueGiveMutexRecursive+0x5c>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->uxRecursiveCallCount )--;
    3f50:	ea 81       	ldd	r30, Y+2	; 0x02
    3f52:	fb 81       	ldd	r31, Y+3	; 0x03
    3f54:	86 81       	ldd	r24, Z+6	; 0x06
    3f56:	97 81       	ldd	r25, Z+7	; 0x07
    3f58:	01 97       	sbiw	r24, 0x01	; 1
    3f5a:	ea 81       	ldd	r30, Y+2	; 0x02
    3f5c:	fb 81       	ldd	r31, Y+3	; 0x03
    3f5e:	97 83       	std	Z+7, r25	; 0x07
    3f60:	86 83       	std	Z+6, r24	; 0x06

			/* Have we unwound the call count? */
			if( pxMutex->uxRecursiveCallCount == 0 )
    3f62:	ea 81       	ldd	r30, Y+2	; 0x02
    3f64:	fb 81       	ldd	r31, Y+3	; 0x03
    3f66:	86 81       	ldd	r24, Z+6	; 0x06
    3f68:	97 81       	ldd	r25, Z+7	; 0x07
    3f6a:	00 97       	sbiw	r24, 0x00	; 0
    3f6c:	49 f4       	brne	.+18     	; 0x3f80 <xQueueGiveMutexRecursive+0x56>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    3f6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f70:	9b 81       	ldd	r25, Y+3	; 0x03
    3f72:	60 e0       	ldi	r22, 0x00	; 0
    3f74:	70 e0       	ldi	r23, 0x00	; 0
    3f76:	40 e0       	ldi	r20, 0x00	; 0
    3f78:	50 e0       	ldi	r21, 0x00	; 0
    3f7a:	20 e0       	ldi	r18, 0x00	; 0
    3f7c:	0e 94 30 20 	call	0x4060	; 0x4060 <xQueueGenericSend>
			}

			xReturn = pdPASS;
    3f80:	81 e0       	ldi	r24, 0x01	; 1
    3f82:	89 83       	std	Y+1, r24	; 0x01
    3f84:	01 c0       	rjmp	.+2      	; 0x3f88 <xQueueGiveMutexRecursive+0x5e>
		}
		else
		{
			/* We cannot give the mutex because we are not the holder. */
			xReturn = pdFAIL;
    3f86:	19 82       	std	Y+1, r1	; 0x01

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    3f88:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3f8a:	0f 90       	pop	r0
    3f8c:	0f 90       	pop	r0
    3f8e:	0f 90       	pop	r0
    3f90:	cf 91       	pop	r28
    3f92:	df 91       	pop	r29
    3f94:	1f 91       	pop	r17
    3f96:	0f 91       	pop	r16
    3f98:	08 95       	ret

00003f9a <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if configUSE_RECURSIVE_MUTEXES == 1

	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
	{
    3f9a:	0f 93       	push	r16
    3f9c:	1f 93       	push	r17
    3f9e:	df 93       	push	r29
    3fa0:	cf 93       	push	r28
    3fa2:	00 d0       	rcall	.+0      	; 0x3fa4 <xQueueTakeMutexRecursive+0xa>
    3fa4:	00 d0       	rcall	.+0      	; 0x3fa6 <xQueueTakeMutexRecursive+0xc>
    3fa6:	0f 92       	push	r0
    3fa8:	cd b7       	in	r28, 0x3d	; 61
    3faa:	de b7       	in	r29, 0x3e	; 62
    3fac:	9b 83       	std	Y+3, r25	; 0x03
    3fae:	8a 83       	std	Y+2, r24	; 0x02
    3fb0:	7d 83       	std	Y+5, r23	; 0x05
    3fb2:	6c 83       	std	Y+4, r22	; 0x04
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
    3fb4:	ea 81       	ldd	r30, Y+2	; 0x02
    3fb6:	fb 81       	ldd	r31, Y+3	; 0x03
    3fb8:	02 81       	ldd	r16, Z+2	; 0x02
    3fba:	13 81       	ldd	r17, Z+3	; 0x03
    3fbc:	0e 94 25 2b 	call	0x564a	; 0x564a <xTaskGetCurrentTaskHandle>
    3fc0:	08 17       	cp	r16, r24
    3fc2:	19 07       	cpc	r17, r25
    3fc4:	61 f4       	brne	.+24     	; 0x3fde <xQueueTakeMutexRecursive+0x44>
		{
			( pxMutex->uxRecursiveCallCount )++;
    3fc6:	ea 81       	ldd	r30, Y+2	; 0x02
    3fc8:	fb 81       	ldd	r31, Y+3	; 0x03
    3fca:	86 81       	ldd	r24, Z+6	; 0x06
    3fcc:	97 81       	ldd	r25, Z+7	; 0x07
    3fce:	01 96       	adiw	r24, 0x01	; 1
    3fd0:	ea 81       	ldd	r30, Y+2	; 0x02
    3fd2:	fb 81       	ldd	r31, Y+3	; 0x03
    3fd4:	97 83       	std	Z+7, r25	; 0x07
    3fd6:	86 83       	std	Z+6, r24	; 0x06
			xReturn = pdPASS;
    3fd8:	81 e0       	ldi	r24, 0x01	; 1
    3fda:	89 83       	std	Y+1, r24	; 0x01
    3fdc:	17 c0       	rjmp	.+46     	; 0x400c <xQueueTakeMutexRecursive+0x72>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
    3fde:	8a 81       	ldd	r24, Y+2	; 0x02
    3fe0:	9b 81       	ldd	r25, Y+3	; 0x03
    3fe2:	2c 81       	ldd	r18, Y+4	; 0x04
    3fe4:	3d 81       	ldd	r19, Y+5	; 0x05
    3fe6:	60 e0       	ldi	r22, 0x00	; 0
    3fe8:	70 e0       	ldi	r23, 0x00	; 0
    3fea:	a9 01       	movw	r20, r18
    3fec:	20 e0       	ldi	r18, 0x00	; 0
    3fee:	0e 94 1b 21 	call	0x4236	; 0x4236 <xQueueGenericReceive>
    3ff2:	89 83       	std	Y+1, r24	; 0x01

			/* pdPASS will only be returned if we successfully obtained the mutex,
			we may have blocked to reach here. */
			if( xReturn == pdPASS )
    3ff4:	89 81       	ldd	r24, Y+1	; 0x01
    3ff6:	81 30       	cpi	r24, 0x01	; 1
    3ff8:	49 f4       	brne	.+18     	; 0x400c <xQueueTakeMutexRecursive+0x72>
			{
				( pxMutex->uxRecursiveCallCount )++;
    3ffa:	ea 81       	ldd	r30, Y+2	; 0x02
    3ffc:	fb 81       	ldd	r31, Y+3	; 0x03
    3ffe:	86 81       	ldd	r24, Z+6	; 0x06
    4000:	97 81       	ldd	r25, Z+7	; 0x07
    4002:	01 96       	adiw	r24, 0x01	; 1
    4004:	ea 81       	ldd	r30, Y+2	; 0x02
    4006:	fb 81       	ldd	r31, Y+3	; 0x03
    4008:	97 83       	std	Z+7, r25	; 0x07
    400a:	86 83       	std	Z+6, r24	; 0x06
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    400c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    400e:	0f 90       	pop	r0
    4010:	0f 90       	pop	r0
    4012:	0f 90       	pop	r0
    4014:	0f 90       	pop	r0
    4016:	0f 90       	pop	r0
    4018:	cf 91       	pop	r28
    401a:	df 91       	pop	r29
    401c:	1f 91       	pop	r17
    401e:	0f 91       	pop	r16
    4020:	08 95       	ret

00004022 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    4022:	df 93       	push	r29
    4024:	cf 93       	push	r28
    4026:	00 d0       	rcall	.+0      	; 0x4028 <xQueueCreateCountingSemaphore+0x6>
    4028:	00 d0       	rcall	.+0      	; 0x402a <xQueueCreateCountingSemaphore+0x8>
    402a:	cd b7       	in	r28, 0x3d	; 61
    402c:	de b7       	in	r29, 0x3e	; 62
    402e:	8b 83       	std	Y+3, r24	; 0x03
    4030:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    4032:	8b 81       	ldd	r24, Y+3	; 0x03
    4034:	60 e0       	ldi	r22, 0x00	; 0
    4036:	0e 94 a1 1e 	call	0x3d42	; 0x3d42 <xQueueCreate>
    403a:	9a 83       	std	Y+2, r25	; 0x02
    403c:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    403e:	89 81       	ldd	r24, Y+1	; 0x01
    4040:	9a 81       	ldd	r25, Y+2	; 0x02
    4042:	00 97       	sbiw	r24, 0x00	; 0
    4044:	21 f0       	breq	.+8      	; 0x404e <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    4046:	e9 81       	ldd	r30, Y+1	; 0x01
    4048:	fa 81       	ldd	r31, Y+2	; 0x02
    404a:	8c 81       	ldd	r24, Y+4	; 0x04
    404c:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    404e:	89 81       	ldd	r24, Y+1	; 0x01
    4050:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4052:	0f 90       	pop	r0
    4054:	0f 90       	pop	r0
    4056:	0f 90       	pop	r0
    4058:	0f 90       	pop	r0
    405a:	cf 91       	pop	r28
    405c:	df 91       	pop	r29
    405e:	08 95       	ret

00004060 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    4060:	df 93       	push	r29
    4062:	cf 93       	push	r28
    4064:	cd b7       	in	r28, 0x3d	; 61
    4066:	de b7       	in	r29, 0x3e	; 62
    4068:	2c 97       	sbiw	r28, 0x0c	; 12
    406a:	0f b6       	in	r0, 0x3f	; 63
    406c:	f8 94       	cli
    406e:	de bf       	out	0x3e, r29	; 62
    4070:	0f be       	out	0x3f, r0	; 63
    4072:	cd bf       	out	0x3d, r28	; 61
    4074:	9e 83       	std	Y+6, r25	; 0x06
    4076:	8d 83       	std	Y+5, r24	; 0x05
    4078:	78 87       	std	Y+8, r23	; 0x08
    407a:	6f 83       	std	Y+7, r22	; 0x07
    407c:	5a 87       	std	Y+10, r21	; 0x0a
    407e:	49 87       	std	Y+9, r20	; 0x09
    4080:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4082:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    4084:	0f b6       	in	r0, 0x3f	; 63
    4086:	f8 94       	cli
    4088:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    408a:	ed 81       	ldd	r30, Y+5	; 0x05
    408c:	fe 81       	ldd	r31, Y+6	; 0x06
    408e:	92 8d       	ldd	r25, Z+26	; 0x1a
    4090:	ed 81       	ldd	r30, Y+5	; 0x05
    4092:	fe 81       	ldd	r31, Y+6	; 0x06
    4094:	83 8d       	ldd	r24, Z+27	; 0x1b
    4096:	98 17       	cp	r25, r24
    4098:	d8 f4       	brcc	.+54     	; 0x40d0 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    409a:	8d 81       	ldd	r24, Y+5	; 0x05
    409c:	9e 81       	ldd	r25, Y+6	; 0x06
    409e:	2f 81       	ldd	r18, Y+7	; 0x07
    40a0:	38 85       	ldd	r19, Y+8	; 0x08
    40a2:	b9 01       	movw	r22, r18
    40a4:	4b 85       	ldd	r20, Y+11	; 0x0b
    40a6:	0e 94 88 22 	call	0x4510	; 0x4510 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    40aa:	ed 81       	ldd	r30, Y+5	; 0x05
    40ac:	fe 81       	ldd	r31, Y+6	; 0x06
    40ae:	81 89       	ldd	r24, Z+17	; 0x11
    40b0:	88 23       	and	r24, r24
    40b2:	49 f0       	breq	.+18     	; 0x40c6 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    40b4:	8d 81       	ldd	r24, Y+5	; 0x05
    40b6:	9e 81       	ldd	r25, Y+6	; 0x06
    40b8:	41 96       	adiw	r24, 0x11	; 17
    40ba:	0e 94 ae 28 	call	0x515c	; 0x515c <xTaskRemoveFromEventList>
    40be:	81 30       	cpi	r24, 0x01	; 1
    40c0:	11 f4       	brne	.+4      	; 0x40c6 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    40c2:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    40c6:	0f 90       	pop	r0
    40c8:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    40ca:	81 e0       	ldi	r24, 0x01	; 1
    40cc:	8c 87       	std	Y+12, r24	; 0x0c
    40ce:	5c c0       	rjmp	.+184    	; 0x4188 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    40d0:	89 85       	ldd	r24, Y+9	; 0x09
    40d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    40d4:	00 97       	sbiw	r24, 0x00	; 0
    40d6:	21 f4       	brne	.+8      	; 0x40e0 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    40d8:	0f 90       	pop	r0
    40da:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    40dc:	1c 86       	std	Y+12, r1	; 0x0c
    40de:	54 c0       	rjmp	.+168    	; 0x4188 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    40e0:	89 81       	ldd	r24, Y+1	; 0x01
    40e2:	88 23       	and	r24, r24
    40e4:	31 f4       	brne	.+12     	; 0x40f2 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    40e6:	ce 01       	movw	r24, r28
    40e8:	02 96       	adiw	r24, 0x02	; 2
    40ea:	0e 94 16 29 	call	0x522c	; 0x522c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    40ee:	81 e0       	ldi	r24, 0x01	; 1
    40f0:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    40f2:	0f 90       	pop	r0
    40f4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    40f6:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    40fa:	0f b6       	in	r0, 0x3f	; 63
    40fc:	f8 94       	cli
    40fe:	0f 92       	push	r0
    4100:	ed 81       	ldd	r30, Y+5	; 0x05
    4102:	fe 81       	ldd	r31, Y+6	; 0x06
    4104:	85 8d       	ldd	r24, Z+29	; 0x1d
    4106:	8f 3f       	cpi	r24, 0xFF	; 255
    4108:	19 f4       	brne	.+6      	; 0x4110 <xQueueGenericSend+0xb0>
    410a:	ed 81       	ldd	r30, Y+5	; 0x05
    410c:	fe 81       	ldd	r31, Y+6	; 0x06
    410e:	15 8e       	std	Z+29, r1	; 0x1d
    4110:	ed 81       	ldd	r30, Y+5	; 0x05
    4112:	fe 81       	ldd	r31, Y+6	; 0x06
    4114:	86 8d       	ldd	r24, Z+30	; 0x1e
    4116:	8f 3f       	cpi	r24, 0xFF	; 255
    4118:	19 f4       	brne	.+6      	; 0x4120 <xQueueGenericSend+0xc0>
    411a:	ed 81       	ldd	r30, Y+5	; 0x05
    411c:	fe 81       	ldd	r31, Y+6	; 0x06
    411e:	16 8e       	std	Z+30, r1	; 0x1e
    4120:	0f 90       	pop	r0
    4122:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4124:	ce 01       	movw	r24, r28
    4126:	02 96       	adiw	r24, 0x02	; 2
    4128:	9e 01       	movw	r18, r28
    412a:	27 5f       	subi	r18, 0xF7	; 247
    412c:	3f 4f       	sbci	r19, 0xFF	; 255
    412e:	b9 01       	movw	r22, r18
    4130:	0e 94 2f 29 	call	0x525e	; 0x525e <xTaskCheckForTimeOut>
    4134:	88 23       	and	r24, r24
    4136:	09 f5       	brne	.+66     	; 0x417a <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4138:	8d 81       	ldd	r24, Y+5	; 0x05
    413a:	9e 81       	ldd	r25, Y+6	; 0x06
    413c:	0e 94 fd 23 	call	0x47fa	; 0x47fa <prvIsQueueFull>
    4140:	88 23       	and	r24, r24
    4142:	a1 f0       	breq	.+40     	; 0x416c <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4144:	8d 81       	ldd	r24, Y+5	; 0x05
    4146:	9e 81       	ldd	r25, Y+6	; 0x06
    4148:	08 96       	adiw	r24, 0x08	; 8
    414a:	29 85       	ldd	r18, Y+9	; 0x09
    414c:	3a 85       	ldd	r19, Y+10	; 0x0a
    414e:	b9 01       	movw	r22, r18
    4150:	0e 94 78 28 	call	0x50f0	; 0x50f0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    4154:	8d 81       	ldd	r24, Y+5	; 0x05
    4156:	9e 81       	ldd	r25, Y+6	; 0x06
    4158:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    415c:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>
    4160:	88 23       	and	r24, r24
    4162:	09 f0       	breq	.+2      	; 0x4166 <xQueueGenericSend+0x106>
    4164:	8f cf       	rjmp	.-226    	; 0x4084 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    4166:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
    416a:	8c cf       	rjmp	.-232    	; 0x4084 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    416c:	8d 81       	ldd	r24, Y+5	; 0x05
    416e:	9e 81       	ldd	r25, Y+6	; 0x06
    4170:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4174:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>
    4178:	85 cf       	rjmp	.-246    	; 0x4084 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    417a:	8d 81       	ldd	r24, Y+5	; 0x05
    417c:	9e 81       	ldd	r25, Y+6	; 0x06
    417e:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4182:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4186:	1c 86       	std	Y+12, r1	; 0x0c
    4188:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    418a:	2c 96       	adiw	r28, 0x0c	; 12
    418c:	0f b6       	in	r0, 0x3f	; 63
    418e:	f8 94       	cli
    4190:	de bf       	out	0x3e, r29	; 62
    4192:	0f be       	out	0x3f, r0	; 63
    4194:	cd bf       	out	0x3d, r28	; 61
    4196:	cf 91       	pop	r28
    4198:	df 91       	pop	r29
    419a:	08 95       	ret

0000419c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    419c:	df 93       	push	r29
    419e:	cf 93       	push	r28
    41a0:	cd b7       	in	r28, 0x3d	; 61
    41a2:	de b7       	in	r29, 0x3e	; 62
    41a4:	29 97       	sbiw	r28, 0x09	; 9
    41a6:	0f b6       	in	r0, 0x3f	; 63
    41a8:	f8 94       	cli
    41aa:	de bf       	out	0x3e, r29	; 62
    41ac:	0f be       	out	0x3f, r0	; 63
    41ae:	cd bf       	out	0x3d, r28	; 61
    41b0:	9c 83       	std	Y+4, r25	; 0x04
    41b2:	8b 83       	std	Y+3, r24	; 0x03
    41b4:	7e 83       	std	Y+6, r23	; 0x06
    41b6:	6d 83       	std	Y+5, r22	; 0x05
    41b8:	58 87       	std	Y+8, r21	; 0x08
    41ba:	4f 83       	std	Y+7, r20	; 0x07
    41bc:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    41be:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    41c0:	eb 81       	ldd	r30, Y+3	; 0x03
    41c2:	fc 81       	ldd	r31, Y+4	; 0x04
    41c4:	92 8d       	ldd	r25, Z+26	; 0x1a
    41c6:	eb 81       	ldd	r30, Y+3	; 0x03
    41c8:	fc 81       	ldd	r31, Y+4	; 0x04
    41ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    41cc:	98 17       	cp	r25, r24
    41ce:	40 f5       	brcc	.+80     	; 0x4220 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    41d0:	8b 81       	ldd	r24, Y+3	; 0x03
    41d2:	9c 81       	ldd	r25, Y+4	; 0x04
    41d4:	2d 81       	ldd	r18, Y+5	; 0x05
    41d6:	3e 81       	ldd	r19, Y+6	; 0x06
    41d8:	b9 01       	movw	r22, r18
    41da:	49 85       	ldd	r20, Y+9	; 0x09
    41dc:	0e 94 88 22 	call	0x4510	; 0x4510 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    41e0:	eb 81       	ldd	r30, Y+3	; 0x03
    41e2:	fc 81       	ldd	r31, Y+4	; 0x04
    41e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    41e6:	8f 3f       	cpi	r24, 0xFF	; 255
    41e8:	89 f4       	brne	.+34     	; 0x420c <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    41ea:	eb 81       	ldd	r30, Y+3	; 0x03
    41ec:	fc 81       	ldd	r31, Y+4	; 0x04
    41ee:	81 89       	ldd	r24, Z+17	; 0x11
    41f0:	88 23       	and	r24, r24
    41f2:	99 f0       	breq	.+38     	; 0x421a <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    41f4:	8b 81       	ldd	r24, Y+3	; 0x03
    41f6:	9c 81       	ldd	r25, Y+4	; 0x04
    41f8:	41 96       	adiw	r24, 0x11	; 17
    41fa:	0e 94 ae 28 	call	0x515c	; 0x515c <xTaskRemoveFromEventList>
    41fe:	88 23       	and	r24, r24
    4200:	61 f0       	breq	.+24     	; 0x421a <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    4202:	ef 81       	ldd	r30, Y+7	; 0x07
    4204:	f8 85       	ldd	r31, Y+8	; 0x08
    4206:	81 e0       	ldi	r24, 0x01	; 1
    4208:	80 83       	st	Z, r24
    420a:	07 c0       	rjmp	.+14     	; 0x421a <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    420c:	eb 81       	ldd	r30, Y+3	; 0x03
    420e:	fc 81       	ldd	r31, Y+4	; 0x04
    4210:	86 8d       	ldd	r24, Z+30	; 0x1e
    4212:	8f 5f       	subi	r24, 0xFF	; 255
    4214:	eb 81       	ldd	r30, Y+3	; 0x03
    4216:	fc 81       	ldd	r31, Y+4	; 0x04
    4218:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    421a:	81 e0       	ldi	r24, 0x01	; 1
    421c:	8a 83       	std	Y+2, r24	; 0x02
    421e:	01 c0       	rjmp	.+2      	; 0x4222 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    4220:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4222:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4224:	29 96       	adiw	r28, 0x09	; 9
    4226:	0f b6       	in	r0, 0x3f	; 63
    4228:	f8 94       	cli
    422a:	de bf       	out	0x3e, r29	; 62
    422c:	0f be       	out	0x3f, r0	; 63
    422e:	cd bf       	out	0x3d, r28	; 61
    4230:	cf 91       	pop	r28
    4232:	df 91       	pop	r29
    4234:	08 95       	ret

00004236 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    4236:	df 93       	push	r29
    4238:	cf 93       	push	r28
    423a:	cd b7       	in	r28, 0x3d	; 61
    423c:	de b7       	in	r29, 0x3e	; 62
    423e:	2e 97       	sbiw	r28, 0x0e	; 14
    4240:	0f b6       	in	r0, 0x3f	; 63
    4242:	f8 94       	cli
    4244:	de bf       	out	0x3e, r29	; 62
    4246:	0f be       	out	0x3f, r0	; 63
    4248:	cd bf       	out	0x3d, r28	; 61
    424a:	98 87       	std	Y+8, r25	; 0x08
    424c:	8f 83       	std	Y+7, r24	; 0x07
    424e:	7a 87       	std	Y+10, r23	; 0x0a
    4250:	69 87       	std	Y+9, r22	; 0x09
    4252:	5c 87       	std	Y+12, r21	; 0x0c
    4254:	4b 87       	std	Y+11, r20	; 0x0b
    4256:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4258:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    425a:	0f b6       	in	r0, 0x3f	; 63
    425c:	f8 94       	cli
    425e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    4260:	ef 81       	ldd	r30, Y+7	; 0x07
    4262:	f8 85       	ldd	r31, Y+8	; 0x08
    4264:	82 8d       	ldd	r24, Z+26	; 0x1a
    4266:	88 23       	and	r24, r24
    4268:	09 f4       	brne	.+2      	; 0x426c <xQueueGenericReceive+0x36>
    426a:	4b c0       	rjmp	.+150    	; 0x4302 <xQueueGenericReceive+0xcc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    426c:	ef 81       	ldd	r30, Y+7	; 0x07
    426e:	f8 85       	ldd	r31, Y+8	; 0x08
    4270:	86 81       	ldd	r24, Z+6	; 0x06
    4272:	97 81       	ldd	r25, Z+7	; 0x07
    4274:	9a 83       	std	Y+2, r25	; 0x02
    4276:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    4278:	8f 81       	ldd	r24, Y+7	; 0x07
    427a:	98 85       	ldd	r25, Y+8	; 0x08
    427c:	29 85       	ldd	r18, Y+9	; 0x09
    427e:	3a 85       	ldd	r19, Y+10	; 0x0a
    4280:	b9 01       	movw	r22, r18
    4282:	0e 94 2e 23 	call	0x465c	; 0x465c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    4286:	8d 85       	ldd	r24, Y+13	; 0x0d
    4288:	88 23       	and	r24, r24
    428a:	11 f5       	brne	.+68     	; 0x42d0 <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    428c:	ef 81       	ldd	r30, Y+7	; 0x07
    428e:	f8 85       	ldd	r31, Y+8	; 0x08
    4290:	82 8d       	ldd	r24, Z+26	; 0x1a
    4292:	81 50       	subi	r24, 0x01	; 1
    4294:	ef 81       	ldd	r30, Y+7	; 0x07
    4296:	f8 85       	ldd	r31, Y+8	; 0x08
    4298:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    429a:	ef 81       	ldd	r30, Y+7	; 0x07
    429c:	f8 85       	ldd	r31, Y+8	; 0x08
    429e:	80 81       	ld	r24, Z
    42a0:	91 81       	ldd	r25, Z+1	; 0x01
    42a2:	00 97       	sbiw	r24, 0x00	; 0
    42a4:	31 f4       	brne	.+12     	; 0x42b2 <xQueueGenericReceive+0x7c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    42a6:	0e 94 25 2b 	call	0x564a	; 0x564a <xTaskGetCurrentTaskHandle>
    42aa:	ef 81       	ldd	r30, Y+7	; 0x07
    42ac:	f8 85       	ldd	r31, Y+8	; 0x08
    42ae:	93 83       	std	Z+3, r25	; 0x03
    42b0:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    42b2:	ef 81       	ldd	r30, Y+7	; 0x07
    42b4:	f8 85       	ldd	r31, Y+8	; 0x08
    42b6:	80 85       	ldd	r24, Z+8	; 0x08
    42b8:	88 23       	and	r24, r24
    42ba:	f1 f0       	breq	.+60     	; 0x42f8 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    42bc:	8f 81       	ldd	r24, Y+7	; 0x07
    42be:	98 85       	ldd	r25, Y+8	; 0x08
    42c0:	08 96       	adiw	r24, 0x08	; 8
    42c2:	0e 94 ae 28 	call	0x515c	; 0x515c <xTaskRemoveFromEventList>
    42c6:	81 30       	cpi	r24, 0x01	; 1
    42c8:	b9 f4       	brne	.+46     	; 0x42f8 <xQueueGenericReceive+0xc2>
						{
							portYIELD_WITHIN_API();
    42ca:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
    42ce:	14 c0       	rjmp	.+40     	; 0x42f8 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    42d0:	ef 81       	ldd	r30, Y+7	; 0x07
    42d2:	f8 85       	ldd	r31, Y+8	; 0x08
    42d4:	89 81       	ldd	r24, Y+1	; 0x01
    42d6:	9a 81       	ldd	r25, Y+2	; 0x02
    42d8:	97 83       	std	Z+7, r25	; 0x07
    42da:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    42dc:	ef 81       	ldd	r30, Y+7	; 0x07
    42de:	f8 85       	ldd	r31, Y+8	; 0x08
    42e0:	81 89       	ldd	r24, Z+17	; 0x11
    42e2:	88 23       	and	r24, r24
    42e4:	49 f0       	breq	.+18     	; 0x42f8 <xQueueGenericReceive+0xc2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    42e6:	8f 81       	ldd	r24, Y+7	; 0x07
    42e8:	98 85       	ldd	r25, Y+8	; 0x08
    42ea:	41 96       	adiw	r24, 0x11	; 17
    42ec:	0e 94 ae 28 	call	0x515c	; 0x515c <xTaskRemoveFromEventList>
    42f0:	88 23       	and	r24, r24
    42f2:	11 f0       	breq	.+4      	; 0x42f8 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    42f4:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    42f8:	0f 90       	pop	r0
    42fa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    42fc:	81 e0       	ldi	r24, 0x01	; 1
    42fe:	8e 87       	std	Y+14, r24	; 0x0e
    4300:	6d c0       	rjmp	.+218    	; 0x43dc <xQueueGenericReceive+0x1a6>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    4302:	8b 85       	ldd	r24, Y+11	; 0x0b
    4304:	9c 85       	ldd	r25, Y+12	; 0x0c
    4306:	00 97       	sbiw	r24, 0x00	; 0
    4308:	21 f4       	brne	.+8      	; 0x4312 <xQueueGenericReceive+0xdc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    430a:	0f 90       	pop	r0
    430c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    430e:	1e 86       	std	Y+14, r1	; 0x0e
    4310:	65 c0       	rjmp	.+202    	; 0x43dc <xQueueGenericReceive+0x1a6>
				}
				else if( xEntryTimeSet == pdFALSE )
    4312:	8b 81       	ldd	r24, Y+3	; 0x03
    4314:	88 23       	and	r24, r24
    4316:	31 f4       	brne	.+12     	; 0x4324 <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4318:	ce 01       	movw	r24, r28
    431a:	04 96       	adiw	r24, 0x04	; 4
    431c:	0e 94 16 29 	call	0x522c	; 0x522c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4320:	81 e0       	ldi	r24, 0x01	; 1
    4322:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    4324:	0f 90       	pop	r0
    4326:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4328:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    432c:	0f b6       	in	r0, 0x3f	; 63
    432e:	f8 94       	cli
    4330:	0f 92       	push	r0
    4332:	ef 81       	ldd	r30, Y+7	; 0x07
    4334:	f8 85       	ldd	r31, Y+8	; 0x08
    4336:	85 8d       	ldd	r24, Z+29	; 0x1d
    4338:	8f 3f       	cpi	r24, 0xFF	; 255
    433a:	19 f4       	brne	.+6      	; 0x4342 <xQueueGenericReceive+0x10c>
    433c:	ef 81       	ldd	r30, Y+7	; 0x07
    433e:	f8 85       	ldd	r31, Y+8	; 0x08
    4340:	15 8e       	std	Z+29, r1	; 0x1d
    4342:	ef 81       	ldd	r30, Y+7	; 0x07
    4344:	f8 85       	ldd	r31, Y+8	; 0x08
    4346:	86 8d       	ldd	r24, Z+30	; 0x1e
    4348:	8f 3f       	cpi	r24, 0xFF	; 255
    434a:	19 f4       	brne	.+6      	; 0x4352 <xQueueGenericReceive+0x11c>
    434c:	ef 81       	ldd	r30, Y+7	; 0x07
    434e:	f8 85       	ldd	r31, Y+8	; 0x08
    4350:	16 8e       	std	Z+30, r1	; 0x1e
    4352:	0f 90       	pop	r0
    4354:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4356:	ce 01       	movw	r24, r28
    4358:	04 96       	adiw	r24, 0x04	; 4
    435a:	9e 01       	movw	r18, r28
    435c:	25 5f       	subi	r18, 0xF5	; 245
    435e:	3f 4f       	sbci	r19, 0xFF	; 255
    4360:	b9 01       	movw	r22, r18
    4362:	0e 94 2f 29 	call	0x525e	; 0x525e <xTaskCheckForTimeOut>
    4366:	88 23       	and	r24, r24
    4368:	91 f5       	brne	.+100    	; 0x43ce <xQueueGenericReceive+0x198>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    436a:	8f 81       	ldd	r24, Y+7	; 0x07
    436c:	98 85       	ldd	r25, Y+8	; 0x08
    436e:	0e 94 ca 23 	call	0x4794	; 0x4794 <prvIsQueueEmpty>
    4372:	88 23       	and	r24, r24
    4374:	29 f1       	breq	.+74     	; 0x43c0 <xQueueGenericReceive+0x18a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4376:	ef 81       	ldd	r30, Y+7	; 0x07
    4378:	f8 85       	ldd	r31, Y+8	; 0x08
    437a:	80 81       	ld	r24, Z
    437c:	91 81       	ldd	r25, Z+1	; 0x01
    437e:	00 97       	sbiw	r24, 0x00	; 0
    4380:	59 f4       	brne	.+22     	; 0x4398 <xQueueGenericReceive+0x162>
					{
						portENTER_CRITICAL();
    4382:	0f b6       	in	r0, 0x3f	; 63
    4384:	f8 94       	cli
    4386:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    4388:	ef 81       	ldd	r30, Y+7	; 0x07
    438a:	f8 85       	ldd	r31, Y+8	; 0x08
    438c:	82 81       	ldd	r24, Z+2	; 0x02
    438e:	93 81       	ldd	r25, Z+3	; 0x03
    4390:	0e 94 37 2b 	call	0x566e	; 0x566e <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    4394:	0f 90       	pop	r0
    4396:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4398:	8f 81       	ldd	r24, Y+7	; 0x07
    439a:	98 85       	ldd	r25, Y+8	; 0x08
    439c:	41 96       	adiw	r24, 0x11	; 17
    439e:	2b 85       	ldd	r18, Y+11	; 0x0b
    43a0:	3c 85       	ldd	r19, Y+12	; 0x0c
    43a2:	b9 01       	movw	r22, r18
    43a4:	0e 94 78 28 	call	0x50f0	; 0x50f0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    43a8:	8f 81       	ldd	r24, Y+7	; 0x07
    43aa:	98 85       	ldd	r25, Y+8	; 0x08
    43ac:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    43b0:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>
    43b4:	88 23       	and	r24, r24
    43b6:	09 f0       	breq	.+2      	; 0x43ba <xQueueGenericReceive+0x184>
    43b8:	50 cf       	rjmp	.-352    	; 0x425a <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    43ba:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
    43be:	4d cf       	rjmp	.-358    	; 0x425a <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    43c0:	8f 81       	ldd	r24, Y+7	; 0x07
    43c2:	98 85       	ldd	r25, Y+8	; 0x08
    43c4:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvUnlockQueue>
				( void ) xTaskResumeAll();
    43c8:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>
    43cc:	46 cf       	rjmp	.-372    	; 0x425a <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    43ce:	8f 81       	ldd	r24, Y+7	; 0x07
    43d0:	98 85       	ldd	r25, Y+8	; 0x08
    43d2:	0e 94 76 23 	call	0x46ec	; 0x46ec <prvUnlockQueue>
			( void ) xTaskResumeAll();
    43d6:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    43da:	1e 86       	std	Y+14, r1	; 0x0e
    43dc:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    43de:	2e 96       	adiw	r28, 0x0e	; 14
    43e0:	0f b6       	in	r0, 0x3f	; 63
    43e2:	f8 94       	cli
    43e4:	de bf       	out	0x3e, r29	; 62
    43e6:	0f be       	out	0x3f, r0	; 63
    43e8:	cd bf       	out	0x3d, r28	; 61
    43ea:	cf 91       	pop	r28
    43ec:	df 91       	pop	r29
    43ee:	08 95       	ret

000043f0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    43f0:	df 93       	push	r29
    43f2:	cf 93       	push	r28
    43f4:	cd b7       	in	r28, 0x3d	; 61
    43f6:	de b7       	in	r29, 0x3e	; 62
    43f8:	28 97       	sbiw	r28, 0x08	; 8
    43fa:	0f b6       	in	r0, 0x3f	; 63
    43fc:	f8 94       	cli
    43fe:	de bf       	out	0x3e, r29	; 62
    4400:	0f be       	out	0x3f, r0	; 63
    4402:	cd bf       	out	0x3d, r28	; 61
    4404:	9c 83       	std	Y+4, r25	; 0x04
    4406:	8b 83       	std	Y+3, r24	; 0x03
    4408:	7e 83       	std	Y+6, r23	; 0x06
    440a:	6d 83       	std	Y+5, r22	; 0x05
    440c:	58 87       	std	Y+8, r21	; 0x08
    440e:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4410:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    4412:	eb 81       	ldd	r30, Y+3	; 0x03
    4414:	fc 81       	ldd	r31, Y+4	; 0x04
    4416:	82 8d       	ldd	r24, Z+26	; 0x1a
    4418:	88 23       	and	r24, r24
    441a:	71 f1       	breq	.+92     	; 0x4478 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    441c:	8b 81       	ldd	r24, Y+3	; 0x03
    441e:	9c 81       	ldd	r25, Y+4	; 0x04
    4420:	2d 81       	ldd	r18, Y+5	; 0x05
    4422:	3e 81       	ldd	r19, Y+6	; 0x06
    4424:	b9 01       	movw	r22, r18
    4426:	0e 94 2e 23 	call	0x465c	; 0x465c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    442a:	eb 81       	ldd	r30, Y+3	; 0x03
    442c:	fc 81       	ldd	r31, Y+4	; 0x04
    442e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4430:	81 50       	subi	r24, 0x01	; 1
    4432:	eb 81       	ldd	r30, Y+3	; 0x03
    4434:	fc 81       	ldd	r31, Y+4	; 0x04
    4436:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    4438:	eb 81       	ldd	r30, Y+3	; 0x03
    443a:	fc 81       	ldd	r31, Y+4	; 0x04
    443c:	85 8d       	ldd	r24, Z+29	; 0x1d
    443e:	8f 3f       	cpi	r24, 0xFF	; 255
    4440:	89 f4       	brne	.+34     	; 0x4464 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4442:	eb 81       	ldd	r30, Y+3	; 0x03
    4444:	fc 81       	ldd	r31, Y+4	; 0x04
    4446:	80 85       	ldd	r24, Z+8	; 0x08
    4448:	88 23       	and	r24, r24
    444a:	99 f0       	breq	.+38     	; 0x4472 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    444c:	8b 81       	ldd	r24, Y+3	; 0x03
    444e:	9c 81       	ldd	r25, Y+4	; 0x04
    4450:	08 96       	adiw	r24, 0x08	; 8
    4452:	0e 94 ae 28 	call	0x515c	; 0x515c <xTaskRemoveFromEventList>
    4456:	88 23       	and	r24, r24
    4458:	61 f0       	breq	.+24     	; 0x4472 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    445a:	ef 81       	ldd	r30, Y+7	; 0x07
    445c:	f8 85       	ldd	r31, Y+8	; 0x08
    445e:	81 e0       	ldi	r24, 0x01	; 1
    4460:	80 83       	st	Z, r24
    4462:	07 c0       	rjmp	.+14     	; 0x4472 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    4464:	eb 81       	ldd	r30, Y+3	; 0x03
    4466:	fc 81       	ldd	r31, Y+4	; 0x04
    4468:	85 8d       	ldd	r24, Z+29	; 0x1d
    446a:	8f 5f       	subi	r24, 0xFF	; 255
    446c:	eb 81       	ldd	r30, Y+3	; 0x03
    446e:	fc 81       	ldd	r31, Y+4	; 0x04
    4470:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    4472:	81 e0       	ldi	r24, 0x01	; 1
    4474:	8a 83       	std	Y+2, r24	; 0x02
    4476:	01 c0       	rjmp	.+2      	; 0x447a <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    4478:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    447a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    447c:	28 96       	adiw	r28, 0x08	; 8
    447e:	0f b6       	in	r0, 0x3f	; 63
    4480:	f8 94       	cli
    4482:	de bf       	out	0x3e, r29	; 62
    4484:	0f be       	out	0x3f, r0	; 63
    4486:	cd bf       	out	0x3d, r28	; 61
    4488:	cf 91       	pop	r28
    448a:	df 91       	pop	r29
    448c:	08 95       	ret

0000448e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    448e:	df 93       	push	r29
    4490:	cf 93       	push	r28
    4492:	00 d0       	rcall	.+0      	; 0x4494 <uxQueueMessagesWaiting+0x6>
    4494:	0f 92       	push	r0
    4496:	cd b7       	in	r28, 0x3d	; 61
    4498:	de b7       	in	r29, 0x3e	; 62
    449a:	9b 83       	std	Y+3, r25	; 0x03
    449c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    449e:	0f b6       	in	r0, 0x3f	; 63
    44a0:	f8 94       	cli
    44a2:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    44a4:	ea 81       	ldd	r30, Y+2	; 0x02
    44a6:	fb 81       	ldd	r31, Y+3	; 0x03
    44a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    44aa:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    44ac:	0f 90       	pop	r0
    44ae:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    44b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    44b2:	0f 90       	pop	r0
    44b4:	0f 90       	pop	r0
    44b6:	0f 90       	pop	r0
    44b8:	cf 91       	pop	r28
    44ba:	df 91       	pop	r29
    44bc:	08 95       	ret

000044be <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    44be:	df 93       	push	r29
    44c0:	cf 93       	push	r28
    44c2:	00 d0       	rcall	.+0      	; 0x44c4 <uxQueueMessagesWaitingFromISR+0x6>
    44c4:	0f 92       	push	r0
    44c6:	cd b7       	in	r28, 0x3d	; 61
    44c8:	de b7       	in	r29, 0x3e	; 62
    44ca:	9b 83       	std	Y+3, r25	; 0x03
    44cc:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    44ce:	ea 81       	ldd	r30, Y+2	; 0x02
    44d0:	fb 81       	ldd	r31, Y+3	; 0x03
    44d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    44d4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    44d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    44d8:	0f 90       	pop	r0
    44da:	0f 90       	pop	r0
    44dc:	0f 90       	pop	r0
    44de:	cf 91       	pop	r28
    44e0:	df 91       	pop	r29
    44e2:	08 95       	ret

000044e4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    44e4:	df 93       	push	r29
    44e6:	cf 93       	push	r28
    44e8:	00 d0       	rcall	.+0      	; 0x44ea <vQueueDelete+0x6>
    44ea:	cd b7       	in	r28, 0x3d	; 61
    44ec:	de b7       	in	r29, 0x3e	; 62
    44ee:	9a 83       	std	Y+2, r25	; 0x02
    44f0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    44f2:	e9 81       	ldd	r30, Y+1	; 0x01
    44f4:	fa 81       	ldd	r31, Y+2	; 0x02
    44f6:	80 81       	ld	r24, Z
    44f8:	91 81       	ldd	r25, Z+1	; 0x01
    44fa:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vPortFree>
	vPortFree( pxQueue );
    44fe:	89 81       	ldd	r24, Y+1	; 0x01
    4500:	9a 81       	ldd	r25, Y+2	; 0x02
    4502:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vPortFree>
}
    4506:	0f 90       	pop	r0
    4508:	0f 90       	pop	r0
    450a:	cf 91       	pop	r28
    450c:	df 91       	pop	r29
    450e:	08 95       	ret

00004510 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    4510:	df 93       	push	r29
    4512:	cf 93       	push	r28
    4514:	00 d0       	rcall	.+0      	; 0x4516 <prvCopyDataToQueue+0x6>
    4516:	00 d0       	rcall	.+0      	; 0x4518 <prvCopyDataToQueue+0x8>
    4518:	0f 92       	push	r0
    451a:	cd b7       	in	r28, 0x3d	; 61
    451c:	de b7       	in	r29, 0x3e	; 62
    451e:	9a 83       	std	Y+2, r25	; 0x02
    4520:	89 83       	std	Y+1, r24	; 0x01
    4522:	7c 83       	std	Y+4, r23	; 0x04
    4524:	6b 83       	std	Y+3, r22	; 0x03
    4526:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    4528:	e9 81       	ldd	r30, Y+1	; 0x01
    452a:	fa 81       	ldd	r31, Y+2	; 0x02
    452c:	84 8d       	ldd	r24, Z+28	; 0x1c
    452e:	88 23       	and	r24, r24
    4530:	91 f4       	brne	.+36     	; 0x4556 <prvCopyDataToQueue+0x46>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4532:	e9 81       	ldd	r30, Y+1	; 0x01
    4534:	fa 81       	ldd	r31, Y+2	; 0x02
    4536:	80 81       	ld	r24, Z
    4538:	91 81       	ldd	r25, Z+1	; 0x01
    453a:	00 97       	sbiw	r24, 0x00	; 0
    453c:	09 f0       	breq	.+2      	; 0x4540 <prvCopyDataToQueue+0x30>
    453e:	7f c0       	rjmp	.+254    	; 0x463e <prvCopyDataToQueue+0x12e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    4540:	e9 81       	ldd	r30, Y+1	; 0x01
    4542:	fa 81       	ldd	r31, Y+2	; 0x02
    4544:	82 81       	ldd	r24, Z+2	; 0x02
    4546:	93 81       	ldd	r25, Z+3	; 0x03
    4548:	0e 94 b7 2b 	call	0x576e	; 0x576e <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    454c:	e9 81       	ldd	r30, Y+1	; 0x01
    454e:	fa 81       	ldd	r31, Y+2	; 0x02
    4550:	13 82       	std	Z+3, r1	; 0x03
    4552:	12 82       	std	Z+2, r1	; 0x02
    4554:	74 c0       	rjmp	.+232    	; 0x463e <prvCopyDataToQueue+0x12e>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    4556:	8d 81       	ldd	r24, Y+5	; 0x05
    4558:	88 23       	and	r24, r24
    455a:	99 f5       	brne	.+102    	; 0x45c2 <prvCopyDataToQueue+0xb2>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    455c:	e9 81       	ldd	r30, Y+1	; 0x01
    455e:	fa 81       	ldd	r31, Y+2	; 0x02
    4560:	64 81       	ldd	r22, Z+4	; 0x04
    4562:	75 81       	ldd	r23, Z+5	; 0x05
    4564:	e9 81       	ldd	r30, Y+1	; 0x01
    4566:	fa 81       	ldd	r31, Y+2	; 0x02
    4568:	84 8d       	ldd	r24, Z+28	; 0x1c
    456a:	48 2f       	mov	r20, r24
    456c:	50 e0       	ldi	r21, 0x00	; 0
    456e:	2b 81       	ldd	r18, Y+3	; 0x03
    4570:	3c 81       	ldd	r19, Y+4	; 0x04
    4572:	cb 01       	movw	r24, r22
    4574:	b9 01       	movw	r22, r18
    4576:	0e 94 40 31 	call	0x6280	; 0x6280 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    457a:	e9 81       	ldd	r30, Y+1	; 0x01
    457c:	fa 81       	ldd	r31, Y+2	; 0x02
    457e:	24 81       	ldd	r18, Z+4	; 0x04
    4580:	35 81       	ldd	r19, Z+5	; 0x05
    4582:	e9 81       	ldd	r30, Y+1	; 0x01
    4584:	fa 81       	ldd	r31, Y+2	; 0x02
    4586:	84 8d       	ldd	r24, Z+28	; 0x1c
    4588:	88 2f       	mov	r24, r24
    458a:	90 e0       	ldi	r25, 0x00	; 0
    458c:	82 0f       	add	r24, r18
    458e:	93 1f       	adc	r25, r19
    4590:	e9 81       	ldd	r30, Y+1	; 0x01
    4592:	fa 81       	ldd	r31, Y+2	; 0x02
    4594:	95 83       	std	Z+5, r25	; 0x05
    4596:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    4598:	e9 81       	ldd	r30, Y+1	; 0x01
    459a:	fa 81       	ldd	r31, Y+2	; 0x02
    459c:	24 81       	ldd	r18, Z+4	; 0x04
    459e:	35 81       	ldd	r19, Z+5	; 0x05
    45a0:	e9 81       	ldd	r30, Y+1	; 0x01
    45a2:	fa 81       	ldd	r31, Y+2	; 0x02
    45a4:	82 81       	ldd	r24, Z+2	; 0x02
    45a6:	93 81       	ldd	r25, Z+3	; 0x03
    45a8:	28 17       	cp	r18, r24
    45aa:	39 07       	cpc	r19, r25
    45ac:	08 f4       	brcc	.+2      	; 0x45b0 <prvCopyDataToQueue+0xa0>
    45ae:	47 c0       	rjmp	.+142    	; 0x463e <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    45b0:	e9 81       	ldd	r30, Y+1	; 0x01
    45b2:	fa 81       	ldd	r31, Y+2	; 0x02
    45b4:	80 81       	ld	r24, Z
    45b6:	91 81       	ldd	r25, Z+1	; 0x01
    45b8:	e9 81       	ldd	r30, Y+1	; 0x01
    45ba:	fa 81       	ldd	r31, Y+2	; 0x02
    45bc:	95 83       	std	Z+5, r25	; 0x05
    45be:	84 83       	std	Z+4, r24	; 0x04
    45c0:	3e c0       	rjmp	.+124    	; 0x463e <prvCopyDataToQueue+0x12e>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    45c2:	e9 81       	ldd	r30, Y+1	; 0x01
    45c4:	fa 81       	ldd	r31, Y+2	; 0x02
    45c6:	66 81       	ldd	r22, Z+6	; 0x06
    45c8:	77 81       	ldd	r23, Z+7	; 0x07
    45ca:	e9 81       	ldd	r30, Y+1	; 0x01
    45cc:	fa 81       	ldd	r31, Y+2	; 0x02
    45ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    45d0:	48 2f       	mov	r20, r24
    45d2:	50 e0       	ldi	r21, 0x00	; 0
    45d4:	2b 81       	ldd	r18, Y+3	; 0x03
    45d6:	3c 81       	ldd	r19, Y+4	; 0x04
    45d8:	cb 01       	movw	r24, r22
    45da:	b9 01       	movw	r22, r18
    45dc:	0e 94 40 31 	call	0x6280	; 0x6280 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    45e0:	e9 81       	ldd	r30, Y+1	; 0x01
    45e2:	fa 81       	ldd	r31, Y+2	; 0x02
    45e4:	26 81       	ldd	r18, Z+6	; 0x06
    45e6:	37 81       	ldd	r19, Z+7	; 0x07
    45e8:	e9 81       	ldd	r30, Y+1	; 0x01
    45ea:	fa 81       	ldd	r31, Y+2	; 0x02
    45ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    45ee:	88 2f       	mov	r24, r24
    45f0:	90 e0       	ldi	r25, 0x00	; 0
    45f2:	90 95       	com	r25
    45f4:	81 95       	neg	r24
    45f6:	9f 4f       	sbci	r25, 0xFF	; 255
    45f8:	82 0f       	add	r24, r18
    45fa:	93 1f       	adc	r25, r19
    45fc:	e9 81       	ldd	r30, Y+1	; 0x01
    45fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4600:	97 83       	std	Z+7, r25	; 0x07
    4602:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    4604:	e9 81       	ldd	r30, Y+1	; 0x01
    4606:	fa 81       	ldd	r31, Y+2	; 0x02
    4608:	26 81       	ldd	r18, Z+6	; 0x06
    460a:	37 81       	ldd	r19, Z+7	; 0x07
    460c:	e9 81       	ldd	r30, Y+1	; 0x01
    460e:	fa 81       	ldd	r31, Y+2	; 0x02
    4610:	80 81       	ld	r24, Z
    4612:	91 81       	ldd	r25, Z+1	; 0x01
    4614:	28 17       	cp	r18, r24
    4616:	39 07       	cpc	r19, r25
    4618:	90 f4       	brcc	.+36     	; 0x463e <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    461a:	e9 81       	ldd	r30, Y+1	; 0x01
    461c:	fa 81       	ldd	r31, Y+2	; 0x02
    461e:	22 81       	ldd	r18, Z+2	; 0x02
    4620:	33 81       	ldd	r19, Z+3	; 0x03
    4622:	e9 81       	ldd	r30, Y+1	; 0x01
    4624:	fa 81       	ldd	r31, Y+2	; 0x02
    4626:	84 8d       	ldd	r24, Z+28	; 0x1c
    4628:	88 2f       	mov	r24, r24
    462a:	90 e0       	ldi	r25, 0x00	; 0
    462c:	90 95       	com	r25
    462e:	81 95       	neg	r24
    4630:	9f 4f       	sbci	r25, 0xFF	; 255
    4632:	82 0f       	add	r24, r18
    4634:	93 1f       	adc	r25, r19
    4636:	e9 81       	ldd	r30, Y+1	; 0x01
    4638:	fa 81       	ldd	r31, Y+2	; 0x02
    463a:	97 83       	std	Z+7, r25	; 0x07
    463c:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    463e:	e9 81       	ldd	r30, Y+1	; 0x01
    4640:	fa 81       	ldd	r31, Y+2	; 0x02
    4642:	82 8d       	ldd	r24, Z+26	; 0x1a
    4644:	8f 5f       	subi	r24, 0xFF	; 255
    4646:	e9 81       	ldd	r30, Y+1	; 0x01
    4648:	fa 81       	ldd	r31, Y+2	; 0x02
    464a:	82 8f       	std	Z+26, r24	; 0x1a
}
    464c:	0f 90       	pop	r0
    464e:	0f 90       	pop	r0
    4650:	0f 90       	pop	r0
    4652:	0f 90       	pop	r0
    4654:	0f 90       	pop	r0
    4656:	cf 91       	pop	r28
    4658:	df 91       	pop	r29
    465a:	08 95       	ret

0000465c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    465c:	df 93       	push	r29
    465e:	cf 93       	push	r28
    4660:	00 d0       	rcall	.+0      	; 0x4662 <prvCopyDataFromQueue+0x6>
    4662:	00 d0       	rcall	.+0      	; 0x4664 <prvCopyDataFromQueue+0x8>
    4664:	cd b7       	in	r28, 0x3d	; 61
    4666:	de b7       	in	r29, 0x3e	; 62
    4668:	9a 83       	std	Y+2, r25	; 0x02
    466a:	89 83       	std	Y+1, r24	; 0x01
    466c:	7c 83       	std	Y+4, r23	; 0x04
    466e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    4670:	e9 81       	ldd	r30, Y+1	; 0x01
    4672:	fa 81       	ldd	r31, Y+2	; 0x02
    4674:	80 81       	ld	r24, Z
    4676:	91 81       	ldd	r25, Z+1	; 0x01
    4678:	00 97       	sbiw	r24, 0x00	; 0
    467a:	89 f1       	breq	.+98     	; 0x46de <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    467c:	e9 81       	ldd	r30, Y+1	; 0x01
    467e:	fa 81       	ldd	r31, Y+2	; 0x02
    4680:	26 81       	ldd	r18, Z+6	; 0x06
    4682:	37 81       	ldd	r19, Z+7	; 0x07
    4684:	e9 81       	ldd	r30, Y+1	; 0x01
    4686:	fa 81       	ldd	r31, Y+2	; 0x02
    4688:	84 8d       	ldd	r24, Z+28	; 0x1c
    468a:	88 2f       	mov	r24, r24
    468c:	90 e0       	ldi	r25, 0x00	; 0
    468e:	82 0f       	add	r24, r18
    4690:	93 1f       	adc	r25, r19
    4692:	e9 81       	ldd	r30, Y+1	; 0x01
    4694:	fa 81       	ldd	r31, Y+2	; 0x02
    4696:	97 83       	std	Z+7, r25	; 0x07
    4698:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    469a:	e9 81       	ldd	r30, Y+1	; 0x01
    469c:	fa 81       	ldd	r31, Y+2	; 0x02
    469e:	26 81       	ldd	r18, Z+6	; 0x06
    46a0:	37 81       	ldd	r19, Z+7	; 0x07
    46a2:	e9 81       	ldd	r30, Y+1	; 0x01
    46a4:	fa 81       	ldd	r31, Y+2	; 0x02
    46a6:	82 81       	ldd	r24, Z+2	; 0x02
    46a8:	93 81       	ldd	r25, Z+3	; 0x03
    46aa:	28 17       	cp	r18, r24
    46ac:	39 07       	cpc	r19, r25
    46ae:	40 f0       	brcs	.+16     	; 0x46c0 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    46b0:	e9 81       	ldd	r30, Y+1	; 0x01
    46b2:	fa 81       	ldd	r31, Y+2	; 0x02
    46b4:	80 81       	ld	r24, Z
    46b6:	91 81       	ldd	r25, Z+1	; 0x01
    46b8:	e9 81       	ldd	r30, Y+1	; 0x01
    46ba:	fa 81       	ldd	r31, Y+2	; 0x02
    46bc:	97 83       	std	Z+7, r25	; 0x07
    46be:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    46c0:	e9 81       	ldd	r30, Y+1	; 0x01
    46c2:	fa 81       	ldd	r31, Y+2	; 0x02
    46c4:	46 81       	ldd	r20, Z+6	; 0x06
    46c6:	57 81       	ldd	r21, Z+7	; 0x07
    46c8:	e9 81       	ldd	r30, Y+1	; 0x01
    46ca:	fa 81       	ldd	r31, Y+2	; 0x02
    46cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    46ce:	28 2f       	mov	r18, r24
    46d0:	30 e0       	ldi	r19, 0x00	; 0
    46d2:	8b 81       	ldd	r24, Y+3	; 0x03
    46d4:	9c 81       	ldd	r25, Y+4	; 0x04
    46d6:	ba 01       	movw	r22, r20
    46d8:	a9 01       	movw	r20, r18
    46da:	0e 94 40 31 	call	0x6280	; 0x6280 <memcpy>
	}
}
    46de:	0f 90       	pop	r0
    46e0:	0f 90       	pop	r0
    46e2:	0f 90       	pop	r0
    46e4:	0f 90       	pop	r0
    46e6:	cf 91       	pop	r28
    46e8:	df 91       	pop	r29
    46ea:	08 95       	ret

000046ec <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    46ec:	df 93       	push	r29
    46ee:	cf 93       	push	r28
    46f0:	00 d0       	rcall	.+0      	; 0x46f2 <prvUnlockQueue+0x6>
    46f2:	cd b7       	in	r28, 0x3d	; 61
    46f4:	de b7       	in	r29, 0x3e	; 62
    46f6:	9a 83       	std	Y+2, r25	; 0x02
    46f8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    46fa:	0f b6       	in	r0, 0x3f	; 63
    46fc:	f8 94       	cli
    46fe:	0f 92       	push	r0
    4700:	15 c0       	rjmp	.+42     	; 0x472c <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4702:	e9 81       	ldd	r30, Y+1	; 0x01
    4704:	fa 81       	ldd	r31, Y+2	; 0x02
    4706:	81 89       	ldd	r24, Z+17	; 0x11
    4708:	88 23       	and	r24, r24
    470a:	a9 f0       	breq	.+42     	; 0x4736 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    470c:	89 81       	ldd	r24, Y+1	; 0x01
    470e:	9a 81       	ldd	r25, Y+2	; 0x02
    4710:	41 96       	adiw	r24, 0x11	; 17
    4712:	0e 94 ae 28 	call	0x515c	; 0x515c <xTaskRemoveFromEventList>
    4716:	88 23       	and	r24, r24
    4718:	11 f0       	breq	.+4      	; 0x471e <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    471a:	0e 94 8c 29 	call	0x5318	; 0x5318 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    471e:	e9 81       	ldd	r30, Y+1	; 0x01
    4720:	fa 81       	ldd	r31, Y+2	; 0x02
    4722:	86 8d       	ldd	r24, Z+30	; 0x1e
    4724:	81 50       	subi	r24, 0x01	; 1
    4726:	e9 81       	ldd	r30, Y+1	; 0x01
    4728:	fa 81       	ldd	r31, Y+2	; 0x02
    472a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    472c:	e9 81       	ldd	r30, Y+1	; 0x01
    472e:	fa 81       	ldd	r31, Y+2	; 0x02
    4730:	86 8d       	ldd	r24, Z+30	; 0x1e
    4732:	18 16       	cp	r1, r24
    4734:	34 f3       	brlt	.-52     	; 0x4702 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4736:	e9 81       	ldd	r30, Y+1	; 0x01
    4738:	fa 81       	ldd	r31, Y+2	; 0x02
    473a:	8f ef       	ldi	r24, 0xFF	; 255
    473c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    473e:	0f 90       	pop	r0
    4740:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4742:	0f b6       	in	r0, 0x3f	; 63
    4744:	f8 94       	cli
    4746:	0f 92       	push	r0
    4748:	15 c0       	rjmp	.+42     	; 0x4774 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    474a:	e9 81       	ldd	r30, Y+1	; 0x01
    474c:	fa 81       	ldd	r31, Y+2	; 0x02
    474e:	80 85       	ldd	r24, Z+8	; 0x08
    4750:	88 23       	and	r24, r24
    4752:	a9 f0       	breq	.+42     	; 0x477e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4754:	89 81       	ldd	r24, Y+1	; 0x01
    4756:	9a 81       	ldd	r25, Y+2	; 0x02
    4758:	08 96       	adiw	r24, 0x08	; 8
    475a:	0e 94 ae 28 	call	0x515c	; 0x515c <xTaskRemoveFromEventList>
    475e:	88 23       	and	r24, r24
    4760:	11 f0       	breq	.+4      	; 0x4766 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4762:	0e 94 8c 29 	call	0x5318	; 0x5318 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4766:	e9 81       	ldd	r30, Y+1	; 0x01
    4768:	fa 81       	ldd	r31, Y+2	; 0x02
    476a:	85 8d       	ldd	r24, Z+29	; 0x1d
    476c:	81 50       	subi	r24, 0x01	; 1
    476e:	e9 81       	ldd	r30, Y+1	; 0x01
    4770:	fa 81       	ldd	r31, Y+2	; 0x02
    4772:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4774:	e9 81       	ldd	r30, Y+1	; 0x01
    4776:	fa 81       	ldd	r31, Y+2	; 0x02
    4778:	85 8d       	ldd	r24, Z+29	; 0x1d
    477a:	18 16       	cp	r1, r24
    477c:	34 f3       	brlt	.-52     	; 0x474a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    477e:	e9 81       	ldd	r30, Y+1	; 0x01
    4780:	fa 81       	ldd	r31, Y+2	; 0x02
    4782:	8f ef       	ldi	r24, 0xFF	; 255
    4784:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4786:	0f 90       	pop	r0
    4788:	0f be       	out	0x3f, r0	; 63
}
    478a:	0f 90       	pop	r0
    478c:	0f 90       	pop	r0
    478e:	cf 91       	pop	r28
    4790:	df 91       	pop	r29
    4792:	08 95       	ret

00004794 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    4794:	df 93       	push	r29
    4796:	cf 93       	push	r28
    4798:	00 d0       	rcall	.+0      	; 0x479a <prvIsQueueEmpty+0x6>
    479a:	0f 92       	push	r0
    479c:	cd b7       	in	r28, 0x3d	; 61
    479e:	de b7       	in	r29, 0x3e	; 62
    47a0:	9b 83       	std	Y+3, r25	; 0x03
    47a2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    47a4:	0f b6       	in	r0, 0x3f	; 63
    47a6:	f8 94       	cli
    47a8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    47aa:	ea 81       	ldd	r30, Y+2	; 0x02
    47ac:	fb 81       	ldd	r31, Y+3	; 0x03
    47ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    47b0:	19 82       	std	Y+1, r1	; 0x01
    47b2:	88 23       	and	r24, r24
    47b4:	11 f4       	brne	.+4      	; 0x47ba <prvIsQueueEmpty+0x26>
    47b6:	81 e0       	ldi	r24, 0x01	; 1
    47b8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    47ba:	0f 90       	pop	r0
    47bc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    47be:	89 81       	ldd	r24, Y+1	; 0x01
}
    47c0:	0f 90       	pop	r0
    47c2:	0f 90       	pop	r0
    47c4:	0f 90       	pop	r0
    47c6:	cf 91       	pop	r28
    47c8:	df 91       	pop	r29
    47ca:	08 95       	ret

000047cc <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    47cc:	df 93       	push	r29
    47ce:	cf 93       	push	r28
    47d0:	00 d0       	rcall	.+0      	; 0x47d2 <xQueueIsQueueEmptyFromISR+0x6>
    47d2:	0f 92       	push	r0
    47d4:	cd b7       	in	r28, 0x3d	; 61
    47d6:	de b7       	in	r29, 0x3e	; 62
    47d8:	9b 83       	std	Y+3, r25	; 0x03
    47da:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    47dc:	ea 81       	ldd	r30, Y+2	; 0x02
    47de:	fb 81       	ldd	r31, Y+3	; 0x03
    47e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    47e2:	19 82       	std	Y+1, r1	; 0x01
    47e4:	88 23       	and	r24, r24
    47e6:	11 f4       	brne	.+4      	; 0x47ec <xQueueIsQueueEmptyFromISR+0x20>
    47e8:	81 e0       	ldi	r24, 0x01	; 1
    47ea:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    47ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    47ee:	0f 90       	pop	r0
    47f0:	0f 90       	pop	r0
    47f2:	0f 90       	pop	r0
    47f4:	cf 91       	pop	r28
    47f6:	df 91       	pop	r29
    47f8:	08 95       	ret

000047fa <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    47fa:	df 93       	push	r29
    47fc:	cf 93       	push	r28
    47fe:	00 d0       	rcall	.+0      	; 0x4800 <prvIsQueueFull+0x6>
    4800:	0f 92       	push	r0
    4802:	cd b7       	in	r28, 0x3d	; 61
    4804:	de b7       	in	r29, 0x3e	; 62
    4806:	9b 83       	std	Y+3, r25	; 0x03
    4808:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    480a:	0f b6       	in	r0, 0x3f	; 63
    480c:	f8 94       	cli
    480e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    4810:	ea 81       	ldd	r30, Y+2	; 0x02
    4812:	fb 81       	ldd	r31, Y+3	; 0x03
    4814:	92 8d       	ldd	r25, Z+26	; 0x1a
    4816:	ea 81       	ldd	r30, Y+2	; 0x02
    4818:	fb 81       	ldd	r31, Y+3	; 0x03
    481a:	83 8d       	ldd	r24, Z+27	; 0x1b
    481c:	19 82       	std	Y+1, r1	; 0x01
    481e:	98 17       	cp	r25, r24
    4820:	11 f4       	brne	.+4      	; 0x4826 <prvIsQueueFull+0x2c>
    4822:	81 e0       	ldi	r24, 0x01	; 1
    4824:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4826:	0f 90       	pop	r0
    4828:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    482a:	89 81       	ldd	r24, Y+1	; 0x01
}
    482c:	0f 90       	pop	r0
    482e:	0f 90       	pop	r0
    4830:	0f 90       	pop	r0
    4832:	cf 91       	pop	r28
    4834:	df 91       	pop	r29
    4836:	08 95       	ret

00004838 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    4838:	df 93       	push	r29
    483a:	cf 93       	push	r28
    483c:	00 d0       	rcall	.+0      	; 0x483e <xQueueIsQueueFullFromISR+0x6>
    483e:	0f 92       	push	r0
    4840:	cd b7       	in	r28, 0x3d	; 61
    4842:	de b7       	in	r29, 0x3e	; 62
    4844:	9b 83       	std	Y+3, r25	; 0x03
    4846:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    4848:	ea 81       	ldd	r30, Y+2	; 0x02
    484a:	fb 81       	ldd	r31, Y+3	; 0x03
    484c:	92 8d       	ldd	r25, Z+26	; 0x1a
    484e:	ea 81       	ldd	r30, Y+2	; 0x02
    4850:	fb 81       	ldd	r31, Y+3	; 0x03
    4852:	83 8d       	ldd	r24, Z+27	; 0x1b
    4854:	19 82       	std	Y+1, r1	; 0x01
    4856:	98 17       	cp	r25, r24
    4858:	11 f4       	brne	.+4      	; 0x485e <xQueueIsQueueFullFromISR+0x26>
    485a:	81 e0       	ldi	r24, 0x01	; 1
    485c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    485e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4860:	0f 90       	pop	r0
    4862:	0f 90       	pop	r0
    4864:	0f 90       	pop	r0
    4866:	cf 91       	pop	r28
    4868:	df 91       	pop	r29
    486a:	08 95       	ret

0000486c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    486c:	af 92       	push	r10
    486e:	bf 92       	push	r11
    4870:	cf 92       	push	r12
    4872:	df 92       	push	r13
    4874:	ef 92       	push	r14
    4876:	ff 92       	push	r15
    4878:	0f 93       	push	r16
    487a:	1f 93       	push	r17
    487c:	df 93       	push	r29
    487e:	cf 93       	push	r28
    4880:	cd b7       	in	r28, 0x3d	; 61
    4882:	de b7       	in	r29, 0x3e	; 62
    4884:	64 97       	sbiw	r28, 0x14	; 20
    4886:	0f b6       	in	r0, 0x3f	; 63
    4888:	f8 94       	cli
    488a:	de bf       	out	0x3e, r29	; 62
    488c:	0f be       	out	0x3f, r0	; 63
    488e:	cd bf       	out	0x3d, r28	; 61
    4890:	9f 83       	std	Y+7, r25	; 0x07
    4892:	8e 83       	std	Y+6, r24	; 0x06
    4894:	79 87       	std	Y+9, r23	; 0x09
    4896:	68 87       	std	Y+8, r22	; 0x08
    4898:	5b 87       	std	Y+11, r21	; 0x0b
    489a:	4a 87       	std	Y+10, r20	; 0x0a
    489c:	3d 87       	std	Y+13, r19	; 0x0d
    489e:	2c 87       	std	Y+12, r18	; 0x0c
    48a0:	0e 87       	std	Y+14, r16	; 0x0e
    48a2:	f8 8a       	std	Y+16, r15	; 0x10
    48a4:	ef 86       	std	Y+15, r14	; 0x0f
    48a6:	da 8a       	std	Y+18, r13	; 0x12
    48a8:	c9 8a       	std	Y+17, r12	; 0x11
    48aa:	bc 8a       	std	Y+20, r11	; 0x14
    48ac:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    48ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    48b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    48b2:	29 89       	ldd	r18, Y+17	; 0x11
    48b4:	3a 89       	ldd	r19, Y+18	; 0x12
    48b6:	b9 01       	movw	r22, r18
    48b8:	0e 94 bf 2a 	call	0x557e	; 0x557e <prvAllocateTCBAndStack>
    48bc:	9c 83       	std	Y+4, r25	; 0x04
    48be:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    48c0:	8b 81       	ldd	r24, Y+3	; 0x03
    48c2:	9c 81       	ldd	r25, Y+4	; 0x04
    48c4:	00 97       	sbiw	r24, 0x00	; 0
    48c6:	09 f4       	brne	.+2      	; 0x48ca <xTaskGenericCreate+0x5e>
    48c8:	99 c0       	rjmp	.+306    	; 0x49fc <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    48ca:	eb 81       	ldd	r30, Y+3	; 0x03
    48cc:	fc 81       	ldd	r31, Y+4	; 0x04
    48ce:	27 89       	ldd	r18, Z+23	; 0x17
    48d0:	30 8d       	ldd	r19, Z+24	; 0x18
    48d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    48d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    48d6:	01 97       	sbiw	r24, 0x01	; 1
    48d8:	82 0f       	add	r24, r18
    48da:	93 1f       	adc	r25, r19
    48dc:	9a 83       	std	Y+2, r25	; 0x02
    48de:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    48e0:	8b 81       	ldd	r24, Y+3	; 0x03
    48e2:	9c 81       	ldd	r25, Y+4	; 0x04
    48e4:	28 85       	ldd	r18, Y+8	; 0x08
    48e6:	39 85       	ldd	r19, Y+9	; 0x09
    48e8:	eb 89       	ldd	r30, Y+19	; 0x13
    48ea:	fc 89       	ldd	r31, Y+20	; 0x14
    48ec:	aa 85       	ldd	r26, Y+10	; 0x0a
    48ee:	bb 85       	ldd	r27, Y+11	; 0x0b
    48f0:	b9 01       	movw	r22, r18
    48f2:	4e 85       	ldd	r20, Y+14	; 0x0e
    48f4:	9f 01       	movw	r18, r30
    48f6:	8d 01       	movw	r16, r26
    48f8:	0e 94 a0 29 	call	0x5340	; 0x5340 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    48fc:	89 81       	ldd	r24, Y+1	; 0x01
    48fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4900:	2e 81       	ldd	r18, Y+6	; 0x06
    4902:	3f 81       	ldd	r19, Y+7	; 0x07
    4904:	4c 85       	ldd	r20, Y+12	; 0x0c
    4906:	5d 85       	ldd	r21, Y+13	; 0x0d
    4908:	b9 01       	movw	r22, r18
    490a:	0e 94 cf 1b 	call	0x379e	; 0x379e <pxPortInitialiseStack>
    490e:	eb 81       	ldd	r30, Y+3	; 0x03
    4910:	fc 81       	ldd	r31, Y+4	; 0x04
    4912:	91 83       	std	Z+1, r25	; 0x01
    4914:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    4916:	8f 85       	ldd	r24, Y+15	; 0x0f
    4918:	98 89       	ldd	r25, Y+16	; 0x10
    491a:	00 97       	sbiw	r24, 0x00	; 0
    491c:	31 f0       	breq	.+12     	; 0x492a <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    491e:	ef 85       	ldd	r30, Y+15	; 0x0f
    4920:	f8 89       	ldd	r31, Y+16	; 0x10
    4922:	8b 81       	ldd	r24, Y+3	; 0x03
    4924:	9c 81       	ldd	r25, Y+4	; 0x04
    4926:	91 83       	std	Z+1, r25	; 0x01
    4928:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    492a:	0f b6       	in	r0, 0x3f	; 63
    492c:	f8 94       	cli
    492e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    4930:	80 91 c7 06 	lds	r24, 0x06C7
    4934:	8f 5f       	subi	r24, 0xFF	; 255
    4936:	80 93 c7 06 	sts	0x06C7, r24
			if( pxCurrentTCB == NULL )
    493a:	80 91 c4 06 	lds	r24, 0x06C4
    493e:	90 91 c5 06 	lds	r25, 0x06C5
    4942:	00 97       	sbiw	r24, 0x00	; 0
    4944:	69 f4       	brne	.+26     	; 0x4960 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4946:	8b 81       	ldd	r24, Y+3	; 0x03
    4948:	9c 81       	ldd	r25, Y+4	; 0x04
    494a:	90 93 c5 06 	sts	0x06C5, r25
    494e:	80 93 c4 06 	sts	0x06C4, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    4952:	80 91 c7 06 	lds	r24, 0x06C7
    4956:	81 30       	cpi	r24, 0x01	; 1
    4958:	a9 f4       	brne	.+42     	; 0x4984 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    495a:	0e 94 fb 29 	call	0x53f6	; 0x53f6 <prvInitialiseTaskLists>
    495e:	12 c0       	rjmp	.+36     	; 0x4984 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4960:	80 91 cc 06 	lds	r24, 0x06CC
    4964:	88 23       	and	r24, r24
    4966:	71 f4       	brne	.+28     	; 0x4984 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4968:	e0 91 c4 06 	lds	r30, 0x06C4
    496c:	f0 91 c5 06 	lds	r31, 0x06C5
    4970:	96 89       	ldd	r25, Z+22	; 0x16
    4972:	8e 85       	ldd	r24, Y+14	; 0x0e
    4974:	89 17       	cp	r24, r25
    4976:	30 f0       	brcs	.+12     	; 0x4984 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4978:	8b 81       	ldd	r24, Y+3	; 0x03
    497a:	9c 81       	ldd	r25, Y+4	; 0x04
    497c:	90 93 c5 06 	sts	0x06C5, r25
    4980:	80 93 c4 06 	sts	0x06C4, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    4984:	eb 81       	ldd	r30, Y+3	; 0x03
    4986:	fc 81       	ldd	r31, Y+4	; 0x04
    4988:	96 89       	ldd	r25, Z+22	; 0x16
    498a:	80 91 ca 06 	lds	r24, 0x06CA
    498e:	89 17       	cp	r24, r25
    4990:	28 f4       	brcc	.+10     	; 0x499c <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    4992:	eb 81       	ldd	r30, Y+3	; 0x03
    4994:	fc 81       	ldd	r31, Y+4	; 0x04
    4996:	86 89       	ldd	r24, Z+22	; 0x16
    4998:	80 93 ca 06 	sts	0x06CA, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    499c:	80 91 d1 06 	lds	r24, 0x06D1
    49a0:	8f 5f       	subi	r24, 0xFF	; 255
    49a2:	80 93 d1 06 	sts	0x06D1, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    49a6:	eb 81       	ldd	r30, Y+3	; 0x03
    49a8:	fc 81       	ldd	r31, Y+4	; 0x04
    49aa:	96 89       	ldd	r25, Z+22	; 0x16
    49ac:	80 91 cb 06 	lds	r24, 0x06CB
    49b0:	89 17       	cp	r24, r25
    49b2:	28 f4       	brcc	.+10     	; 0x49be <xTaskGenericCreate+0x152>
    49b4:	eb 81       	ldd	r30, Y+3	; 0x03
    49b6:	fc 81       	ldd	r31, Y+4	; 0x04
    49b8:	86 89       	ldd	r24, Z+22	; 0x16
    49ba:	80 93 cb 06 	sts	0x06CB, r24
    49be:	eb 81       	ldd	r30, Y+3	; 0x03
    49c0:	fc 81       	ldd	r31, Y+4	; 0x04
    49c2:	86 89       	ldd	r24, Z+22	; 0x16
    49c4:	28 2f       	mov	r18, r24
    49c6:	30 e0       	ldi	r19, 0x00	; 0
    49c8:	c9 01       	movw	r24, r18
    49ca:	88 0f       	add	r24, r24
    49cc:	99 1f       	adc	r25, r25
    49ce:	88 0f       	add	r24, r24
    49d0:	99 1f       	adc	r25, r25
    49d2:	88 0f       	add	r24, r24
    49d4:	99 1f       	adc	r25, r25
    49d6:	82 0f       	add	r24, r18
    49d8:	93 1f       	adc	r25, r19
    49da:	ac 01       	movw	r20, r24
    49dc:	4e 52       	subi	r20, 0x2E	; 46
    49de:	59 4f       	sbci	r21, 0xF9	; 249
    49e0:	8b 81       	ldd	r24, Y+3	; 0x03
    49e2:	9c 81       	ldd	r25, Y+4	; 0x04
    49e4:	9c 01       	movw	r18, r24
    49e6:	2e 5f       	subi	r18, 0xFE	; 254
    49e8:	3f 4f       	sbci	r19, 0xFF	; 255
    49ea:	ca 01       	movw	r24, r20
    49ec:	b9 01       	movw	r22, r18
    49ee:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>

			xReturn = pdPASS;
    49f2:	81 e0       	ldi	r24, 0x01	; 1
    49f4:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    49f6:	0f 90       	pop	r0
    49f8:	0f be       	out	0x3f, r0	; 63
    49fa:	02 c0       	rjmp	.+4      	; 0x4a00 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    49fc:	8f ef       	ldi	r24, 0xFF	; 255
    49fe:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4a00:	8d 81       	ldd	r24, Y+5	; 0x05
    4a02:	81 30       	cpi	r24, 0x01	; 1
    4a04:	71 f4       	brne	.+28     	; 0x4a22 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    4a06:	80 91 cc 06 	lds	r24, 0x06CC
    4a0a:	88 23       	and	r24, r24
    4a0c:	51 f0       	breq	.+20     	; 0x4a22 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    4a0e:	e0 91 c4 06 	lds	r30, 0x06C4
    4a12:	f0 91 c5 06 	lds	r31, 0x06C5
    4a16:	96 89       	ldd	r25, Z+22	; 0x16
    4a18:	8e 85       	ldd	r24, Y+14	; 0x0e
    4a1a:	98 17       	cp	r25, r24
    4a1c:	10 f4       	brcc	.+4      	; 0x4a22 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    4a1e:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
			}
		}
	}

	return xReturn;
    4a22:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4a24:	64 96       	adiw	r28, 0x14	; 20
    4a26:	0f b6       	in	r0, 0x3f	; 63
    4a28:	f8 94       	cli
    4a2a:	de bf       	out	0x3e, r29	; 62
    4a2c:	0f be       	out	0x3f, r0	; 63
    4a2e:	cd bf       	out	0x3d, r28	; 61
    4a30:	cf 91       	pop	r28
    4a32:	df 91       	pop	r29
    4a34:	1f 91       	pop	r17
    4a36:	0f 91       	pop	r16
    4a38:	ff 90       	pop	r15
    4a3a:	ef 90       	pop	r14
    4a3c:	df 90       	pop	r13
    4a3e:	cf 90       	pop	r12
    4a40:	bf 90       	pop	r11
    4a42:	af 90       	pop	r10
    4a44:	08 95       	ret

00004a46 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    4a46:	df 93       	push	r29
    4a48:	cf 93       	push	r28
    4a4a:	00 d0       	rcall	.+0      	; 0x4a4c <vTaskDelete+0x6>
    4a4c:	00 d0       	rcall	.+0      	; 0x4a4e <vTaskDelete+0x8>
    4a4e:	00 d0       	rcall	.+0      	; 0x4a50 <vTaskDelete+0xa>
    4a50:	cd b7       	in	r28, 0x3d	; 61
    4a52:	de b7       	in	r29, 0x3e	; 62
    4a54:	9c 83       	std	Y+4, r25	; 0x04
    4a56:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4a58:	0f b6       	in	r0, 0x3f	; 63
    4a5a:	f8 94       	cli
    4a5c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    4a5e:	20 91 c4 06 	lds	r18, 0x06C4
    4a62:	30 91 c5 06 	lds	r19, 0x06C5
    4a66:	8b 81       	ldd	r24, Y+3	; 0x03
    4a68:	9c 81       	ldd	r25, Y+4	; 0x04
    4a6a:	82 17       	cp	r24, r18
    4a6c:	93 07       	cpc	r25, r19
    4a6e:	11 f4       	brne	.+4      	; 0x4a74 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    4a70:	1c 82       	std	Y+4, r1	; 0x04
    4a72:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    4a74:	8b 81       	ldd	r24, Y+3	; 0x03
    4a76:	9c 81       	ldd	r25, Y+4	; 0x04
    4a78:	00 97       	sbiw	r24, 0x00	; 0
    4a7a:	39 f4       	brne	.+14     	; 0x4a8a <vTaskDelete+0x44>
    4a7c:	80 91 c4 06 	lds	r24, 0x06C4
    4a80:	90 91 c5 06 	lds	r25, 0x06C5
    4a84:	9e 83       	std	Y+6, r25	; 0x06
    4a86:	8d 83       	std	Y+5, r24	; 0x05
    4a88:	04 c0       	rjmp	.+8      	; 0x4a92 <vTaskDelete+0x4c>
    4a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a8e:	9e 83       	std	Y+6, r25	; 0x06
    4a90:	8d 83       	std	Y+5, r24	; 0x05
    4a92:	8d 81       	ldd	r24, Y+5	; 0x05
    4a94:	9e 81       	ldd	r25, Y+6	; 0x06
    4a96:	9a 83       	std	Y+2, r25	; 0x02
    4a98:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    4a9a:	89 81       	ldd	r24, Y+1	; 0x01
    4a9c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a9e:	02 96       	adiw	r24, 0x02	; 2
    4aa0:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    4aa4:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa6:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa8:	84 89       	ldd	r24, Z+20	; 0x14
    4aaa:	95 89       	ldd	r25, Z+21	; 0x15
    4aac:	00 97       	sbiw	r24, 0x00	; 0
    4aae:	29 f0       	breq	.+10     	; 0x4aba <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    4ab0:	89 81       	ldd	r24, Y+1	; 0x01
    4ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ab4:	0c 96       	adiw	r24, 0x0c	; 12
    4ab6:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4aba:	89 81       	ldd	r24, Y+1	; 0x01
    4abc:	9a 81       	ldd	r25, Y+2	; 0x02
    4abe:	9c 01       	movw	r18, r24
    4ac0:	2e 5f       	subi	r18, 0xFE	; 254
    4ac2:	3f 4f       	sbci	r19, 0xFF	; 255
    4ac4:	80 e3       	ldi	r24, 0x30	; 48
    4ac6:	97 e0       	ldi	r25, 0x07	; 7
    4ac8:	b9 01       	movw	r22, r18
    4aca:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4ace:	80 91 c6 06 	lds	r24, 0x06C6
    4ad2:	8f 5f       	subi	r24, 0xFF	; 255
    4ad4:	80 93 c6 06 	sts	0x06C6, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4ad8:	80 91 d1 06 	lds	r24, 0x06D1
    4adc:	8f 5f       	subi	r24, 0xFF	; 255
    4ade:	80 93 d1 06 	sts	0x06D1, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4ae2:	0f 90       	pop	r0
    4ae4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    4ae6:	80 91 cc 06 	lds	r24, 0x06CC
    4aea:	88 23       	and	r24, r24
    4aec:	31 f0       	breq	.+12     	; 0x4afa <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    4aee:	8b 81       	ldd	r24, Y+3	; 0x03
    4af0:	9c 81       	ldd	r25, Y+4	; 0x04
    4af2:	00 97       	sbiw	r24, 0x00	; 0
    4af4:	11 f4       	brne	.+4      	; 0x4afa <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    4af6:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
			}
		}
	}
    4afa:	26 96       	adiw	r28, 0x06	; 6
    4afc:	0f b6       	in	r0, 0x3f	; 63
    4afe:	f8 94       	cli
    4b00:	de bf       	out	0x3e, r29	; 62
    4b02:	0f be       	out	0x3f, r0	; 63
    4b04:	cd bf       	out	0x3d, r28	; 61
    4b06:	cf 91       	pop	r28
    4b08:	df 91       	pop	r29
    4b0a:	08 95       	ret

00004b0c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    4b0c:	df 93       	push	r29
    4b0e:	cf 93       	push	r28
    4b10:	cd b7       	in	r28, 0x3d	; 61
    4b12:	de b7       	in	r29, 0x3e	; 62
    4b14:	28 97       	sbiw	r28, 0x08	; 8
    4b16:	0f b6       	in	r0, 0x3f	; 63
    4b18:	f8 94       	cli
    4b1a:	de bf       	out	0x3e, r29	; 62
    4b1c:	0f be       	out	0x3f, r0	; 63
    4b1e:	cd bf       	out	0x3d, r28	; 61
    4b20:	9e 83       	std	Y+6, r25	; 0x06
    4b22:	8d 83       	std	Y+5, r24	; 0x05
    4b24:	78 87       	std	Y+8, r23	; 0x08
    4b26:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    4b28:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    4b2a:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4b2e:	ed 81       	ldd	r30, Y+5	; 0x05
    4b30:	fe 81       	ldd	r31, Y+6	; 0x06
    4b32:	20 81       	ld	r18, Z
    4b34:	31 81       	ldd	r19, Z+1	; 0x01
    4b36:	8f 81       	ldd	r24, Y+7	; 0x07
    4b38:	98 85       	ldd	r25, Y+8	; 0x08
    4b3a:	82 0f       	add	r24, r18
    4b3c:	93 1f       	adc	r25, r19
    4b3e:	9c 83       	std	Y+4, r25	; 0x04
    4b40:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    4b42:	ed 81       	ldd	r30, Y+5	; 0x05
    4b44:	fe 81       	ldd	r31, Y+6	; 0x06
    4b46:	20 81       	ld	r18, Z
    4b48:	31 81       	ldd	r19, Z+1	; 0x01
    4b4a:	80 91 c8 06 	lds	r24, 0x06C8
    4b4e:	90 91 c9 06 	lds	r25, 0x06C9
    4b52:	82 17       	cp	r24, r18
    4b54:	93 07       	cpc	r25, r19
    4b56:	a8 f4       	brcc	.+42     	; 0x4b82 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4b58:	ed 81       	ldd	r30, Y+5	; 0x05
    4b5a:	fe 81       	ldd	r31, Y+6	; 0x06
    4b5c:	20 81       	ld	r18, Z
    4b5e:	31 81       	ldd	r19, Z+1	; 0x01
    4b60:	8b 81       	ldd	r24, Y+3	; 0x03
    4b62:	9c 81       	ldd	r25, Y+4	; 0x04
    4b64:	82 17       	cp	r24, r18
    4b66:	93 07       	cpc	r25, r19
    4b68:	00 f5       	brcc	.+64     	; 0x4baa <vTaskDelayUntil+0x9e>
    4b6a:	20 91 c8 06 	lds	r18, 0x06C8
    4b6e:	30 91 c9 06 	lds	r19, 0x06C9
    4b72:	8b 81       	ldd	r24, Y+3	; 0x03
    4b74:	9c 81       	ldd	r25, Y+4	; 0x04
    4b76:	28 17       	cp	r18, r24
    4b78:	39 07       	cpc	r19, r25
    4b7a:	b8 f4       	brcc	.+46     	; 0x4baa <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4b7c:	81 e0       	ldi	r24, 0x01	; 1
    4b7e:	89 83       	std	Y+1, r24	; 0x01
    4b80:	14 c0       	rjmp	.+40     	; 0x4baa <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    4b82:	ed 81       	ldd	r30, Y+5	; 0x05
    4b84:	fe 81       	ldd	r31, Y+6	; 0x06
    4b86:	20 81       	ld	r18, Z
    4b88:	31 81       	ldd	r19, Z+1	; 0x01
    4b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b8e:	82 17       	cp	r24, r18
    4b90:	93 07       	cpc	r25, r19
    4b92:	48 f0       	brcs	.+18     	; 0x4ba6 <vTaskDelayUntil+0x9a>
    4b94:	20 91 c8 06 	lds	r18, 0x06C8
    4b98:	30 91 c9 06 	lds	r19, 0x06C9
    4b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    4ba0:	28 17       	cp	r18, r24
    4ba2:	39 07       	cpc	r19, r25
    4ba4:	10 f4       	brcc	.+4      	; 0x4baa <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4ba6:	81 e0       	ldi	r24, 0x01	; 1
    4ba8:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4baa:	ed 81       	ldd	r30, Y+5	; 0x05
    4bac:	fe 81       	ldd	r31, Y+6	; 0x06
    4bae:	8b 81       	ldd	r24, Y+3	; 0x03
    4bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    4bb2:	91 83       	std	Z+1, r25	; 0x01
    4bb4:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4bb6:	89 81       	ldd	r24, Y+1	; 0x01
    4bb8:	88 23       	and	r24, r24
    4bba:	59 f0       	breq	.+22     	; 0x4bd2 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4bbc:	80 91 c4 06 	lds	r24, 0x06C4
    4bc0:	90 91 c5 06 	lds	r25, 0x06C5
    4bc4:	02 96       	adiw	r24, 0x02	; 2
    4bc6:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4bca:	8b 81       	ldd	r24, Y+3	; 0x03
    4bcc:	9c 81       	ldd	r25, Y+4	; 0x04
    4bce:	0e 94 76 2a 	call	0x54ec	; 0x54ec <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4bd2:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>
    4bd6:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4bd8:	8a 81       	ldd	r24, Y+2	; 0x02
    4bda:	88 23       	and	r24, r24
    4bdc:	11 f4       	brne	.+4      	; 0x4be2 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    4bde:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
		}
	}
    4be2:	28 96       	adiw	r28, 0x08	; 8
    4be4:	0f b6       	in	r0, 0x3f	; 63
    4be6:	f8 94       	cli
    4be8:	de bf       	out	0x3e, r29	; 62
    4bea:	0f be       	out	0x3f, r0	; 63
    4bec:	cd bf       	out	0x3d, r28	; 61
    4bee:	cf 91       	pop	r28
    4bf0:	df 91       	pop	r29
    4bf2:	08 95       	ret

00004bf4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    4bf4:	df 93       	push	r29
    4bf6:	cf 93       	push	r28
    4bf8:	00 d0       	rcall	.+0      	; 0x4bfa <vTaskDelay+0x6>
    4bfa:	00 d0       	rcall	.+0      	; 0x4bfc <vTaskDelay+0x8>
    4bfc:	0f 92       	push	r0
    4bfe:	cd b7       	in	r28, 0x3d	; 61
    4c00:	de b7       	in	r29, 0x3e	; 62
    4c02:	9d 83       	std	Y+5, r25	; 0x05
    4c04:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4c06:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    4c08:	8c 81       	ldd	r24, Y+4	; 0x04
    4c0a:	9d 81       	ldd	r25, Y+5	; 0x05
    4c0c:	00 97       	sbiw	r24, 0x00	; 0
    4c0e:	d1 f0       	breq	.+52     	; 0x4c44 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    4c10:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    4c14:	20 91 c8 06 	lds	r18, 0x06C8
    4c18:	30 91 c9 06 	lds	r19, 0x06C9
    4c1c:	8c 81       	ldd	r24, Y+4	; 0x04
    4c1e:	9d 81       	ldd	r25, Y+5	; 0x05
    4c20:	82 0f       	add	r24, r18
    4c22:	93 1f       	adc	r25, r19
    4c24:	9b 83       	std	Y+3, r25	; 0x03
    4c26:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4c28:	80 91 c4 06 	lds	r24, 0x06C4
    4c2c:	90 91 c5 06 	lds	r25, 0x06C5
    4c30:	02 96       	adiw	r24, 0x02	; 2
    4c32:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4c36:	8a 81       	ldd	r24, Y+2	; 0x02
    4c38:	9b 81       	ldd	r25, Y+3	; 0x03
    4c3a:	0e 94 76 2a 	call	0x54ec	; 0x54ec <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4c3e:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>
    4c42:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4c44:	89 81       	ldd	r24, Y+1	; 0x01
    4c46:	88 23       	and	r24, r24
    4c48:	11 f4       	brne	.+4      	; 0x4c4e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4c4a:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
		}
	}
    4c4e:	0f 90       	pop	r0
    4c50:	0f 90       	pop	r0
    4c52:	0f 90       	pop	r0
    4c54:	0f 90       	pop	r0
    4c56:	0f 90       	pop	r0
    4c58:	cf 91       	pop	r28
    4c5a:	df 91       	pop	r29
    4c5c:	08 95       	ret

00004c5e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    4c5e:	af 92       	push	r10
    4c60:	bf 92       	push	r11
    4c62:	cf 92       	push	r12
    4c64:	df 92       	push	r13
    4c66:	ef 92       	push	r14
    4c68:	ff 92       	push	r15
    4c6a:	0f 93       	push	r16
    4c6c:	df 93       	push	r29
    4c6e:	cf 93       	push	r28
    4c70:	0f 92       	push	r0
    4c72:	cd b7       	in	r28, 0x3d	; 61
    4c74:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4c76:	20 e6       	ldi	r18, 0x60	; 96
    4c78:	30 e0       	ldi	r19, 0x00	; 0
    4c7a:	86 e9       	ldi	r24, 0x96	; 150
    4c7c:	99 e2       	ldi	r25, 0x29	; 41
    4c7e:	b9 01       	movw	r22, r18
    4c80:	44 e6       	ldi	r20, 0x64	; 100
    4c82:	50 e0       	ldi	r21, 0x00	; 0
    4c84:	20 e0       	ldi	r18, 0x00	; 0
    4c86:	30 e0       	ldi	r19, 0x00	; 0
    4c88:	00 e0       	ldi	r16, 0x00	; 0
    4c8a:	ee 24       	eor	r14, r14
    4c8c:	ff 24       	eor	r15, r15
    4c8e:	cc 24       	eor	r12, r12
    4c90:	dd 24       	eor	r13, r13
    4c92:	aa 24       	eor	r10, r10
    4c94:	bb 24       	eor	r11, r11
    4c96:	0e 94 36 24 	call	0x486c	; 0x486c <xTaskGenericCreate>
    4c9a:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    4c9c:	89 81       	ldd	r24, Y+1	; 0x01
    4c9e:	81 30       	cpi	r24, 0x01	; 1
    4ca0:	51 f4       	brne	.+20     	; 0x4cb6 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    4ca2:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    4ca4:	81 e0       	ldi	r24, 0x01	; 1
    4ca6:	80 93 cc 06 	sts	0x06CC, r24
		xTickCount = ( portTickType ) 0U;
    4caa:	10 92 c9 06 	sts	0x06C9, r1
    4cae:	10 92 c8 06 	sts	0x06C8, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4cb2:	0e 94 52 1d 	call	0x3aa4	; 0x3aa4 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4cb6:	0f 90       	pop	r0
    4cb8:	cf 91       	pop	r28
    4cba:	df 91       	pop	r29
    4cbc:	0f 91       	pop	r16
    4cbe:	ff 90       	pop	r15
    4cc0:	ef 90       	pop	r14
    4cc2:	df 90       	pop	r13
    4cc4:	cf 90       	pop	r12
    4cc6:	bf 90       	pop	r11
    4cc8:	af 90       	pop	r10
    4cca:	08 95       	ret

00004ccc <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4ccc:	df 93       	push	r29
    4cce:	cf 93       	push	r28
    4cd0:	cd b7       	in	r28, 0x3d	; 61
    4cd2:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4cd4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4cd6:	10 92 cc 06 	sts	0x06CC, r1
	vPortEndScheduler();
    4cda:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <vPortEndScheduler>
}
    4cde:	cf 91       	pop	r28
    4ce0:	df 91       	pop	r29
    4ce2:	08 95       	ret

00004ce4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4ce4:	df 93       	push	r29
    4ce6:	cf 93       	push	r28
    4ce8:	cd b7       	in	r28, 0x3d	; 61
    4cea:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    4cec:	80 91 cd 06 	lds	r24, 0x06CD
    4cf0:	8f 5f       	subi	r24, 0xFF	; 255
    4cf2:	80 93 cd 06 	sts	0x06CD, r24
}
    4cf6:	cf 91       	pop	r28
    4cf8:	df 91       	pop	r29
    4cfa:	08 95       	ret

00004cfc <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    4cfc:	df 93       	push	r29
    4cfe:	cf 93       	push	r28
    4d00:	00 d0       	rcall	.+0      	; 0x4d02 <xTaskResumeAll+0x6>
    4d02:	00 d0       	rcall	.+0      	; 0x4d04 <xTaskResumeAll+0x8>
    4d04:	cd b7       	in	r28, 0x3d	; 61
    4d06:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4d08:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4d0a:	0f b6       	in	r0, 0x3f	; 63
    4d0c:	f8 94       	cli
    4d0e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4d10:	80 91 cd 06 	lds	r24, 0x06CD
    4d14:	81 50       	subi	r24, 0x01	; 1
    4d16:	80 93 cd 06 	sts	0x06CD, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4d1a:	80 91 cd 06 	lds	r24, 0x06CD
    4d1e:	88 23       	and	r24, r24
    4d20:	09 f0       	breq	.+2      	; 0x4d24 <xTaskResumeAll+0x28>
    4d22:	6c c0       	rjmp	.+216    	; 0x4dfc <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    4d24:	80 91 c7 06 	lds	r24, 0x06C7
    4d28:	88 23       	and	r24, r24
    4d2a:	09 f4       	brne	.+2      	; 0x4d2e <xTaskResumeAll+0x32>
    4d2c:	67 c0       	rjmp	.+206    	; 0x4dfc <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    4d2e:	19 82       	std	Y+1, r1	; 0x01
    4d30:	41 c0       	rjmp	.+130    	; 0x4db4 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    4d32:	e0 91 2c 07 	lds	r30, 0x072C
    4d36:	f0 91 2d 07 	lds	r31, 0x072D
    4d3a:	86 81       	ldd	r24, Z+6	; 0x06
    4d3c:	97 81       	ldd	r25, Z+7	; 0x07
    4d3e:	9c 83       	std	Y+4, r25	; 0x04
    4d40:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    4d42:	8b 81       	ldd	r24, Y+3	; 0x03
    4d44:	9c 81       	ldd	r25, Y+4	; 0x04
    4d46:	0c 96       	adiw	r24, 0x0c	; 12
    4d48:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    4d4c:	8b 81       	ldd	r24, Y+3	; 0x03
    4d4e:	9c 81       	ldd	r25, Y+4	; 0x04
    4d50:	02 96       	adiw	r24, 0x02	; 2
    4d52:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4d56:	eb 81       	ldd	r30, Y+3	; 0x03
    4d58:	fc 81       	ldd	r31, Y+4	; 0x04
    4d5a:	96 89       	ldd	r25, Z+22	; 0x16
    4d5c:	80 91 cb 06 	lds	r24, 0x06CB
    4d60:	89 17       	cp	r24, r25
    4d62:	28 f4       	brcc	.+10     	; 0x4d6e <xTaskResumeAll+0x72>
    4d64:	eb 81       	ldd	r30, Y+3	; 0x03
    4d66:	fc 81       	ldd	r31, Y+4	; 0x04
    4d68:	86 89       	ldd	r24, Z+22	; 0x16
    4d6a:	80 93 cb 06 	sts	0x06CB, r24
    4d6e:	eb 81       	ldd	r30, Y+3	; 0x03
    4d70:	fc 81       	ldd	r31, Y+4	; 0x04
    4d72:	86 89       	ldd	r24, Z+22	; 0x16
    4d74:	28 2f       	mov	r18, r24
    4d76:	30 e0       	ldi	r19, 0x00	; 0
    4d78:	c9 01       	movw	r24, r18
    4d7a:	88 0f       	add	r24, r24
    4d7c:	99 1f       	adc	r25, r25
    4d7e:	88 0f       	add	r24, r24
    4d80:	99 1f       	adc	r25, r25
    4d82:	88 0f       	add	r24, r24
    4d84:	99 1f       	adc	r25, r25
    4d86:	82 0f       	add	r24, r18
    4d88:	93 1f       	adc	r25, r19
    4d8a:	8e 52       	subi	r24, 0x2E	; 46
    4d8c:	99 4f       	sbci	r25, 0xF9	; 249
    4d8e:	2b 81       	ldd	r18, Y+3	; 0x03
    4d90:	3c 81       	ldd	r19, Y+4	; 0x04
    4d92:	2e 5f       	subi	r18, 0xFE	; 254
    4d94:	3f 4f       	sbci	r19, 0xFF	; 255
    4d96:	b9 01       	movw	r22, r18
    4d98:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4d9c:	eb 81       	ldd	r30, Y+3	; 0x03
    4d9e:	fc 81       	ldd	r31, Y+4	; 0x04
    4da0:	96 89       	ldd	r25, Z+22	; 0x16
    4da2:	e0 91 c4 06 	lds	r30, 0x06C4
    4da6:	f0 91 c5 06 	lds	r31, 0x06C5
    4daa:	86 89       	ldd	r24, Z+22	; 0x16
    4dac:	98 17       	cp	r25, r24
    4dae:	10 f0       	brcs	.+4      	; 0x4db4 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    4db0:	81 e0       	ldi	r24, 0x01	; 1
    4db2:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4db4:	80 91 27 07 	lds	r24, 0x0727
    4db8:	88 23       	and	r24, r24
    4dba:	09 f0       	breq	.+2      	; 0x4dbe <xTaskResumeAll+0xc2>
    4dbc:	ba cf       	rjmp	.-140    	; 0x4d32 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4dbe:	80 91 ce 06 	lds	r24, 0x06CE
    4dc2:	88 23       	and	r24, r24
    4dc4:	71 f0       	breq	.+28     	; 0x4de2 <xTaskResumeAll+0xe6>
    4dc6:	07 c0       	rjmp	.+14     	; 0x4dd6 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4dc8:	0e 94 3d 27 	call	0x4e7a	; 0x4e7a <vTaskIncrementTick>
						--uxMissedTicks;
    4dcc:	80 91 ce 06 	lds	r24, 0x06CE
    4dd0:	81 50       	subi	r24, 0x01	; 1
    4dd2:	80 93 ce 06 	sts	0x06CE, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4dd6:	80 91 ce 06 	lds	r24, 0x06CE
    4dda:	88 23       	and	r24, r24
    4ddc:	a9 f7       	brne	.-22     	; 0x4dc8 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    4dde:	81 e0       	ldi	r24, 0x01	; 1
    4de0:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    4de2:	89 81       	ldd	r24, Y+1	; 0x01
    4de4:	81 30       	cpi	r24, 0x01	; 1
    4de6:	21 f0       	breq	.+8      	; 0x4df0 <xTaskResumeAll+0xf4>
    4de8:	80 91 cf 06 	lds	r24, 0x06CF
    4dec:	81 30       	cpi	r24, 0x01	; 1
    4dee:	31 f4       	brne	.+12     	; 0x4dfc <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    4df0:	81 e0       	ldi	r24, 0x01	; 1
    4df2:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    4df4:	10 92 cf 06 	sts	0x06CF, r1
					portYIELD_WITHIN_API();
    4df8:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    4dfc:	0f 90       	pop	r0
    4dfe:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4e00:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4e02:	0f 90       	pop	r0
    4e04:	0f 90       	pop	r0
    4e06:	0f 90       	pop	r0
    4e08:	0f 90       	pop	r0
    4e0a:	cf 91       	pop	r28
    4e0c:	df 91       	pop	r29
    4e0e:	08 95       	ret

00004e10 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    4e10:	df 93       	push	r29
    4e12:	cf 93       	push	r28
    4e14:	00 d0       	rcall	.+0      	; 0x4e16 <xTaskGetTickCount+0x6>
    4e16:	cd b7       	in	r28, 0x3d	; 61
    4e18:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    4e1a:	0f b6       	in	r0, 0x3f	; 63
    4e1c:	f8 94       	cli
    4e1e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4e20:	80 91 c8 06 	lds	r24, 0x06C8
    4e24:	90 91 c9 06 	lds	r25, 0x06C9
    4e28:	9a 83       	std	Y+2, r25	; 0x02
    4e2a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4e2c:	0f 90       	pop	r0
    4e2e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4e30:	89 81       	ldd	r24, Y+1	; 0x01
    4e32:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4e34:	0f 90       	pop	r0
    4e36:	0f 90       	pop	r0
    4e38:	cf 91       	pop	r28
    4e3a:	df 91       	pop	r29
    4e3c:	08 95       	ret

00004e3e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    4e3e:	df 93       	push	r29
    4e40:	cf 93       	push	r28
    4e42:	00 d0       	rcall	.+0      	; 0x4e44 <xTaskGetTickCountFromISR+0x6>
    4e44:	0f 92       	push	r0
    4e46:	cd b7       	in	r28, 0x3d	; 61
    4e48:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4e4a:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4e4c:	80 91 c8 06 	lds	r24, 0x06C8
    4e50:	90 91 c9 06 	lds	r25, 0x06C9
    4e54:	9b 83       	std	Y+3, r25	; 0x03
    4e56:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4e58:	8a 81       	ldd	r24, Y+2	; 0x02
    4e5a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4e5c:	0f 90       	pop	r0
    4e5e:	0f 90       	pop	r0
    4e60:	0f 90       	pop	r0
    4e62:	cf 91       	pop	r28
    4e64:	df 91       	pop	r29
    4e66:	08 95       	ret

00004e68 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4e68:	df 93       	push	r29
    4e6a:	cf 93       	push	r28
    4e6c:	cd b7       	in	r28, 0x3d	; 61
    4e6e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    4e70:	80 91 c7 06 	lds	r24, 0x06C7
}
    4e74:	cf 91       	pop	r28
    4e76:	df 91       	pop	r29
    4e78:	08 95       	ret

00004e7a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4e7a:	df 93       	push	r29
    4e7c:	cf 93       	push	r28
    4e7e:	00 d0       	rcall	.+0      	; 0x4e80 <vTaskIncrementTick+0x6>
    4e80:	00 d0       	rcall	.+0      	; 0x4e82 <vTaskIncrementTick+0x8>
    4e82:	00 d0       	rcall	.+0      	; 0x4e84 <vTaskIncrementTick+0xa>
    4e84:	cd b7       	in	r28, 0x3d	; 61
    4e86:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4e88:	80 91 cd 06 	lds	r24, 0x06CD
    4e8c:	88 23       	and	r24, r24
    4e8e:	09 f0       	breq	.+2      	; 0x4e92 <vTaskIncrementTick+0x18>
    4e90:	bb c0       	rjmp	.+374    	; 0x5008 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    4e92:	80 91 c8 06 	lds	r24, 0x06C8
    4e96:	90 91 c9 06 	lds	r25, 0x06C9
    4e9a:	01 96       	adiw	r24, 0x01	; 1
    4e9c:	90 93 c9 06 	sts	0x06C9, r25
    4ea0:	80 93 c8 06 	sts	0x06C8, r24
		if( xTickCount == ( portTickType ) 0U )
    4ea4:	80 91 c8 06 	lds	r24, 0x06C8
    4ea8:	90 91 c9 06 	lds	r25, 0x06C9
    4eac:	00 97       	sbiw	r24, 0x00	; 0
    4eae:	d1 f5       	brne	.+116    	; 0x4f24 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    4eb0:	80 91 23 07 	lds	r24, 0x0723
    4eb4:	90 91 24 07 	lds	r25, 0x0724
    4eb8:	9c 83       	std	Y+4, r25	; 0x04
    4eba:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4ebc:	80 91 25 07 	lds	r24, 0x0725
    4ec0:	90 91 26 07 	lds	r25, 0x0726
    4ec4:	90 93 24 07 	sts	0x0724, r25
    4ec8:	80 93 23 07 	sts	0x0723, r24
			pxOverflowDelayedTaskList = pxTemp;
    4ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    4ece:	9c 81       	ldd	r25, Y+4	; 0x04
    4ed0:	90 93 26 07 	sts	0x0726, r25
    4ed4:	80 93 25 07 	sts	0x0725, r24
			xNumOfOverflows++;
    4ed8:	80 91 d0 06 	lds	r24, 0x06D0
    4edc:	8f 5f       	subi	r24, 0xFF	; 255
    4ede:	80 93 d0 06 	sts	0x06D0, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4ee2:	e0 91 23 07 	lds	r30, 0x0723
    4ee6:	f0 91 24 07 	lds	r31, 0x0724
    4eea:	80 81       	ld	r24, Z
    4eec:	88 23       	and	r24, r24
    4eee:	39 f4       	brne	.+14     	; 0x4efe <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    4ef0:	8f ef       	ldi	r24, 0xFF	; 255
    4ef2:	9f ef       	ldi	r25, 0xFF	; 255
    4ef4:	90 93 c3 01 	sts	0x01C3, r25
    4ef8:	80 93 c2 01 	sts	0x01C2, r24
    4efc:	13 c0       	rjmp	.+38     	; 0x4f24 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4efe:	e0 91 23 07 	lds	r30, 0x0723
    4f02:	f0 91 24 07 	lds	r31, 0x0724
    4f06:	05 80       	ldd	r0, Z+5	; 0x05
    4f08:	f6 81       	ldd	r31, Z+6	; 0x06
    4f0a:	e0 2d       	mov	r30, r0
    4f0c:	86 81       	ldd	r24, Z+6	; 0x06
    4f0e:	97 81       	ldd	r25, Z+7	; 0x07
    4f10:	9e 83       	std	Y+6, r25	; 0x06
    4f12:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4f14:	ed 81       	ldd	r30, Y+5	; 0x05
    4f16:	fe 81       	ldd	r31, Y+6	; 0x06
    4f18:	82 81       	ldd	r24, Z+2	; 0x02
    4f1a:	93 81       	ldd	r25, Z+3	; 0x03
    4f1c:	90 93 c3 01 	sts	0x01C3, r25
    4f20:	80 93 c2 01 	sts	0x01C2, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    4f24:	20 91 c8 06 	lds	r18, 0x06C8
    4f28:	30 91 c9 06 	lds	r19, 0x06C9
    4f2c:	80 91 c2 01 	lds	r24, 0x01C2
    4f30:	90 91 c3 01 	lds	r25, 0x01C3
    4f34:	28 17       	cp	r18, r24
    4f36:	39 07       	cpc	r19, r25
    4f38:	08 f4       	brcc	.+2      	; 0x4f3c <vTaskIncrementTick+0xc2>
    4f3a:	6b c0       	rjmp	.+214    	; 0x5012 <vTaskIncrementTick+0x198>
    4f3c:	e0 91 23 07 	lds	r30, 0x0723
    4f40:	f0 91 24 07 	lds	r31, 0x0724
    4f44:	80 81       	ld	r24, Z
    4f46:	88 23       	and	r24, r24
    4f48:	39 f4       	brne	.+14     	; 0x4f58 <vTaskIncrementTick+0xde>
    4f4a:	8f ef       	ldi	r24, 0xFF	; 255
    4f4c:	9f ef       	ldi	r25, 0xFF	; 255
    4f4e:	90 93 c3 01 	sts	0x01C3, r25
    4f52:	80 93 c2 01 	sts	0x01C2, r24
    4f56:	5d c0       	rjmp	.+186    	; 0x5012 <vTaskIncrementTick+0x198>
    4f58:	e0 91 23 07 	lds	r30, 0x0723
    4f5c:	f0 91 24 07 	lds	r31, 0x0724
    4f60:	05 80       	ldd	r0, Z+5	; 0x05
    4f62:	f6 81       	ldd	r31, Z+6	; 0x06
    4f64:	e0 2d       	mov	r30, r0
    4f66:	86 81       	ldd	r24, Z+6	; 0x06
    4f68:	97 81       	ldd	r25, Z+7	; 0x07
    4f6a:	9e 83       	std	Y+6, r25	; 0x06
    4f6c:	8d 83       	std	Y+5, r24	; 0x05
    4f6e:	ed 81       	ldd	r30, Y+5	; 0x05
    4f70:	fe 81       	ldd	r31, Y+6	; 0x06
    4f72:	82 81       	ldd	r24, Z+2	; 0x02
    4f74:	93 81       	ldd	r25, Z+3	; 0x03
    4f76:	9a 83       	std	Y+2, r25	; 0x02
    4f78:	89 83       	std	Y+1, r24	; 0x01
    4f7a:	20 91 c8 06 	lds	r18, 0x06C8
    4f7e:	30 91 c9 06 	lds	r19, 0x06C9
    4f82:	89 81       	ldd	r24, Y+1	; 0x01
    4f84:	9a 81       	ldd	r25, Y+2	; 0x02
    4f86:	28 17       	cp	r18, r24
    4f88:	39 07       	cpc	r19, r25
    4f8a:	38 f4       	brcc	.+14     	; 0x4f9a <vTaskIncrementTick+0x120>
    4f8c:	89 81       	ldd	r24, Y+1	; 0x01
    4f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f90:	90 93 c3 01 	sts	0x01C3, r25
    4f94:	80 93 c2 01 	sts	0x01C2, r24
    4f98:	3c c0       	rjmp	.+120    	; 0x5012 <vTaskIncrementTick+0x198>
    4f9a:	8d 81       	ldd	r24, Y+5	; 0x05
    4f9c:	9e 81       	ldd	r25, Y+6	; 0x06
    4f9e:	02 96       	adiw	r24, 0x02	; 2
    4fa0:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
    4fa4:	ed 81       	ldd	r30, Y+5	; 0x05
    4fa6:	fe 81       	ldd	r31, Y+6	; 0x06
    4fa8:	84 89       	ldd	r24, Z+20	; 0x14
    4faa:	95 89       	ldd	r25, Z+21	; 0x15
    4fac:	00 97       	sbiw	r24, 0x00	; 0
    4fae:	29 f0       	breq	.+10     	; 0x4fba <vTaskIncrementTick+0x140>
    4fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    4fb2:	9e 81       	ldd	r25, Y+6	; 0x06
    4fb4:	0c 96       	adiw	r24, 0x0c	; 12
    4fb6:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
    4fba:	ed 81       	ldd	r30, Y+5	; 0x05
    4fbc:	fe 81       	ldd	r31, Y+6	; 0x06
    4fbe:	96 89       	ldd	r25, Z+22	; 0x16
    4fc0:	80 91 cb 06 	lds	r24, 0x06CB
    4fc4:	89 17       	cp	r24, r25
    4fc6:	28 f4       	brcc	.+10     	; 0x4fd2 <vTaskIncrementTick+0x158>
    4fc8:	ed 81       	ldd	r30, Y+5	; 0x05
    4fca:	fe 81       	ldd	r31, Y+6	; 0x06
    4fcc:	86 89       	ldd	r24, Z+22	; 0x16
    4fce:	80 93 cb 06 	sts	0x06CB, r24
    4fd2:	ed 81       	ldd	r30, Y+5	; 0x05
    4fd4:	fe 81       	ldd	r31, Y+6	; 0x06
    4fd6:	86 89       	ldd	r24, Z+22	; 0x16
    4fd8:	28 2f       	mov	r18, r24
    4fda:	30 e0       	ldi	r19, 0x00	; 0
    4fdc:	c9 01       	movw	r24, r18
    4fde:	88 0f       	add	r24, r24
    4fe0:	99 1f       	adc	r25, r25
    4fe2:	88 0f       	add	r24, r24
    4fe4:	99 1f       	adc	r25, r25
    4fe6:	88 0f       	add	r24, r24
    4fe8:	99 1f       	adc	r25, r25
    4fea:	82 0f       	add	r24, r18
    4fec:	93 1f       	adc	r25, r19
    4fee:	ac 01       	movw	r20, r24
    4ff0:	4e 52       	subi	r20, 0x2E	; 46
    4ff2:	59 4f       	sbci	r21, 0xF9	; 249
    4ff4:	8d 81       	ldd	r24, Y+5	; 0x05
    4ff6:	9e 81       	ldd	r25, Y+6	; 0x06
    4ff8:	9c 01       	movw	r18, r24
    4ffa:	2e 5f       	subi	r18, 0xFE	; 254
    4ffc:	3f 4f       	sbci	r19, 0xFF	; 255
    4ffe:	ca 01       	movw	r24, r20
    5000:	b9 01       	movw	r22, r18
    5002:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>
    5006:	9a cf       	rjmp	.-204    	; 0x4f3c <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    5008:	80 91 ce 06 	lds	r24, 0x06CE
    500c:	8f 5f       	subi	r24, 0xFF	; 255
    500e:	80 93 ce 06 	sts	0x06CE, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    5012:	26 96       	adiw	r28, 0x06	; 6
    5014:	0f b6       	in	r0, 0x3f	; 63
    5016:	f8 94       	cli
    5018:	de bf       	out	0x3e, r29	; 62
    501a:	0f be       	out	0x3f, r0	; 63
    501c:	cd bf       	out	0x3d, r28	; 61
    501e:	cf 91       	pop	r28
    5020:	df 91       	pop	r29
    5022:	08 95       	ret

00005024 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5024:	df 93       	push	r29
    5026:	cf 93       	push	r28
    5028:	00 d0       	rcall	.+0      	; 0x502a <vTaskSwitchContext+0x6>
    502a:	cd b7       	in	r28, 0x3d	; 61
    502c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    502e:	80 91 cd 06 	lds	r24, 0x06CD
    5032:	88 23       	and	r24, r24
    5034:	49 f0       	breq	.+18     	; 0x5048 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    5036:	81 e0       	ldi	r24, 0x01	; 1
    5038:	80 93 cf 06 	sts	0x06CF, r24
    503c:	54 c0       	rjmp	.+168    	; 0x50e6 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    503e:	80 91 cb 06 	lds	r24, 0x06CB
    5042:	81 50       	subi	r24, 0x01	; 1
    5044:	80 93 cb 06 	sts	0x06CB, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    5048:	80 91 cb 06 	lds	r24, 0x06CB
    504c:	28 2f       	mov	r18, r24
    504e:	30 e0       	ldi	r19, 0x00	; 0
    5050:	c9 01       	movw	r24, r18
    5052:	88 0f       	add	r24, r24
    5054:	99 1f       	adc	r25, r25
    5056:	88 0f       	add	r24, r24
    5058:	99 1f       	adc	r25, r25
    505a:	88 0f       	add	r24, r24
    505c:	99 1f       	adc	r25, r25
    505e:	82 0f       	add	r24, r18
    5060:	93 1f       	adc	r25, r19
    5062:	fc 01       	movw	r30, r24
    5064:	ee 52       	subi	r30, 0x2E	; 46
    5066:	f9 4f       	sbci	r31, 0xF9	; 249
    5068:	80 81       	ld	r24, Z
    506a:	88 23       	and	r24, r24
    506c:	41 f3       	breq	.-48     	; 0x503e <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    506e:	80 91 cb 06 	lds	r24, 0x06CB
    5072:	28 2f       	mov	r18, r24
    5074:	30 e0       	ldi	r19, 0x00	; 0
    5076:	c9 01       	movw	r24, r18
    5078:	88 0f       	add	r24, r24
    507a:	99 1f       	adc	r25, r25
    507c:	88 0f       	add	r24, r24
    507e:	99 1f       	adc	r25, r25
    5080:	88 0f       	add	r24, r24
    5082:	99 1f       	adc	r25, r25
    5084:	82 0f       	add	r24, r18
    5086:	93 1f       	adc	r25, r19
    5088:	8e 52       	subi	r24, 0x2E	; 46
    508a:	99 4f       	sbci	r25, 0xF9	; 249
    508c:	9a 83       	std	Y+2, r25	; 0x02
    508e:	89 83       	std	Y+1, r24	; 0x01
    5090:	e9 81       	ldd	r30, Y+1	; 0x01
    5092:	fa 81       	ldd	r31, Y+2	; 0x02
    5094:	01 80       	ldd	r0, Z+1	; 0x01
    5096:	f2 81       	ldd	r31, Z+2	; 0x02
    5098:	e0 2d       	mov	r30, r0
    509a:	82 81       	ldd	r24, Z+2	; 0x02
    509c:	93 81       	ldd	r25, Z+3	; 0x03
    509e:	e9 81       	ldd	r30, Y+1	; 0x01
    50a0:	fa 81       	ldd	r31, Y+2	; 0x02
    50a2:	92 83       	std	Z+2, r25	; 0x02
    50a4:	81 83       	std	Z+1, r24	; 0x01
    50a6:	e9 81       	ldd	r30, Y+1	; 0x01
    50a8:	fa 81       	ldd	r31, Y+2	; 0x02
    50aa:	21 81       	ldd	r18, Z+1	; 0x01
    50ac:	32 81       	ldd	r19, Z+2	; 0x02
    50ae:	89 81       	ldd	r24, Y+1	; 0x01
    50b0:	9a 81       	ldd	r25, Y+2	; 0x02
    50b2:	03 96       	adiw	r24, 0x03	; 3
    50b4:	28 17       	cp	r18, r24
    50b6:	39 07       	cpc	r19, r25
    50b8:	59 f4       	brne	.+22     	; 0x50d0 <vTaskSwitchContext+0xac>
    50ba:	e9 81       	ldd	r30, Y+1	; 0x01
    50bc:	fa 81       	ldd	r31, Y+2	; 0x02
    50be:	01 80       	ldd	r0, Z+1	; 0x01
    50c0:	f2 81       	ldd	r31, Z+2	; 0x02
    50c2:	e0 2d       	mov	r30, r0
    50c4:	82 81       	ldd	r24, Z+2	; 0x02
    50c6:	93 81       	ldd	r25, Z+3	; 0x03
    50c8:	e9 81       	ldd	r30, Y+1	; 0x01
    50ca:	fa 81       	ldd	r31, Y+2	; 0x02
    50cc:	92 83       	std	Z+2, r25	; 0x02
    50ce:	81 83       	std	Z+1, r24	; 0x01
    50d0:	e9 81       	ldd	r30, Y+1	; 0x01
    50d2:	fa 81       	ldd	r31, Y+2	; 0x02
    50d4:	01 80       	ldd	r0, Z+1	; 0x01
    50d6:	f2 81       	ldd	r31, Z+2	; 0x02
    50d8:	e0 2d       	mov	r30, r0
    50da:	86 81       	ldd	r24, Z+6	; 0x06
    50dc:	97 81       	ldd	r25, Z+7	; 0x07
    50de:	90 93 c5 06 	sts	0x06C5, r25
    50e2:	80 93 c4 06 	sts	0x06C4, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    50e6:	0f 90       	pop	r0
    50e8:	0f 90       	pop	r0
    50ea:	cf 91       	pop	r28
    50ec:	df 91       	pop	r29
    50ee:	08 95       	ret

000050f0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    50f0:	df 93       	push	r29
    50f2:	cf 93       	push	r28
    50f4:	00 d0       	rcall	.+0      	; 0x50f6 <vTaskPlaceOnEventList+0x6>
    50f6:	00 d0       	rcall	.+0      	; 0x50f8 <vTaskPlaceOnEventList+0x8>
    50f8:	00 d0       	rcall	.+0      	; 0x50fa <vTaskPlaceOnEventList+0xa>
    50fa:	cd b7       	in	r28, 0x3d	; 61
    50fc:	de b7       	in	r29, 0x3e	; 62
    50fe:	9c 83       	std	Y+4, r25	; 0x04
    5100:	8b 83       	std	Y+3, r24	; 0x03
    5102:	7e 83       	std	Y+6, r23	; 0x06
    5104:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    5106:	4b 81       	ldd	r20, Y+3	; 0x03
    5108:	5c 81       	ldd	r21, Y+4	; 0x04
    510a:	80 91 c4 06 	lds	r24, 0x06C4
    510e:	90 91 c5 06 	lds	r25, 0x06C5
    5112:	9c 01       	movw	r18, r24
    5114:	24 5f       	subi	r18, 0xF4	; 244
    5116:	3f 4f       	sbci	r19, 0xFF	; 255
    5118:	ca 01       	movw	r24, r20
    511a:	b9 01       	movw	r22, r18
    511c:	0e 94 1a 1b 	call	0x3634	; 0x3634 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5120:	80 91 c4 06 	lds	r24, 0x06C4
    5124:	90 91 c5 06 	lds	r25, 0x06C5
    5128:	02 96       	adiw	r24, 0x02	; 2
    512a:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    512e:	20 91 c8 06 	lds	r18, 0x06C8
    5132:	30 91 c9 06 	lds	r19, 0x06C9
    5136:	8d 81       	ldd	r24, Y+5	; 0x05
    5138:	9e 81       	ldd	r25, Y+6	; 0x06
    513a:	82 0f       	add	r24, r18
    513c:	93 1f       	adc	r25, r19
    513e:	9a 83       	std	Y+2, r25	; 0x02
    5140:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5142:	89 81       	ldd	r24, Y+1	; 0x01
    5144:	9a 81       	ldd	r25, Y+2	; 0x02
    5146:	0e 94 76 2a 	call	0x54ec	; 0x54ec <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    514a:	26 96       	adiw	r28, 0x06	; 6
    514c:	0f b6       	in	r0, 0x3f	; 63
    514e:	f8 94       	cli
    5150:	de bf       	out	0x3e, r29	; 62
    5152:	0f be       	out	0x3f, r0	; 63
    5154:	cd bf       	out	0x3d, r28	; 61
    5156:	cf 91       	pop	r28
    5158:	df 91       	pop	r29
    515a:	08 95       	ret

0000515c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    515c:	df 93       	push	r29
    515e:	cf 93       	push	r28
    5160:	00 d0       	rcall	.+0      	; 0x5162 <xTaskRemoveFromEventList+0x6>
    5162:	00 d0       	rcall	.+0      	; 0x5164 <xTaskRemoveFromEventList+0x8>
    5164:	0f 92       	push	r0
    5166:	cd b7       	in	r28, 0x3d	; 61
    5168:	de b7       	in	r29, 0x3e	; 62
    516a:	9d 83       	std	Y+5, r25	; 0x05
    516c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    516e:	ec 81       	ldd	r30, Y+4	; 0x04
    5170:	fd 81       	ldd	r31, Y+5	; 0x05
    5172:	05 80       	ldd	r0, Z+5	; 0x05
    5174:	f6 81       	ldd	r31, Z+6	; 0x06
    5176:	e0 2d       	mov	r30, r0
    5178:	86 81       	ldd	r24, Z+6	; 0x06
    517a:	97 81       	ldd	r25, Z+7	; 0x07
    517c:	9b 83       	std	Y+3, r25	; 0x03
    517e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5180:	8a 81       	ldd	r24, Y+2	; 0x02
    5182:	9b 81       	ldd	r25, Y+3	; 0x03
    5184:	0c 96       	adiw	r24, 0x0c	; 12
    5186:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    518a:	80 91 cd 06 	lds	r24, 0x06CD
    518e:	88 23       	and	r24, r24
    5190:	61 f5       	brne	.+88     	; 0x51ea <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5192:	8a 81       	ldd	r24, Y+2	; 0x02
    5194:	9b 81       	ldd	r25, Y+3	; 0x03
    5196:	02 96       	adiw	r24, 0x02	; 2
    5198:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    519c:	ea 81       	ldd	r30, Y+2	; 0x02
    519e:	fb 81       	ldd	r31, Y+3	; 0x03
    51a0:	96 89       	ldd	r25, Z+22	; 0x16
    51a2:	80 91 cb 06 	lds	r24, 0x06CB
    51a6:	89 17       	cp	r24, r25
    51a8:	28 f4       	brcc	.+10     	; 0x51b4 <xTaskRemoveFromEventList+0x58>
    51aa:	ea 81       	ldd	r30, Y+2	; 0x02
    51ac:	fb 81       	ldd	r31, Y+3	; 0x03
    51ae:	86 89       	ldd	r24, Z+22	; 0x16
    51b0:	80 93 cb 06 	sts	0x06CB, r24
    51b4:	ea 81       	ldd	r30, Y+2	; 0x02
    51b6:	fb 81       	ldd	r31, Y+3	; 0x03
    51b8:	86 89       	ldd	r24, Z+22	; 0x16
    51ba:	28 2f       	mov	r18, r24
    51bc:	30 e0       	ldi	r19, 0x00	; 0
    51be:	c9 01       	movw	r24, r18
    51c0:	88 0f       	add	r24, r24
    51c2:	99 1f       	adc	r25, r25
    51c4:	88 0f       	add	r24, r24
    51c6:	99 1f       	adc	r25, r25
    51c8:	88 0f       	add	r24, r24
    51ca:	99 1f       	adc	r25, r25
    51cc:	82 0f       	add	r24, r18
    51ce:	93 1f       	adc	r25, r19
    51d0:	ac 01       	movw	r20, r24
    51d2:	4e 52       	subi	r20, 0x2E	; 46
    51d4:	59 4f       	sbci	r21, 0xF9	; 249
    51d6:	8a 81       	ldd	r24, Y+2	; 0x02
    51d8:	9b 81       	ldd	r25, Y+3	; 0x03
    51da:	9c 01       	movw	r18, r24
    51dc:	2e 5f       	subi	r18, 0xFE	; 254
    51de:	3f 4f       	sbci	r19, 0xFF	; 255
    51e0:	ca 01       	movw	r24, r20
    51e2:	b9 01       	movw	r22, r18
    51e4:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>
    51e8:	0a c0       	rjmp	.+20     	; 0x51fe <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    51ea:	8a 81       	ldd	r24, Y+2	; 0x02
    51ec:	9b 81       	ldd	r25, Y+3	; 0x03
    51ee:	9c 01       	movw	r18, r24
    51f0:	24 5f       	subi	r18, 0xF4	; 244
    51f2:	3f 4f       	sbci	r19, 0xFF	; 255
    51f4:	87 e2       	ldi	r24, 0x27	; 39
    51f6:	97 e0       	ldi	r25, 0x07	; 7
    51f8:	b9 01       	movw	r22, r18
    51fa:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    51fe:	ea 81       	ldd	r30, Y+2	; 0x02
    5200:	fb 81       	ldd	r31, Y+3	; 0x03
    5202:	96 89       	ldd	r25, Z+22	; 0x16
    5204:	e0 91 c4 06 	lds	r30, 0x06C4
    5208:	f0 91 c5 06 	lds	r31, 0x06C5
    520c:	86 89       	ldd	r24, Z+22	; 0x16
    520e:	98 17       	cp	r25, r24
    5210:	18 f0       	brcs	.+6      	; 0x5218 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    5212:	81 e0       	ldi	r24, 0x01	; 1
    5214:	89 83       	std	Y+1, r24	; 0x01
    5216:	01 c0       	rjmp	.+2      	; 0x521a <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    5218:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    521a:	89 81       	ldd	r24, Y+1	; 0x01
}
    521c:	0f 90       	pop	r0
    521e:	0f 90       	pop	r0
    5220:	0f 90       	pop	r0
    5222:	0f 90       	pop	r0
    5224:	0f 90       	pop	r0
    5226:	cf 91       	pop	r28
    5228:	df 91       	pop	r29
    522a:	08 95       	ret

0000522c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    522c:	df 93       	push	r29
    522e:	cf 93       	push	r28
    5230:	00 d0       	rcall	.+0      	; 0x5232 <vTaskSetTimeOutState+0x6>
    5232:	cd b7       	in	r28, 0x3d	; 61
    5234:	de b7       	in	r29, 0x3e	; 62
    5236:	9a 83       	std	Y+2, r25	; 0x02
    5238:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    523a:	80 91 d0 06 	lds	r24, 0x06D0
    523e:	e9 81       	ldd	r30, Y+1	; 0x01
    5240:	fa 81       	ldd	r31, Y+2	; 0x02
    5242:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5244:	80 91 c8 06 	lds	r24, 0x06C8
    5248:	90 91 c9 06 	lds	r25, 0x06C9
    524c:	e9 81       	ldd	r30, Y+1	; 0x01
    524e:	fa 81       	ldd	r31, Y+2	; 0x02
    5250:	92 83       	std	Z+2, r25	; 0x02
    5252:	81 83       	std	Z+1, r24	; 0x01
}
    5254:	0f 90       	pop	r0
    5256:	0f 90       	pop	r0
    5258:	cf 91       	pop	r28
    525a:	df 91       	pop	r29
    525c:	08 95       	ret

0000525e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    525e:	df 93       	push	r29
    5260:	cf 93       	push	r28
    5262:	00 d0       	rcall	.+0      	; 0x5264 <xTaskCheckForTimeOut+0x6>
    5264:	00 d0       	rcall	.+0      	; 0x5266 <xTaskCheckForTimeOut+0x8>
    5266:	0f 92       	push	r0
    5268:	cd b7       	in	r28, 0x3d	; 61
    526a:	de b7       	in	r29, 0x3e	; 62
    526c:	9b 83       	std	Y+3, r25	; 0x03
    526e:	8a 83       	std	Y+2, r24	; 0x02
    5270:	7d 83       	std	Y+5, r23	; 0x05
    5272:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5274:	0f b6       	in	r0, 0x3f	; 63
    5276:	f8 94       	cli
    5278:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    527a:	ea 81       	ldd	r30, Y+2	; 0x02
    527c:	fb 81       	ldd	r31, Y+3	; 0x03
    527e:	90 81       	ld	r25, Z
    5280:	80 91 d0 06 	lds	r24, 0x06D0
    5284:	98 17       	cp	r25, r24
    5286:	71 f0       	breq	.+28     	; 0x52a4 <xTaskCheckForTimeOut+0x46>
    5288:	ea 81       	ldd	r30, Y+2	; 0x02
    528a:	fb 81       	ldd	r31, Y+3	; 0x03
    528c:	21 81       	ldd	r18, Z+1	; 0x01
    528e:	32 81       	ldd	r19, Z+2	; 0x02
    5290:	80 91 c8 06 	lds	r24, 0x06C8
    5294:	90 91 c9 06 	lds	r25, 0x06C9
    5298:	82 17       	cp	r24, r18
    529a:	93 07       	cpc	r25, r19
    529c:	18 f0       	brcs	.+6      	; 0x52a4 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    529e:	81 e0       	ldi	r24, 0x01	; 1
    52a0:	89 83       	std	Y+1, r24	; 0x01
    52a2:	2f c0       	rjmp	.+94     	; 0x5302 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    52a4:	20 91 c8 06 	lds	r18, 0x06C8
    52a8:	30 91 c9 06 	lds	r19, 0x06C9
    52ac:	ea 81       	ldd	r30, Y+2	; 0x02
    52ae:	fb 81       	ldd	r31, Y+3	; 0x03
    52b0:	81 81       	ldd	r24, Z+1	; 0x01
    52b2:	92 81       	ldd	r25, Z+2	; 0x02
    52b4:	28 1b       	sub	r18, r24
    52b6:	39 0b       	sbc	r19, r25
    52b8:	ec 81       	ldd	r30, Y+4	; 0x04
    52ba:	fd 81       	ldd	r31, Y+5	; 0x05
    52bc:	80 81       	ld	r24, Z
    52be:	91 81       	ldd	r25, Z+1	; 0x01
    52c0:	28 17       	cp	r18, r24
    52c2:	39 07       	cpc	r19, r25
    52c4:	e0 f4       	brcc	.+56     	; 0x52fe <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    52c6:	ec 81       	ldd	r30, Y+4	; 0x04
    52c8:	fd 81       	ldd	r31, Y+5	; 0x05
    52ca:	40 81       	ld	r20, Z
    52cc:	51 81       	ldd	r21, Z+1	; 0x01
    52ce:	ea 81       	ldd	r30, Y+2	; 0x02
    52d0:	fb 81       	ldd	r31, Y+3	; 0x03
    52d2:	21 81       	ldd	r18, Z+1	; 0x01
    52d4:	32 81       	ldd	r19, Z+2	; 0x02
    52d6:	80 91 c8 06 	lds	r24, 0x06C8
    52da:	90 91 c9 06 	lds	r25, 0x06C9
    52de:	b9 01       	movw	r22, r18
    52e0:	68 1b       	sub	r22, r24
    52e2:	79 0b       	sbc	r23, r25
    52e4:	cb 01       	movw	r24, r22
    52e6:	84 0f       	add	r24, r20
    52e8:	95 1f       	adc	r25, r21
    52ea:	ec 81       	ldd	r30, Y+4	; 0x04
    52ec:	fd 81       	ldd	r31, Y+5	; 0x05
    52ee:	91 83       	std	Z+1, r25	; 0x01
    52f0:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    52f2:	8a 81       	ldd	r24, Y+2	; 0x02
    52f4:	9b 81       	ldd	r25, Y+3	; 0x03
    52f6:	0e 94 16 29 	call	0x522c	; 0x522c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    52fa:	19 82       	std	Y+1, r1	; 0x01
    52fc:	02 c0       	rjmp	.+4      	; 0x5302 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    52fe:	81 e0       	ldi	r24, 0x01	; 1
    5300:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    5302:	0f 90       	pop	r0
    5304:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5306:	89 81       	ldd	r24, Y+1	; 0x01
}
    5308:	0f 90       	pop	r0
    530a:	0f 90       	pop	r0
    530c:	0f 90       	pop	r0
    530e:	0f 90       	pop	r0
    5310:	0f 90       	pop	r0
    5312:	cf 91       	pop	r28
    5314:	df 91       	pop	r29
    5316:	08 95       	ret

00005318 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5318:	df 93       	push	r29
    531a:	cf 93       	push	r28
    531c:	cd b7       	in	r28, 0x3d	; 61
    531e:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    5320:	81 e0       	ldi	r24, 0x01	; 1
    5322:	80 93 cf 06 	sts	0x06CF, r24
}
    5326:	cf 91       	pop	r28
    5328:	df 91       	pop	r29
    532a:	08 95       	ret

0000532c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    532c:	df 93       	push	r29
    532e:	cf 93       	push	r28
    5330:	00 d0       	rcall	.+0      	; 0x5332 <prvIdleTask+0x6>
    5332:	cd b7       	in	r28, 0x3d	; 61
    5334:	de b7       	in	r29, 0x3e	; 62
    5336:	9a 83       	std	Y+2, r25	; 0x02
    5338:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    533a:	0e 94 38 2a 	call	0x5470	; 0x5470 <prvCheckTasksWaitingTermination>
    533e:	fd cf       	rjmp	.-6      	; 0x533a <prvIdleTask+0xe>

00005340 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    5340:	0f 93       	push	r16
    5342:	1f 93       	push	r17
    5344:	df 93       	push	r29
    5346:	cf 93       	push	r28
    5348:	cd b7       	in	r28, 0x3d	; 61
    534a:	de b7       	in	r29, 0x3e	; 62
    534c:	29 97       	sbiw	r28, 0x09	; 9
    534e:	0f b6       	in	r0, 0x3f	; 63
    5350:	f8 94       	cli
    5352:	de bf       	out	0x3e, r29	; 62
    5354:	0f be       	out	0x3f, r0	; 63
    5356:	cd bf       	out	0x3d, r28	; 61
    5358:	9a 83       	std	Y+2, r25	; 0x02
    535a:	89 83       	std	Y+1, r24	; 0x01
    535c:	7c 83       	std	Y+4, r23	; 0x04
    535e:	6b 83       	std	Y+3, r22	; 0x03
    5360:	4d 83       	std	Y+5, r20	; 0x05
    5362:	3f 83       	std	Y+7, r19	; 0x07
    5364:	2e 83       	std	Y+6, r18	; 0x06
    5366:	19 87       	std	Y+9, r17	; 0x09
    5368:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    536a:	89 81       	ldd	r24, Y+1	; 0x01
    536c:	9a 81       	ldd	r25, Y+2	; 0x02
    536e:	49 96       	adiw	r24, 0x19	; 25
    5370:	2b 81       	ldd	r18, Y+3	; 0x03
    5372:	3c 81       	ldd	r19, Y+4	; 0x04
    5374:	b9 01       	movw	r22, r18
    5376:	48 e0       	ldi	r20, 0x08	; 8
    5378:	50 e0       	ldi	r21, 0x00	; 0
    537a:	0e 94 50 31 	call	0x62a0	; 0x62a0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    537e:	e9 81       	ldd	r30, Y+1	; 0x01
    5380:	fa 81       	ldd	r31, Y+2	; 0x02
    5382:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    5384:	8d 81       	ldd	r24, Y+5	; 0x05
    5386:	87 30       	cpi	r24, 0x07	; 7
    5388:	10 f0       	brcs	.+4      	; 0x538e <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    538a:	86 e0       	ldi	r24, 0x06	; 6
    538c:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    538e:	e9 81       	ldd	r30, Y+1	; 0x01
    5390:	fa 81       	ldd	r31, Y+2	; 0x02
    5392:	8d 81       	ldd	r24, Y+5	; 0x05
    5394:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    5396:	e9 81       	ldd	r30, Y+1	; 0x01
    5398:	fa 81       	ldd	r31, Y+2	; 0x02
    539a:	8d 81       	ldd	r24, Y+5	; 0x05
    539c:	81 a3       	std	Z+33, r24	; 0x21
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    539e:	89 81       	ldd	r24, Y+1	; 0x01
    53a0:	9a 81       	ldd	r25, Y+2	; 0x02
    53a2:	02 96       	adiw	r24, 0x02	; 2
    53a4:	0e 94 be 1a 	call	0x357c	; 0x357c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    53a8:	89 81       	ldd	r24, Y+1	; 0x01
    53aa:	9a 81       	ldd	r25, Y+2	; 0x02
    53ac:	0c 96       	adiw	r24, 0x0c	; 12
    53ae:	0e 94 be 1a 	call	0x357c	; 0x357c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    53b2:	e9 81       	ldd	r30, Y+1	; 0x01
    53b4:	fa 81       	ldd	r31, Y+2	; 0x02
    53b6:	89 81       	ldd	r24, Y+1	; 0x01
    53b8:	9a 81       	ldd	r25, Y+2	; 0x02
    53ba:	91 87       	std	Z+9, r25	; 0x09
    53bc:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    53be:	8d 81       	ldd	r24, Y+5	; 0x05
    53c0:	28 2f       	mov	r18, r24
    53c2:	30 e0       	ldi	r19, 0x00	; 0
    53c4:	87 e0       	ldi	r24, 0x07	; 7
    53c6:	90 e0       	ldi	r25, 0x00	; 0
    53c8:	82 1b       	sub	r24, r18
    53ca:	93 0b       	sbc	r25, r19
    53cc:	e9 81       	ldd	r30, Y+1	; 0x01
    53ce:	fa 81       	ldd	r31, Y+2	; 0x02
    53d0:	95 87       	std	Z+13, r25	; 0x0d
    53d2:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    53d4:	e9 81       	ldd	r30, Y+1	; 0x01
    53d6:	fa 81       	ldd	r31, Y+2	; 0x02
    53d8:	89 81       	ldd	r24, Y+1	; 0x01
    53da:	9a 81       	ldd	r25, Y+2	; 0x02
    53dc:	93 8b       	std	Z+19, r25	; 0x13
    53de:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    53e0:	29 96       	adiw	r28, 0x09	; 9
    53e2:	0f b6       	in	r0, 0x3f	; 63
    53e4:	f8 94       	cli
    53e6:	de bf       	out	0x3e, r29	; 62
    53e8:	0f be       	out	0x3f, r0	; 63
    53ea:	cd bf       	out	0x3d, r28	; 61
    53ec:	cf 91       	pop	r28
    53ee:	df 91       	pop	r29
    53f0:	1f 91       	pop	r17
    53f2:	0f 91       	pop	r16
    53f4:	08 95       	ret

000053f6 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    53f6:	df 93       	push	r29
    53f8:	cf 93       	push	r28
    53fa:	0f 92       	push	r0
    53fc:	cd b7       	in	r28, 0x3d	; 61
    53fe:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5400:	19 82       	std	Y+1, r1	; 0x01
    5402:	13 c0       	rjmp	.+38     	; 0x542a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    5404:	89 81       	ldd	r24, Y+1	; 0x01
    5406:	28 2f       	mov	r18, r24
    5408:	30 e0       	ldi	r19, 0x00	; 0
    540a:	c9 01       	movw	r24, r18
    540c:	88 0f       	add	r24, r24
    540e:	99 1f       	adc	r25, r25
    5410:	88 0f       	add	r24, r24
    5412:	99 1f       	adc	r25, r25
    5414:	88 0f       	add	r24, r24
    5416:	99 1f       	adc	r25, r25
    5418:	82 0f       	add	r24, r18
    541a:	93 1f       	adc	r25, r19
    541c:	8e 52       	subi	r24, 0x2E	; 46
    541e:	99 4f       	sbci	r25, 0xF9	; 249
    5420:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5424:	89 81       	ldd	r24, Y+1	; 0x01
    5426:	8f 5f       	subi	r24, 0xFF	; 255
    5428:	89 83       	std	Y+1, r24	; 0x01
    542a:	89 81       	ldd	r24, Y+1	; 0x01
    542c:	87 30       	cpi	r24, 0x07	; 7
    542e:	50 f3       	brcs	.-44     	; 0x5404 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    5430:	81 e1       	ldi	r24, 0x11	; 17
    5432:	97 e0       	ldi	r25, 0x07	; 7
    5434:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    5438:	8a e1       	ldi	r24, 0x1A	; 26
    543a:	97 e0       	ldi	r25, 0x07	; 7
    543c:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    5440:	87 e2       	ldi	r24, 0x27	; 39
    5442:	97 e0       	ldi	r25, 0x07	; 7
    5444:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    5448:	80 e3       	ldi	r24, 0x30	; 48
    544a:	97 e0       	ldi	r25, 0x07	; 7
    544c:	0e 94 94 1a 	call	0x3528	; 0x3528 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5450:	81 e1       	ldi	r24, 0x11	; 17
    5452:	97 e0       	ldi	r25, 0x07	; 7
    5454:	90 93 24 07 	sts	0x0724, r25
    5458:	80 93 23 07 	sts	0x0723, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    545c:	8a e1       	ldi	r24, 0x1A	; 26
    545e:	97 e0       	ldi	r25, 0x07	; 7
    5460:	90 93 26 07 	sts	0x0726, r25
    5464:	80 93 25 07 	sts	0x0725, r24
}
    5468:	0f 90       	pop	r0
    546a:	cf 91       	pop	r28
    546c:	df 91       	pop	r29
    546e:	08 95       	ret

00005470 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5470:	df 93       	push	r29
    5472:	cf 93       	push	r28
    5474:	00 d0       	rcall	.+0      	; 0x5476 <prvCheckTasksWaitingTermination+0x6>
    5476:	0f 92       	push	r0
    5478:	cd b7       	in	r28, 0x3d	; 61
    547a:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    547c:	80 91 c6 06 	lds	r24, 0x06C6
    5480:	88 23       	and	r24, r24
    5482:	71 f1       	breq	.+92     	; 0x54e0 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    5484:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    5488:	80 91 30 07 	lds	r24, 0x0730
    548c:	1b 82       	std	Y+3, r1	; 0x03
    548e:	88 23       	and	r24, r24
    5490:	11 f4       	brne	.+4      	; 0x5496 <prvCheckTasksWaitingTermination+0x26>
    5492:	81 e0       	ldi	r24, 0x01	; 1
    5494:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    5496:	0e 94 7e 26 	call	0x4cfc	; 0x4cfc <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    549a:	8b 81       	ldd	r24, Y+3	; 0x03
    549c:	88 23       	and	r24, r24
    549e:	01 f5       	brne	.+64     	; 0x54e0 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    54a0:	0f b6       	in	r0, 0x3f	; 63
    54a2:	f8 94       	cli
    54a4:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    54a6:	e0 91 35 07 	lds	r30, 0x0735
    54aa:	f0 91 36 07 	lds	r31, 0x0736
    54ae:	86 81       	ldd	r24, Z+6	; 0x06
    54b0:	97 81       	ldd	r25, Z+7	; 0x07
    54b2:	9a 83       	std	Y+2, r25	; 0x02
    54b4:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    54b6:	89 81       	ldd	r24, Y+1	; 0x01
    54b8:	9a 81       	ldd	r25, Y+2	; 0x02
    54ba:	02 96       	adiw	r24, 0x02	; 2
    54bc:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>
					--uxCurrentNumberOfTasks;
    54c0:	80 91 c7 06 	lds	r24, 0x06C7
    54c4:	81 50       	subi	r24, 0x01	; 1
    54c6:	80 93 c7 06 	sts	0x06C7, r24
					--uxTasksDeleted;
    54ca:	80 91 c6 06 	lds	r24, 0x06C6
    54ce:	81 50       	subi	r24, 0x01	; 1
    54d0:	80 93 c6 06 	sts	0x06C6, r24
				}
				taskEXIT_CRITICAL();
    54d4:	0f 90       	pop	r0
    54d6:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    54d8:	89 81       	ldd	r24, Y+1	; 0x01
    54da:	9a 81       	ldd	r25, Y+2	; 0x02
    54dc:	0e 94 0f 2b 	call	0x561e	; 0x561e <prvDeleteTCB>
			}
		}
	}
	#endif
}
    54e0:	0f 90       	pop	r0
    54e2:	0f 90       	pop	r0
    54e4:	0f 90       	pop	r0
    54e6:	cf 91       	pop	r28
    54e8:	df 91       	pop	r29
    54ea:	08 95       	ret

000054ec <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    54ec:	df 93       	push	r29
    54ee:	cf 93       	push	r28
    54f0:	00 d0       	rcall	.+0      	; 0x54f2 <prvAddCurrentTaskToDelayedList+0x6>
    54f2:	cd b7       	in	r28, 0x3d	; 61
    54f4:	de b7       	in	r29, 0x3e	; 62
    54f6:	9a 83       	std	Y+2, r25	; 0x02
    54f8:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    54fa:	e0 91 c4 06 	lds	r30, 0x06C4
    54fe:	f0 91 c5 06 	lds	r31, 0x06C5
    5502:	89 81       	ldd	r24, Y+1	; 0x01
    5504:	9a 81       	ldd	r25, Y+2	; 0x02
    5506:	93 83       	std	Z+3, r25	; 0x03
    5508:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    550a:	20 91 c8 06 	lds	r18, 0x06C8
    550e:	30 91 c9 06 	lds	r19, 0x06C9
    5512:	89 81       	ldd	r24, Y+1	; 0x01
    5514:	9a 81       	ldd	r25, Y+2	; 0x02
    5516:	82 17       	cp	r24, r18
    5518:	93 07       	cpc	r25, r19
    551a:	70 f4       	brcc	.+28     	; 0x5538 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    551c:	80 91 25 07 	lds	r24, 0x0725
    5520:	90 91 26 07 	lds	r25, 0x0726
    5524:	20 91 c4 06 	lds	r18, 0x06C4
    5528:	30 91 c5 06 	lds	r19, 0x06C5
    552c:	2e 5f       	subi	r18, 0xFE	; 254
    552e:	3f 4f       	sbci	r19, 0xFF	; 255
    5530:	b9 01       	movw	r22, r18
    5532:	0e 94 1a 1b 	call	0x3634	; 0x3634 <vListInsert>
    5536:	1e c0       	rjmp	.+60     	; 0x5574 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5538:	40 91 23 07 	lds	r20, 0x0723
    553c:	50 91 24 07 	lds	r21, 0x0724
    5540:	80 91 c4 06 	lds	r24, 0x06C4
    5544:	90 91 c5 06 	lds	r25, 0x06C5
    5548:	9c 01       	movw	r18, r24
    554a:	2e 5f       	subi	r18, 0xFE	; 254
    554c:	3f 4f       	sbci	r19, 0xFF	; 255
    554e:	ca 01       	movw	r24, r20
    5550:	b9 01       	movw	r22, r18
    5552:	0e 94 1a 1b 	call	0x3634	; 0x3634 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    5556:	20 91 c2 01 	lds	r18, 0x01C2
    555a:	30 91 c3 01 	lds	r19, 0x01C3
    555e:	89 81       	ldd	r24, Y+1	; 0x01
    5560:	9a 81       	ldd	r25, Y+2	; 0x02
    5562:	82 17       	cp	r24, r18
    5564:	93 07       	cpc	r25, r19
    5566:	30 f4       	brcc	.+12     	; 0x5574 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    5568:	89 81       	ldd	r24, Y+1	; 0x01
    556a:	9a 81       	ldd	r25, Y+2	; 0x02
    556c:	90 93 c3 01 	sts	0x01C3, r25
    5570:	80 93 c2 01 	sts	0x01C2, r24
		}
	}
}
    5574:	0f 90       	pop	r0
    5576:	0f 90       	pop	r0
    5578:	cf 91       	pop	r28
    557a:	df 91       	pop	r29
    557c:	08 95       	ret

0000557e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    557e:	df 93       	push	r29
    5580:	cf 93       	push	r28
    5582:	cd b7       	in	r28, 0x3d	; 61
    5584:	de b7       	in	r29, 0x3e	; 62
    5586:	28 97       	sbiw	r28, 0x08	; 8
    5588:	0f b6       	in	r0, 0x3f	; 63
    558a:	f8 94       	cli
    558c:	de bf       	out	0x3e, r29	; 62
    558e:	0f be       	out	0x3f, r0	; 63
    5590:	cd bf       	out	0x3d, r28	; 61
    5592:	9c 83       	std	Y+4, r25	; 0x04
    5594:	8b 83       	std	Y+3, r24	; 0x03
    5596:	7e 83       	std	Y+6, r23	; 0x06
    5598:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    559a:	82 e2       	ldi	r24, 0x22	; 34
    559c:	90 e0       	ldi	r25, 0x00	; 0
    559e:	0e 94 28 1a 	call	0x3450	; 0x3450 <pvPortMalloc>
    55a2:	9a 83       	std	Y+2, r25	; 0x02
    55a4:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    55a6:	89 81       	ldd	r24, Y+1	; 0x01
    55a8:	9a 81       	ldd	r25, Y+2	; 0x02
    55aa:	00 97       	sbiw	r24, 0x00	; 0
    55ac:	69 f1       	breq	.+90     	; 0x5608 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    55ae:	8d 81       	ldd	r24, Y+5	; 0x05
    55b0:	9e 81       	ldd	r25, Y+6	; 0x06
    55b2:	00 97       	sbiw	r24, 0x00	; 0
    55b4:	39 f4       	brne	.+14     	; 0x55c4 <prvAllocateTCBAndStack+0x46>
    55b6:	8b 81       	ldd	r24, Y+3	; 0x03
    55b8:	9c 81       	ldd	r25, Y+4	; 0x04
    55ba:	0e 94 28 1a 	call	0x3450	; 0x3450 <pvPortMalloc>
    55be:	98 87       	std	Y+8, r25	; 0x08
    55c0:	8f 83       	std	Y+7, r24	; 0x07
    55c2:	04 c0       	rjmp	.+8      	; 0x55cc <prvAllocateTCBAndStack+0x4e>
    55c4:	8d 81       	ldd	r24, Y+5	; 0x05
    55c6:	9e 81       	ldd	r25, Y+6	; 0x06
    55c8:	98 87       	std	Y+8, r25	; 0x08
    55ca:	8f 83       	std	Y+7, r24	; 0x07
    55cc:	e9 81       	ldd	r30, Y+1	; 0x01
    55ce:	fa 81       	ldd	r31, Y+2	; 0x02
    55d0:	8f 81       	ldd	r24, Y+7	; 0x07
    55d2:	98 85       	ldd	r25, Y+8	; 0x08
    55d4:	90 8f       	std	Z+24, r25	; 0x18
    55d6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    55d8:	e9 81       	ldd	r30, Y+1	; 0x01
    55da:	fa 81       	ldd	r31, Y+2	; 0x02
    55dc:	87 89       	ldd	r24, Z+23	; 0x17
    55de:	90 8d       	ldd	r25, Z+24	; 0x18
    55e0:	00 97       	sbiw	r24, 0x00	; 0
    55e2:	39 f4       	brne	.+14     	; 0x55f2 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    55e4:	89 81       	ldd	r24, Y+1	; 0x01
    55e6:	9a 81       	ldd	r25, Y+2	; 0x02
    55e8:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vPortFree>
			pxNewTCB = NULL;
    55ec:	1a 82       	std	Y+2, r1	; 0x02
    55ee:	19 82       	std	Y+1, r1	; 0x01
    55f0:	0b c0       	rjmp	.+22     	; 0x5608 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    55f2:	e9 81       	ldd	r30, Y+1	; 0x01
    55f4:	fa 81       	ldd	r31, Y+2	; 0x02
    55f6:	87 89       	ldd	r24, Z+23	; 0x17
    55f8:	90 8d       	ldd	r25, Z+24	; 0x18
    55fa:	2b 81       	ldd	r18, Y+3	; 0x03
    55fc:	3c 81       	ldd	r19, Y+4	; 0x04
    55fe:	65 ea       	ldi	r22, 0xA5	; 165
    5600:	70 e0       	ldi	r23, 0x00	; 0
    5602:	a9 01       	movw	r20, r18
    5604:	0e 94 49 31 	call	0x6292	; 0x6292 <memset>
		}
	}

	return pxNewTCB;
    5608:	89 81       	ldd	r24, Y+1	; 0x01
    560a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    560c:	28 96       	adiw	r28, 0x08	; 8
    560e:	0f b6       	in	r0, 0x3f	; 63
    5610:	f8 94       	cli
    5612:	de bf       	out	0x3e, r29	; 62
    5614:	0f be       	out	0x3f, r0	; 63
    5616:	cd bf       	out	0x3d, r28	; 61
    5618:	cf 91       	pop	r28
    561a:	df 91       	pop	r29
    561c:	08 95       	ret

0000561e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    561e:	df 93       	push	r29
    5620:	cf 93       	push	r28
    5622:	00 d0       	rcall	.+0      	; 0x5624 <prvDeleteTCB+0x6>
    5624:	cd b7       	in	r28, 0x3d	; 61
    5626:	de b7       	in	r29, 0x3e	; 62
    5628:	9a 83       	std	Y+2, r25	; 0x02
    562a:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    562c:	e9 81       	ldd	r30, Y+1	; 0x01
    562e:	fa 81       	ldd	r31, Y+2	; 0x02
    5630:	87 89       	ldd	r24, Z+23	; 0x17
    5632:	90 8d       	ldd	r25, Z+24	; 0x18
    5634:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vPortFree>
		vPortFree( pxTCB );
    5638:	89 81       	ldd	r24, Y+1	; 0x01
    563a:	9a 81       	ldd	r25, Y+2	; 0x02
    563c:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vPortFree>
	}
    5640:	0f 90       	pop	r0
    5642:	0f 90       	pop	r0
    5644:	cf 91       	pop	r28
    5646:	df 91       	pop	r29
    5648:	08 95       	ret

0000564a <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    564a:	df 93       	push	r29
    564c:	cf 93       	push	r28
    564e:	00 d0       	rcall	.+0      	; 0x5650 <xTaskGetCurrentTaskHandle+0x6>
    5650:	cd b7       	in	r28, 0x3d	; 61
    5652:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    5654:	80 91 c4 06 	lds	r24, 0x06C4
    5658:	90 91 c5 06 	lds	r25, 0x06C5
    565c:	9a 83       	std	Y+2, r25	; 0x02
    565e:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5660:	89 81       	ldd	r24, Y+1	; 0x01
    5662:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    5664:	0f 90       	pop	r0
    5666:	0f 90       	pop	r0
    5668:	cf 91       	pop	r28
    566a:	df 91       	pop	r29
    566c:	08 95       	ret

0000566e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    566e:	df 93       	push	r29
    5670:	cf 93       	push	r28
    5672:	00 d0       	rcall	.+0      	; 0x5674 <vTaskPriorityInherit+0x6>
    5674:	00 d0       	rcall	.+0      	; 0x5676 <vTaskPriorityInherit+0x8>
    5676:	cd b7       	in	r28, 0x3d	; 61
    5678:	de b7       	in	r29, 0x3e	; 62
    567a:	9c 83       	std	Y+4, r25	; 0x04
    567c:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    567e:	8b 81       	ldd	r24, Y+3	; 0x03
    5680:	9c 81       	ldd	r25, Y+4	; 0x04
    5682:	9a 83       	std	Y+2, r25	; 0x02
    5684:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    5686:	e9 81       	ldd	r30, Y+1	; 0x01
    5688:	fa 81       	ldd	r31, Y+2	; 0x02
    568a:	96 89       	ldd	r25, Z+22	; 0x16
    568c:	e0 91 c4 06 	lds	r30, 0x06C4
    5690:	f0 91 c5 06 	lds	r31, 0x06C5
    5694:	86 89       	ldd	r24, Z+22	; 0x16
    5696:	98 17       	cp	r25, r24
    5698:	08 f0       	brcs	.+2      	; 0x569c <vTaskPriorityInherit+0x2e>
    569a:	62 c0       	rjmp	.+196    	; 0x5760 <vTaskPriorityInherit+0xf2>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    569c:	e0 91 c4 06 	lds	r30, 0x06C4
    56a0:	f0 91 c5 06 	lds	r31, 0x06C5
    56a4:	86 89       	ldd	r24, Z+22	; 0x16
    56a6:	28 2f       	mov	r18, r24
    56a8:	30 e0       	ldi	r19, 0x00	; 0
    56aa:	87 e0       	ldi	r24, 0x07	; 7
    56ac:	90 e0       	ldi	r25, 0x00	; 0
    56ae:	82 1b       	sub	r24, r18
    56b0:	93 0b       	sbc	r25, r19
    56b2:	e9 81       	ldd	r30, Y+1	; 0x01
    56b4:	fa 81       	ldd	r31, Y+2	; 0x02
    56b6:	95 87       	std	Z+13, r25	; 0x0d
    56b8:	84 87       	std	Z+12, r24	; 0x0c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    56ba:	e9 81       	ldd	r30, Y+1	; 0x01
    56bc:	fa 81       	ldd	r31, Y+2	; 0x02
    56be:	42 85       	ldd	r20, Z+10	; 0x0a
    56c0:	53 85       	ldd	r21, Z+11	; 0x0b
    56c2:	e9 81       	ldd	r30, Y+1	; 0x01
    56c4:	fa 81       	ldd	r31, Y+2	; 0x02
    56c6:	86 89       	ldd	r24, Z+22	; 0x16
    56c8:	28 2f       	mov	r18, r24
    56ca:	30 e0       	ldi	r19, 0x00	; 0
    56cc:	c9 01       	movw	r24, r18
    56ce:	88 0f       	add	r24, r24
    56d0:	99 1f       	adc	r25, r25
    56d2:	88 0f       	add	r24, r24
    56d4:	99 1f       	adc	r25, r25
    56d6:	88 0f       	add	r24, r24
    56d8:	99 1f       	adc	r25, r25
    56da:	82 0f       	add	r24, r18
    56dc:	93 1f       	adc	r25, r19
    56de:	8e 52       	subi	r24, 0x2E	; 46
    56e0:	99 4f       	sbci	r25, 0xF9	; 249
    56e2:	48 17       	cp	r20, r24
    56e4:	59 07       	cpc	r21, r25
    56e6:	a1 f5       	brne	.+104    	; 0x5750 <vTaskPriorityInherit+0xe2>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    56e8:	89 81       	ldd	r24, Y+1	; 0x01
    56ea:	9a 81       	ldd	r25, Y+2	; 0x02
    56ec:	02 96       	adiw	r24, 0x02	; 2
    56ee:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    56f2:	e0 91 c4 06 	lds	r30, 0x06C4
    56f6:	f0 91 c5 06 	lds	r31, 0x06C5
    56fa:	86 89       	ldd	r24, Z+22	; 0x16
    56fc:	e9 81       	ldd	r30, Y+1	; 0x01
    56fe:	fa 81       	ldd	r31, Y+2	; 0x02
    5700:	86 8b       	std	Z+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    5702:	e9 81       	ldd	r30, Y+1	; 0x01
    5704:	fa 81       	ldd	r31, Y+2	; 0x02
    5706:	96 89       	ldd	r25, Z+22	; 0x16
    5708:	80 91 cb 06 	lds	r24, 0x06CB
    570c:	89 17       	cp	r24, r25
    570e:	28 f4       	brcc	.+10     	; 0x571a <vTaskPriorityInherit+0xac>
    5710:	e9 81       	ldd	r30, Y+1	; 0x01
    5712:	fa 81       	ldd	r31, Y+2	; 0x02
    5714:	86 89       	ldd	r24, Z+22	; 0x16
    5716:	80 93 cb 06 	sts	0x06CB, r24
    571a:	e9 81       	ldd	r30, Y+1	; 0x01
    571c:	fa 81       	ldd	r31, Y+2	; 0x02
    571e:	86 89       	ldd	r24, Z+22	; 0x16
    5720:	28 2f       	mov	r18, r24
    5722:	30 e0       	ldi	r19, 0x00	; 0
    5724:	c9 01       	movw	r24, r18
    5726:	88 0f       	add	r24, r24
    5728:	99 1f       	adc	r25, r25
    572a:	88 0f       	add	r24, r24
    572c:	99 1f       	adc	r25, r25
    572e:	88 0f       	add	r24, r24
    5730:	99 1f       	adc	r25, r25
    5732:	82 0f       	add	r24, r18
    5734:	93 1f       	adc	r25, r19
    5736:	ac 01       	movw	r20, r24
    5738:	4e 52       	subi	r20, 0x2E	; 46
    573a:	59 4f       	sbci	r21, 0xF9	; 249
    573c:	89 81       	ldd	r24, Y+1	; 0x01
    573e:	9a 81       	ldd	r25, Y+2	; 0x02
    5740:	9c 01       	movw	r18, r24
    5742:	2e 5f       	subi	r18, 0xFE	; 254
    5744:	3f 4f       	sbci	r19, 0xFF	; 255
    5746:	ca 01       	movw	r24, r20
    5748:	b9 01       	movw	r22, r18
    574a:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>
    574e:	08 c0       	rjmp	.+16     	; 0x5760 <vTaskPriorityInherit+0xf2>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    5750:	e0 91 c4 06 	lds	r30, 0x06C4
    5754:	f0 91 c5 06 	lds	r31, 0x06C5
    5758:	86 89       	ldd	r24, Z+22	; 0x16
    575a:	e9 81       	ldd	r30, Y+1	; 0x01
    575c:	fa 81       	ldd	r31, Y+2	; 0x02
    575e:	86 8b       	std	Z+22, r24	; 0x16
			}
		}
	}
    5760:	0f 90       	pop	r0
    5762:	0f 90       	pop	r0
    5764:	0f 90       	pop	r0
    5766:	0f 90       	pop	r0
    5768:	cf 91       	pop	r28
    576a:	df 91       	pop	r29
    576c:	08 95       	ret

0000576e <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    576e:	df 93       	push	r29
    5770:	cf 93       	push	r28
    5772:	00 d0       	rcall	.+0      	; 0x5774 <vTaskPriorityDisinherit+0x6>
    5774:	00 d0       	rcall	.+0      	; 0x5776 <vTaskPriorityDisinherit+0x8>
    5776:	cd b7       	in	r28, 0x3d	; 61
    5778:	de b7       	in	r29, 0x3e	; 62
    577a:	9c 83       	std	Y+4, r25	; 0x04
    577c:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    577e:	8b 81       	ldd	r24, Y+3	; 0x03
    5780:	9c 81       	ldd	r25, Y+4	; 0x04
    5782:	9a 83       	std	Y+2, r25	; 0x02
    5784:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    5786:	8b 81       	ldd	r24, Y+3	; 0x03
    5788:	9c 81       	ldd	r25, Y+4	; 0x04
    578a:	00 97       	sbiw	r24, 0x00	; 0
    578c:	09 f4       	brne	.+2      	; 0x5790 <vTaskPriorityDisinherit+0x22>
    578e:	47 c0       	rjmp	.+142    	; 0x581e <vTaskPriorityDisinherit+0xb0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    5790:	e9 81       	ldd	r30, Y+1	; 0x01
    5792:	fa 81       	ldd	r31, Y+2	; 0x02
    5794:	96 89       	ldd	r25, Z+22	; 0x16
    5796:	e9 81       	ldd	r30, Y+1	; 0x01
    5798:	fa 81       	ldd	r31, Y+2	; 0x02
    579a:	81 a1       	ldd	r24, Z+33	; 0x21
    579c:	98 17       	cp	r25, r24
    579e:	09 f4       	brne	.+2      	; 0x57a2 <vTaskPriorityDisinherit+0x34>
    57a0:	3e c0       	rjmp	.+124    	; 0x581e <vTaskPriorityDisinherit+0xb0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    57a2:	89 81       	ldd	r24, Y+1	; 0x01
    57a4:	9a 81       	ldd	r25, Y+2	; 0x02
    57a6:	02 96       	adiw	r24, 0x02	; 2
    57a8:	0e 94 86 1b 	call	0x370c	; 0x370c <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    57ac:	e9 81       	ldd	r30, Y+1	; 0x01
    57ae:	fa 81       	ldd	r31, Y+2	; 0x02
    57b0:	81 a1       	ldd	r24, Z+33	; 0x21
    57b2:	e9 81       	ldd	r30, Y+1	; 0x01
    57b4:	fa 81       	ldd	r31, Y+2	; 0x02
    57b6:	86 8b       	std	Z+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    57b8:	e9 81       	ldd	r30, Y+1	; 0x01
    57ba:	fa 81       	ldd	r31, Y+2	; 0x02
    57bc:	86 89       	ldd	r24, Z+22	; 0x16
    57be:	28 2f       	mov	r18, r24
    57c0:	30 e0       	ldi	r19, 0x00	; 0
    57c2:	87 e0       	ldi	r24, 0x07	; 7
    57c4:	90 e0       	ldi	r25, 0x00	; 0
    57c6:	82 1b       	sub	r24, r18
    57c8:	93 0b       	sbc	r25, r19
    57ca:	e9 81       	ldd	r30, Y+1	; 0x01
    57cc:	fa 81       	ldd	r31, Y+2	; 0x02
    57ce:	95 87       	std	Z+13, r25	; 0x0d
    57d0:	84 87       	std	Z+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    57d2:	e9 81       	ldd	r30, Y+1	; 0x01
    57d4:	fa 81       	ldd	r31, Y+2	; 0x02
    57d6:	96 89       	ldd	r25, Z+22	; 0x16
    57d8:	80 91 cb 06 	lds	r24, 0x06CB
    57dc:	89 17       	cp	r24, r25
    57de:	28 f4       	brcc	.+10     	; 0x57ea <vTaskPriorityDisinherit+0x7c>
    57e0:	e9 81       	ldd	r30, Y+1	; 0x01
    57e2:	fa 81       	ldd	r31, Y+2	; 0x02
    57e4:	86 89       	ldd	r24, Z+22	; 0x16
    57e6:	80 93 cb 06 	sts	0x06CB, r24
    57ea:	e9 81       	ldd	r30, Y+1	; 0x01
    57ec:	fa 81       	ldd	r31, Y+2	; 0x02
    57ee:	86 89       	ldd	r24, Z+22	; 0x16
    57f0:	28 2f       	mov	r18, r24
    57f2:	30 e0       	ldi	r19, 0x00	; 0
    57f4:	c9 01       	movw	r24, r18
    57f6:	88 0f       	add	r24, r24
    57f8:	99 1f       	adc	r25, r25
    57fa:	88 0f       	add	r24, r24
    57fc:	99 1f       	adc	r25, r25
    57fe:	88 0f       	add	r24, r24
    5800:	99 1f       	adc	r25, r25
    5802:	82 0f       	add	r24, r18
    5804:	93 1f       	adc	r25, r19
    5806:	ac 01       	movw	r20, r24
    5808:	4e 52       	subi	r20, 0x2E	; 46
    580a:	59 4f       	sbci	r21, 0xF9	; 249
    580c:	89 81       	ldd	r24, Y+1	; 0x01
    580e:	9a 81       	ldd	r25, Y+2	; 0x02
    5810:	9c 01       	movw	r18, r24
    5812:	2e 5f       	subi	r18, 0xFE	; 254
    5814:	3f 4f       	sbci	r19, 0xFF	; 255
    5816:	ca 01       	movw	r24, r20
    5818:	b9 01       	movw	r22, r18
    581a:	0e 94 ce 1a 	call	0x359c	; 0x359c <vListInsertEnd>
			}
		}
	}
    581e:	0f 90       	pop	r0
    5820:	0f 90       	pop	r0
    5822:	0f 90       	pop	r0
    5824:	0f 90       	pop	r0
    5826:	cf 91       	pop	r28
    5828:	df 91       	pop	r29
    582a:	08 95       	ret

0000582c <main>:
void taskADC_Read(void *pv);
void task_PotCal(void *pv);
void task_TempCal(void *pv);
/*************************** Main *****************************/
int main(void)
{
    582c:	af 92       	push	r10
    582e:	bf 92       	push	r11
    5830:	cf 92       	push	r12
    5832:	df 92       	push	r13
    5834:	ef 92       	push	r14
    5836:	ff 92       	push	r15
    5838:	0f 93       	push	r16
    583a:	df 93       	push	r29
    583c:	cf 93       	push	r28
    583e:	cd b7       	in	r28, 0x3d	; 61
    5840:	de b7       	in	r29, 0x3e	; 62
	/* Modules Initialization */
	MDIO_Error_State_SetPinDirection(PIN0,MDIO_PORTC,PIN_OUTPUT);//LED1
    5842:	80 e0       	ldi	r24, 0x00	; 0
    5844:	62 e0       	ldi	r22, 0x02	; 2
    5846:	41 e0       	ldi	r20, 0x01	; 1
    5848:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN1,MDIO_PORTC,PIN_OUTPUT);//LED2
    584c:	81 e0       	ldi	r24, 0x01	; 1
    584e:	62 e0       	ldi	r22, 0x02	; 2
    5850:	41 e0       	ldi	r20, 0x01	; 1
    5852:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN2,MDIO_PORTC,PIN_OUTPUT);//LED3
    5856:	82 e0       	ldi	r24, 0x02	; 2
    5858:	62 e0       	ldi	r22, 0x02	; 2
    585a:	41 e0       	ldi	r20, 0x01	; 1
    585c:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>

	MDIO_Error_State_SetPinDirection(PIN5,MDIO_PORTC,PIN_OUTPUT); //Buzzer
    5860:	85 e0       	ldi	r24, 0x05	; 5
    5862:	62 e0       	ldi	r22, 0x02	; 2
    5864:	41 e0       	ldi	r20, 0x01	; 1
    5866:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>

	MDIO_Error_State_SetPinDirection(PIN0,MDIO_PORTD,PIN_OUTPUT);//FAN MOTOR
    586a:	80 e0       	ldi	r24, 0x00	; 0
    586c:	63 e0       	ldi	r22, 0x03	; 3
    586e:	41 e0       	ldi	r20, 0x01	; 1
    5870:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>

	MDIO_Error_State_SetPinDirection(PIN6,MDIO_PORTD,PIN_OUTPUT);//WINDOW MOTOR
    5874:	86 e0       	ldi	r24, 0x06	; 6
    5876:	63 e0       	ldi	r22, 0x03	; 3
    5878:	41 e0       	ldi	r20, 0x01	; 1
    587a:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN7,MDIO_PORTD,PIN_OUTPUT);//WINDOW MOTOR
    587e:	87 e0       	ldi	r24, 0x07	; 7
    5880:	63 e0       	ldi	r22, 0x03	; 3
    5882:	41 e0       	ldi	r20, 0x01	; 1
    5884:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>

	MDIO_Error_State_SetPinDirection(PIN0,MDIO_PORTB,PIN_OUTPUT);//DOOR MOTOR
    5888:	80 e0       	ldi	r24, 0x00	; 0
    588a:	61 e0       	ldi	r22, 0x01	; 1
    588c:	41 e0       	ldi	r20, 0x01	; 1
    588e:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN1,MDIO_PORTB,PIN_OUTPUT);//DOOR MOTOR
    5892:	81 e0       	ldi	r24, 0x01	; 1
    5894:	61 e0       	ldi	r22, 0x01	; 1
    5896:	41 e0       	ldi	r20, 0x01	; 1
    5898:	0e 94 35 08 	call	0x106a	; 0x106a <MDIO_Error_State_SetPinDirection>
		 *  3- Stack depth
		 *  4- Task parameter
		 *  5- priority
		 *  6- Task handler
	*************************************************************/
	xTaskCreate(Task_Pass,NULL,100,NULL,2,NULL);
    589c:	81 ec       	ldi	r24, 0xC1	; 193
    589e:	9c e2       	ldi	r25, 0x2C	; 44
    58a0:	60 e0       	ldi	r22, 0x00	; 0
    58a2:	70 e0       	ldi	r23, 0x00	; 0
    58a4:	44 e6       	ldi	r20, 0x64	; 100
    58a6:	50 e0       	ldi	r21, 0x00	; 0
    58a8:	20 e0       	ldi	r18, 0x00	; 0
    58aa:	30 e0       	ldi	r19, 0x00	; 0
    58ac:	02 e0       	ldi	r16, 0x02	; 2
    58ae:	ee 24       	eor	r14, r14
    58b0:	ff 24       	eor	r15, r15
    58b2:	cc 24       	eor	r12, r12
    58b4:	dd 24       	eor	r13, r13
    58b6:	aa 24       	eor	r10, r10
    58b8:	bb 24       	eor	r11, r11
    58ba:	0e 94 36 24 	call	0x486c	; 0x486c <xTaskGenericCreate>
	xTaskCreate(Task_WelcomeTap,NULL,100,NULL,2,NULL);
    58be:	8d e3       	ldi	r24, 0x3D	; 61
    58c0:	9d e2       	ldi	r25, 0x2D	; 45
    58c2:	60 e0       	ldi	r22, 0x00	; 0
    58c4:	70 e0       	ldi	r23, 0x00	; 0
    58c6:	44 e6       	ldi	r20, 0x64	; 100
    58c8:	50 e0       	ldi	r21, 0x00	; 0
    58ca:	20 e0       	ldi	r18, 0x00	; 0
    58cc:	30 e0       	ldi	r19, 0x00	; 0
    58ce:	02 e0       	ldi	r16, 0x02	; 2
    58d0:	ee 24       	eor	r14, r14
    58d2:	ff 24       	eor	r15, r15
    58d4:	cc 24       	eor	r12, r12
    58d6:	dd 24       	eor	r13, r13
    58d8:	aa 24       	eor	r10, r10
    58da:	bb 24       	eor	r11, r11
    58dc:	0e 94 36 24 	call	0x486c	; 0x486c <xTaskGenericCreate>
	xTaskCreate(Task_LCD,NULL,300,NULL,3,NULL);
    58e0:	8d e7       	ldi	r24, 0x7D	; 125
    58e2:	9d e2       	ldi	r25, 0x2D	; 45
    58e4:	60 e0       	ldi	r22, 0x00	; 0
    58e6:	70 e0       	ldi	r23, 0x00	; 0
    58e8:	4c e2       	ldi	r20, 0x2C	; 44
    58ea:	51 e0       	ldi	r21, 0x01	; 1
    58ec:	20 e0       	ldi	r18, 0x00	; 0
    58ee:	30 e0       	ldi	r19, 0x00	; 0
    58f0:	03 e0       	ldi	r16, 0x03	; 3
    58f2:	ee 24       	eor	r14, r14
    58f4:	ff 24       	eor	r15, r15
    58f6:	cc 24       	eor	r12, r12
    58f8:	dd 24       	eor	r13, r13
    58fa:	aa 24       	eor	r10, r10
    58fc:	bb 24       	eor	r11, r11
    58fe:	0e 94 36 24 	call	0x486c	; 0x486c <xTaskGenericCreate>
	xTaskCreate(taskADC_Read,NULL,100,NULL,2,NULL);
    5902:	82 e5       	ldi	r24, 0x52	; 82
    5904:	9f e2       	ldi	r25, 0x2F	; 47
    5906:	60 e0       	ldi	r22, 0x00	; 0
    5908:	70 e0       	ldi	r23, 0x00	; 0
    590a:	44 e6       	ldi	r20, 0x64	; 100
    590c:	50 e0       	ldi	r21, 0x00	; 0
    590e:	20 e0       	ldi	r18, 0x00	; 0
    5910:	30 e0       	ldi	r19, 0x00	; 0
    5912:	02 e0       	ldi	r16, 0x02	; 2
    5914:	ee 24       	eor	r14, r14
    5916:	ff 24       	eor	r15, r15
    5918:	cc 24       	eor	r12, r12
    591a:	dd 24       	eor	r13, r13
    591c:	aa 24       	eor	r10, r10
    591e:	bb 24       	eor	r11, r11
    5920:	0e 94 36 24 	call	0x486c	; 0x486c <xTaskGenericCreate>
	xTaskCreate(task_PotCal,NULL,100,NULL,2,NULL);
    5924:	8d e8       	ldi	r24, 0x8D	; 141
    5926:	9f e2       	ldi	r25, 0x2F	; 47
    5928:	60 e0       	ldi	r22, 0x00	; 0
    592a:	70 e0       	ldi	r23, 0x00	; 0
    592c:	44 e6       	ldi	r20, 0x64	; 100
    592e:	50 e0       	ldi	r21, 0x00	; 0
    5930:	20 e0       	ldi	r18, 0x00	; 0
    5932:	30 e0       	ldi	r19, 0x00	; 0
    5934:	02 e0       	ldi	r16, 0x02	; 2
    5936:	ee 24       	eor	r14, r14
    5938:	ff 24       	eor	r15, r15
    593a:	cc 24       	eor	r12, r12
    593c:	dd 24       	eor	r13, r13
    593e:	aa 24       	eor	r10, r10
    5940:	bb 24       	eor	r11, r11
    5942:	0e 94 36 24 	call	0x486c	; 0x486c <xTaskGenericCreate>
	xTaskCreate(task_TempCal,NULL,100,NULL,2,NULL);
    5946:	8a e3       	ldi	r24, 0x3A	; 58
    5948:	90 e3       	ldi	r25, 0x30	; 48
    594a:	60 e0       	ldi	r22, 0x00	; 0
    594c:	70 e0       	ldi	r23, 0x00	; 0
    594e:	44 e6       	ldi	r20, 0x64	; 100
    5950:	50 e0       	ldi	r21, 0x00	; 0
    5952:	20 e0       	ldi	r18, 0x00	; 0
    5954:	30 e0       	ldi	r19, 0x00	; 0
    5956:	02 e0       	ldi	r16, 0x02	; 2
    5958:	ee 24       	eor	r14, r14
    595a:	ff 24       	eor	r15, r15
    595c:	cc 24       	eor	r12, r12
    595e:	dd 24       	eor	r13, r13
    5960:	aa 24       	eor	r10, r10
    5962:	bb 24       	eor	r11, r11
    5964:	0e 94 36 24 	call	0x486c	; 0x486c <xTaskGenericCreate>
	 * Init Peripherals
	 *  1- LCD Init
	 *  2- Keypad Init
	 *  3- ADC Init
	 ***********************************************/
	HCLCD_Vid4Bits_Init();
    5968:	0e 94 b1 13 	call	0x2762	; 0x2762 <HCLCD_Vid4Bits_Init>
	HKPD_VidInit();
    596c:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <HKPD_VidInit>
	MADC_VidInit();
    5970:	0e 94 1d 0c 	call	0x183a	; 0x183a <MADC_VidInit>

	/* Start ADC */
	MADC_u16ADC_StartConversion_With_Interrupt(CHANNEL_Num);
    5974:	80 91 49 07 	lds	r24, 0x0749
    5978:	0e 94 8e 0c 	call	0x191c	; 0x191c <MADC_u16ADC_StartConversion_With_Interrupt>

	/* call the scheduler */
	vTaskStartScheduler();
    597c:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <vTaskStartScheduler>
    5980:	ff cf       	rjmp	.-2      	; 0x5980 <main+0x154>

00005982 <Task_Pass>:
 *  1-Take Password
 *  2-Check Password
 *
 **************************************************************/
void Task_Pass(void*pv)
{
    5982:	df 93       	push	r29
    5984:	cf 93       	push	r28
    5986:	00 d0       	rcall	.+0      	; 0x5988 <Task_Pass+0x6>
    5988:	00 d0       	rcall	.+0      	; 0x598a <Task_Pass+0x8>
    598a:	cd b7       	in	r28, 0x3d	; 61
    598c:	de b7       	in	r29, 0x3e	; 62
    598e:	9c 83       	std	Y+4, r25	; 0x04
    5990:	8b 83       	std	Y+3, r24	; 0x03
	while (1)
	{
		if( Flag == 0 && SW_flag == 0)
    5992:	80 91 51 07 	lds	r24, 0x0751
    5996:	88 23       	and	r24, r24
    5998:	09 f0       	breq	.+2      	; 0x599c <Task_Pass+0x1a>
    599a:	6a c0       	rjmp	.+212    	; 0x5a70 <Task_Pass+0xee>
    599c:	80 91 4b 07 	lds	r24, 0x074B
    59a0:	88 23       	and	r24, r24
    59a2:	09 f0       	breq	.+2      	; 0x59a6 <Task_Pass+0x24>
    59a4:	65 c0       	rjmp	.+202    	; 0x5a70 <Task_Pass+0xee>
		{
			static u8 Local_u8counterpassword = 0;
			u8 check = 0 ;
    59a6:	1a 82       	std	Y+2, r1	; 0x02
			u8 Local_u8KeyPressed = NOT_PRESSEDD;
    59a8:	8f e2       	ldi	r24, 0x2F	; 47
    59aa:	89 83       	std	Y+1, r24	; 0x01
			Local_u8KeyPressed = HKPD_U8GetKeyPressed() ;
    59ac:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <HKPD_U8GetKeyPressed>
    59b0:	89 83       	std	Y+1, r24	; 0x01

			if (Local_u8KeyPressed != NOT_PRESSEDD) // NOT_PRESSED = '/'
    59b2:	89 81       	ldd	r24, Y+1	; 0x01
    59b4:	8f 32       	cpi	r24, 0x2F	; 47
    59b6:	09 f4       	brne	.+2      	; 0x59ba <Task_Pass+0x38>
    59b8:	5b c0       	rjmp	.+182    	; 0x5a70 <Task_Pass+0xee>
			{
				if (Local_u8KeyPressed >='0' && Local_u8KeyPressed <='9') //enter password
    59ba:	89 81       	ldd	r24, Y+1	; 0x01
    59bc:	80 33       	cpi	r24, 0x30	; 48
    59be:	d0 f0       	brcs	.+52     	; 0x59f4 <Task_Pass+0x72>
    59c0:	89 81       	ldd	r24, Y+1	; 0x01
    59c2:	8a 33       	cpi	r24, 0x3A	; 58
    59c4:	b8 f4       	brcc	.+46     	; 0x59f4 <Task_Pass+0x72>
				{
					enter_password[Local_u8counterpassword] = Local_u8KeyPressed;
    59c6:	80 91 53 07 	lds	r24, 0x0753
    59ca:	88 2f       	mov	r24, r24
    59cc:	90 e0       	ldi	r25, 0x00	; 0
    59ce:	fc 01       	movw	r30, r24
    59d0:	e4 5b       	subi	r30, 0xB4	; 180
    59d2:	f8 4f       	sbci	r31, 0xF8	; 248
    59d4:	89 81       	ldd	r24, Y+1	; 0x01
    59d6:	80 83       	st	Z, r24
					Local_u8counterpassword++;
    59d8:	80 91 53 07 	lds	r24, 0x0753
    59dc:	8f 5f       	subi	r24, 0xFF	; 255
    59de:	80 93 53 07 	sts	0x0753, r24
					MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTC,PIN_HIGH);//led
    59e2:	80 e0       	ldi	r24, 0x00	; 0
    59e4:	62 e0       	ldi	r22, 0x02	; 2
    59e6:	41 e0       	ldi	r20, 0x01	; 1
    59e8:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
					SW_flag = 1;
    59ec:	81 e0       	ldi	r24, 0x01	; 1
    59ee:	80 93 4b 07 	sts	0x074B, r24
    59f2:	3c c0       	rjmp	.+120    	; 0x5a6c <Task_Pass+0xea>
				}

				else if('#' == Local_u8KeyPressed)  //Check Password
    59f4:	89 81       	ldd	r24, Y+1	; 0x01
    59f6:	83 32       	cpi	r24, 0x23	; 35
    59f8:	c9 f5       	brne	.+114    	; 0x5a6c <Task_Pass+0xea>
				{
					i = 0;
    59fa:	10 92 4a 07 	sts	0x074A, r1
					for(Local_u8counterpassword=0;Local_u8counterpassword<2;Local_u8counterpassword++)
    59fe:	10 92 53 07 	sts	0x0753, r1
    5a02:	19 c0       	rjmp	.+50     	; 0x5a36 <Task_Pass+0xb4>
					{
						if (enter_password[Local_u8counterpassword]	!= password[Local_u8counterpassword])
    5a04:	80 91 53 07 	lds	r24, 0x0753
    5a08:	88 2f       	mov	r24, r24
    5a0a:	90 e0       	ldi	r25, 0x00	; 0
    5a0c:	fc 01       	movw	r30, r24
    5a0e:	e4 5b       	subi	r30, 0xB4	; 180
    5a10:	f8 4f       	sbci	r31, 0xF8	; 248
    5a12:	20 81       	ld	r18, Z
    5a14:	80 91 53 07 	lds	r24, 0x0753
    5a18:	88 2f       	mov	r24, r24
    5a1a:	90 e0       	ldi	r25, 0x00	; 0
    5a1c:	fc 01       	movw	r30, r24
    5a1e:	eb 53       	subi	r30, 0x3B	; 59
    5a20:	fe 4f       	sbci	r31, 0xFE	; 254
    5a22:	80 81       	ld	r24, Z
    5a24:	28 17       	cp	r18, r24
    5a26:	11 f0       	breq	.+4      	; 0x5a2c <Task_Pass+0xaa>
						{check=1 ; }
    5a28:	81 e0       	ldi	r24, 0x01	; 1
    5a2a:	8a 83       	std	Y+2, r24	; 0x02
				}

				else if('#' == Local_u8KeyPressed)  //Check Password
				{
					i = 0;
					for(Local_u8counterpassword=0;Local_u8counterpassword<2;Local_u8counterpassword++)
    5a2c:	80 91 53 07 	lds	r24, 0x0753
    5a30:	8f 5f       	subi	r24, 0xFF	; 255
    5a32:	80 93 53 07 	sts	0x0753, r24
    5a36:	80 91 53 07 	lds	r24, 0x0753
    5a3a:	82 30       	cpi	r24, 0x02	; 2
    5a3c:	18 f3       	brcs	.-58     	; 0x5a04 <Task_Pass+0x82>
					{
						if (enter_password[Local_u8counterpassword]	!= password[Local_u8counterpassword])
						{check=1 ; }
					}
					Local_u8counterpassword = 0 ;
    5a3e:	10 92 53 07 	sts	0x0753, r1

					if( check == 0) 			//right password
    5a42:	8a 81       	ldd	r24, Y+2	; 0x02
    5a44:	88 23       	and	r24, r24
    5a46:	49 f4       	brne	.+18     	; 0x5a5a <Task_Pass+0xd8>
					{
						wrongInputRemain = 2 ;
    5a48:	82 e0       	ldi	r24, 0x02	; 2
    5a4a:	80 93 c4 01 	sts	0x01C4, r24
						Clear = 0;
    5a4e:	10 92 52 07 	sts	0x0752, r1
						Flag = 1 ;
    5a52:	81 e0       	ldi	r24, 0x01	; 1
    5a54:	80 93 51 07 	sts	0x0751, r24
    5a58:	09 c0       	rjmp	.+18     	; 0x5a6c <Task_Pass+0xea>
					}
					else if( check != 0)		//wrong password
    5a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    5a5c:	88 23       	and	r24, r24
    5a5e:	31 f0       	breq	.+12     	; 0x5a6c <Task_Pass+0xea>
					{
						check = 0 ;
    5a60:	1a 82       	std	Y+2, r1	; 0x02
						Clear = 0;
    5a62:	10 92 52 07 	sts	0x0752, r1
						Flag = 2 ;
    5a66:	82 e0       	ldi	r24, 0x02	; 2
    5a68:	80 93 51 07 	sts	0x0751, r24
					}

				}
				Local_u8KeyPressed = NOT_PRESSEDD ;
    5a6c:	8f e2       	ldi	r24, 0x2F	; 47
    5a6e:	89 83       	std	Y+1, r24	; 0x01
			}
		}
		vTaskDelay(10);
    5a70:	8a e0       	ldi	r24, 0x0A	; 10
    5a72:	90 e0       	ldi	r25, 0x00	; 0
    5a74:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
    5a78:	8c cf       	rjmp	.-232    	; 0x5992 <Task_Pass+0x10>

00005a7a <Task_WelcomeTap>:
/**************************** WelcomeTap  Function ***********************************
 *  Task_WelcomeTap
 * 1- if Password is Right -->  Flag = 1 -->  open door (Motor ON and Led ON)
 *************************************************************************************/
void Task_WelcomeTap(void*pv)
{
    5a7a:	df 93       	push	r29
    5a7c:	cf 93       	push	r28
    5a7e:	00 d0       	rcall	.+0      	; 0x5a80 <Task_WelcomeTap+0x6>
    5a80:	cd b7       	in	r28, 0x3d	; 61
    5a82:	de b7       	in	r29, 0x3e	; 62
    5a84:	9a 83       	std	Y+2, r25	; 0x02
    5a86:	89 83       	std	Y+1, r24	; 0x01
	static u8 FLAG1 = 1 ;
	while (1)
	{
		if ( Flag == 1 )
    5a88:	80 91 51 07 	lds	r24, 0x0751
    5a8c:	81 30       	cpi	r24, 0x01	; 1
    5a8e:	81 f5       	brne	.+96     	; 0x5af0 <Task_WelcomeTap+0x76>
		{
			/********Right password Open door and Light*********/
			if(FLAG1 == 1)
    5a90:	80 91 c7 01 	lds	r24, 0x01C7
    5a94:	81 30       	cpi	r24, 0x01	; 1
    5a96:	61 f5       	brne	.+88     	; 0x5af0 <Task_WelcomeTap+0x76>
			{
				MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTC,PIN_HIGH);//Open led door (motor)
    5a98:	80 e0       	ldi	r24, 0x00	; 0
    5a9a:	62 e0       	ldi	r22, 0x02	; 2
    5a9c:	41 e0       	ldi	r20, 0x01	; 1
    5a9e:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTB,PIN_HIGH);//MOTOR OPEN DOOR
    5aa2:	80 e0       	ldi	r24, 0x00	; 0
    5aa4:	61 e0       	ldi	r22, 0x01	; 1
    5aa6:	41 e0       	ldi	r20, 0x01	; 1
    5aa8:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				vTaskDelay(600);
    5aac:	88 e5       	ldi	r24, 0x58	; 88
    5aae:	92 e0       	ldi	r25, 0x02	; 2
    5ab0:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
				MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTB,PIN_LOW);//MOTOR CLOSE DOOR
    5ab4:	80 e0       	ldi	r24, 0x00	; 0
    5ab6:	61 e0       	ldi	r22, 0x01	; 1
    5ab8:	40 e0       	ldi	r20, 0x00	; 0
    5aba:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				vTaskDelay(300);
    5abe:	8c e2       	ldi	r24, 0x2C	; 44
    5ac0:	91 e0       	ldi	r25, 0x01	; 1
    5ac2:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
				MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTC,PIN_HIGH);//Open led door (motor)
    5ac6:	80 e0       	ldi	r24, 0x00	; 0
    5ac8:	62 e0       	ldi	r22, 0x02	; 2
    5aca:	41 e0       	ldi	r20, 0x01	; 1
    5acc:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				vTaskDelay(600);
    5ad0:	88 e5       	ldi	r24, 0x58	; 88
    5ad2:	92 e0       	ldi	r25, 0x02	; 2
    5ad4:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
				MDIO_Error_State_SetPinValue(PIN1,MDIO_PORTB,PIN_LOW);//STOP MOTOR
    5ad8:	81 e0       	ldi	r24, 0x01	; 1
    5ada:	61 e0       	ldi	r22, 0x01	; 1
    5adc:	40 e0       	ldi	r20, 0x00	; 0
    5ade:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTC,PIN_LOW);//Open led door (motor)
    5ae2:	80 e0       	ldi	r24, 0x00	; 0
    5ae4:	62 e0       	ldi	r22, 0x02	; 2
    5ae6:	40 e0       	ldi	r20, 0x00	; 0
    5ae8:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				FLAG1 = 0;
    5aec:	10 92 c7 01 	sts	0x01C7, r1
			}
		}
		vTaskDelay(200);
    5af0:	88 ec       	ldi	r24, 0xC8	; 200
    5af2:	90 e0       	ldi	r25, 0x00	; 0
    5af4:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
    5af8:	c7 cf       	rjmp	.-114    	; 0x5a88 <Task_WelcomeTap+0xe>

00005afa <Task_LCD>:
	 * IF Password Right -->  Flag = 1 -> Display D Open , Temp = ... C , Gas = ... G , Secured
	 * IF password Wrong -->  Flag = 2 -> Display no.Tries , Then Calling Ploice  , Buzzer ON , Unsecured
	 *
 ****************************************************************************/
void Task_LCD(void*pv)
{
    5afa:	df 93       	push	r29
    5afc:	cf 93       	push	r28
    5afe:	cd b7       	in	r28, 0x3d	; 61
    5b00:	de b7       	in	r29, 0x3e	; 62
    5b02:	c3 54       	subi	r28, 0x43	; 67
    5b04:	d0 40       	sbci	r29, 0x00	; 0
    5b06:	0f b6       	in	r0, 0x3f	; 63
    5b08:	f8 94       	cli
    5b0a:	de bf       	out	0x3e, r29	; 62
    5b0c:	0f be       	out	0x3f, r0	; 63
    5b0e:	cd bf       	out	0x3d, r28	; 61
    5b10:	9a a7       	std	Y+42, r25	; 0x2a
    5b12:	89 a7       	std	Y+41, r24	; 0x29
	while (1)
	{
		if ( Flag == 0 )
    5b14:	80 91 51 07 	lds	r24, 0x0751
    5b18:	88 23       	and	r24, r24
    5b1a:	09 f0       	breq	.+2      	; 0x5b1e <Task_LCD+0x24>
    5b1c:	57 c0       	rjmp	.+174    	; 0x5bcc <Task_LCD+0xd2>
		{
			if ( Clear == 0 )
    5b1e:	80 91 52 07 	lds	r24, 0x0752
    5b22:	88 23       	and	r24, r24
    5b24:	31 f4       	brne	.+12     	; 0x5b32 <Task_LCD+0x38>
			{HCLCD_VidWriteCommand_4Bits(0x01>>4);
    5b26:	80 e0       	ldi	r24, 0x00	; 0
    5b28:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
			HCLCD_VidWriteCommand_4Bits(0x01);}
    5b2c:	81 e0       	ldi	r24, 0x01	; 1
    5b2e:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
			Clear = 1;
    5b32:	81 e0       	ldi	r24, 0x01	; 1
    5b34:	80 93 52 07 	sts	0x0752, r24
			u8 string1[]={"Enter Password"};
    5b38:	ce 01       	movw	r24, r28
    5b3a:	01 96       	adiw	r24, 0x01	; 1
    5b3c:	9c a7       	std	Y+44, r25	; 0x2c
    5b3e:	8b a7       	std	Y+43, r24	; 0x2b
    5b40:	e2 e9       	ldi	r30, 0x92	; 146
    5b42:	f0 e0       	ldi	r31, 0x00	; 0
    5b44:	fe a7       	std	Y+46, r31	; 0x2e
    5b46:	ed a7       	std	Y+45, r30	; 0x2d
    5b48:	ff e0       	ldi	r31, 0x0F	; 15
    5b4a:	ff a7       	std	Y+47, r31	; 0x2f
    5b4c:	ed a5       	ldd	r30, Y+45	; 0x2d
    5b4e:	fe a5       	ldd	r31, Y+46	; 0x2e
    5b50:	00 80       	ld	r0, Z
    5b52:	8d a5       	ldd	r24, Y+45	; 0x2d
    5b54:	9e a5       	ldd	r25, Y+46	; 0x2e
    5b56:	01 96       	adiw	r24, 0x01	; 1
    5b58:	9e a7       	std	Y+46, r25	; 0x2e
    5b5a:	8d a7       	std	Y+45, r24	; 0x2d
    5b5c:	eb a5       	ldd	r30, Y+43	; 0x2b
    5b5e:	fc a5       	ldd	r31, Y+44	; 0x2c
    5b60:	00 82       	st	Z, r0
    5b62:	8b a5       	ldd	r24, Y+43	; 0x2b
    5b64:	9c a5       	ldd	r25, Y+44	; 0x2c
    5b66:	01 96       	adiw	r24, 0x01	; 1
    5b68:	9c a7       	std	Y+44, r25	; 0x2c
    5b6a:	8b a7       	std	Y+43, r24	; 0x2b
    5b6c:	9f a5       	ldd	r25, Y+47	; 0x2f
    5b6e:	91 50       	subi	r25, 0x01	; 1
    5b70:	9f a7       	std	Y+47, r25	; 0x2f
    5b72:	ef a5       	ldd	r30, Y+47	; 0x2f
    5b74:	ee 23       	and	r30, r30
    5b76:	51 f7       	brne	.-44     	; 0x5b4c <Task_LCD+0x52>
			HCLCD_VidSetPosition_4BitsMode(1, 0);
    5b78:	81 e0       	ldi	r24, 0x01	; 1
    5b7a:	60 e0       	ldi	r22, 0x00	; 0
    5b7c:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits(string1);
    5b80:	ce 01       	movw	r24, r28
    5b82:	01 96       	adiw	r24, 0x01	; 1
    5b84:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>
			vTaskDelay(50);
    5b88:	82 e3       	ldi	r24, 0x32	; 50
    5b8a:	90 e0       	ldi	r25, 0x00	; 0
    5b8c:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
			if (SW_flag==1) //enter password
    5b90:	80 91 4b 07 	lds	r24, 0x074B
    5b94:	81 30       	cpi	r24, 0x01	; 1
    5b96:	b1 f4       	brne	.+44     	; 0x5bc4 <Task_LCD+0xca>
			{

			HCLCD_VidSetPosition_4BitsMode(2, i);
    5b98:	90 91 4a 07 	lds	r25, 0x074A
    5b9c:	82 e0       	ldi	r24, 0x02	; 2
    5b9e:	69 2f       	mov	r22, r25
    5ba0:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits((u8*)"*");
    5ba4:	85 e6       	ldi	r24, 0x65	; 101
    5ba6:	90 e0       	ldi	r25, 0x00	; 0
    5ba8:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>
			i++;
    5bac:	80 91 4a 07 	lds	r24, 0x074A
    5bb0:	8f 5f       	subi	r24, 0xFF	; 255
    5bb2:	80 93 4a 07 	sts	0x074A, r24
			MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTC,PIN_LOW);//led
    5bb6:	80 e0       	ldi	r24, 0x00	; 0
    5bb8:	62 e0       	ldi	r22, 0x02	; 2
    5bba:	40 e0       	ldi	r20, 0x00	; 0
    5bbc:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
			SW_flag = 0;
    5bc0:	10 92 4b 07 	sts	0x074B, r1
			}
			vTaskDelay(30);
    5bc4:	8e e1       	ldi	r24, 0x1E	; 30
    5bc6:	90 e0       	ldi	r25, 0x00	; 0
    5bc8:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
		}

		if ( Flag == 1 )
    5bcc:	80 91 51 07 	lds	r24, 0x0751
    5bd0:	81 30       	cpi	r24, 0x01	; 1
    5bd2:	09 f0       	breq	.+2      	; 0x5bd6 <Task_LCD+0xdc>
    5bd4:	15 c1       	rjmp	.+554    	; 0x5e00 <Task_LCD+0x306>
		{
			if ( Clear == 0 )
    5bd6:	80 91 52 07 	lds	r24, 0x0752
    5bda:	88 23       	and	r24, r24
    5bdc:	31 f4       	brne	.+12     	; 0x5bea <Task_LCD+0xf0>
			{HCLCD_VidWriteCommand_4Bits(0x01>>4);
    5bde:	80 e0       	ldi	r24, 0x00	; 0
    5be0:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
			HCLCD_VidWriteCommand_4Bits(0x01);}
    5be4:	81 e0       	ldi	r24, 0x01	; 1
    5be6:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
			Clear = 1;
    5bea:	81 e0       	ldi	r24, 0x01	; 1
    5bec:	80 93 52 07 	sts	0x0752, r24
			u8 string1[]={"D  Open"};
    5bf0:	ce 01       	movw	r24, r28
    5bf2:	40 96       	adiw	r24, 0x10	; 16
    5bf4:	99 ab       	std	Y+49, r25	; 0x31
    5bf6:	88 ab       	std	Y+48, r24	; 0x30
    5bf8:	e1 ea       	ldi	r30, 0xA1	; 161
    5bfa:	f0 e0       	ldi	r31, 0x00	; 0
    5bfc:	fb ab       	std	Y+51, r31	; 0x33
    5bfe:	ea ab       	std	Y+50, r30	; 0x32
    5c00:	f8 e0       	ldi	r31, 0x08	; 8
    5c02:	fc ab       	std	Y+52, r31	; 0x34
    5c04:	ea a9       	ldd	r30, Y+50	; 0x32
    5c06:	fb a9       	ldd	r31, Y+51	; 0x33
    5c08:	00 80       	ld	r0, Z
    5c0a:	8a a9       	ldd	r24, Y+50	; 0x32
    5c0c:	9b a9       	ldd	r25, Y+51	; 0x33
    5c0e:	01 96       	adiw	r24, 0x01	; 1
    5c10:	9b ab       	std	Y+51, r25	; 0x33
    5c12:	8a ab       	std	Y+50, r24	; 0x32
    5c14:	e8 a9       	ldd	r30, Y+48	; 0x30
    5c16:	f9 a9       	ldd	r31, Y+49	; 0x31
    5c18:	00 82       	st	Z, r0
    5c1a:	88 a9       	ldd	r24, Y+48	; 0x30
    5c1c:	99 a9       	ldd	r25, Y+49	; 0x31
    5c1e:	01 96       	adiw	r24, 0x01	; 1
    5c20:	99 ab       	std	Y+49, r25	; 0x31
    5c22:	88 ab       	std	Y+48, r24	; 0x30
    5c24:	9c a9       	ldd	r25, Y+52	; 0x34
    5c26:	91 50       	subi	r25, 0x01	; 1
    5c28:	9c ab       	std	Y+52, r25	; 0x34
    5c2a:	ec a9       	ldd	r30, Y+52	; 0x34
    5c2c:	ee 23       	and	r30, r30
    5c2e:	51 f7       	brne	.-44     	; 0x5c04 <Task_LCD+0x10a>
			u8 string2[]={"V="};
    5c30:	ce 01       	movw	r24, r28
    5c32:	48 96       	adiw	r24, 0x18	; 24
    5c34:	9e ab       	std	Y+54, r25	; 0x36
    5c36:	8d ab       	std	Y+53, r24	; 0x35
    5c38:	e9 ea       	ldi	r30, 0xA9	; 169
    5c3a:	f0 e0       	ldi	r31, 0x00	; 0
    5c3c:	f8 af       	std	Y+56, r31	; 0x38
    5c3e:	ef ab       	std	Y+55, r30	; 0x37
    5c40:	f3 e0       	ldi	r31, 0x03	; 3
    5c42:	f9 af       	std	Y+57, r31	; 0x39
    5c44:	ef a9       	ldd	r30, Y+55	; 0x37
    5c46:	f8 ad       	ldd	r31, Y+56	; 0x38
    5c48:	00 80       	ld	r0, Z
    5c4a:	8f a9       	ldd	r24, Y+55	; 0x37
    5c4c:	98 ad       	ldd	r25, Y+56	; 0x38
    5c4e:	01 96       	adiw	r24, 0x01	; 1
    5c50:	98 af       	std	Y+56, r25	; 0x38
    5c52:	8f ab       	std	Y+55, r24	; 0x37
    5c54:	ed a9       	ldd	r30, Y+53	; 0x35
    5c56:	fe a9       	ldd	r31, Y+54	; 0x36
    5c58:	00 82       	st	Z, r0
    5c5a:	8d a9       	ldd	r24, Y+53	; 0x35
    5c5c:	9e a9       	ldd	r25, Y+54	; 0x36
    5c5e:	01 96       	adiw	r24, 0x01	; 1
    5c60:	9e ab       	std	Y+54, r25	; 0x36
    5c62:	8d ab       	std	Y+53, r24	; 0x35
    5c64:	99 ad       	ldd	r25, Y+57	; 0x39
    5c66:	91 50       	subi	r25, 0x01	; 1
    5c68:	99 af       	std	Y+57, r25	; 0x39
    5c6a:	e9 ad       	ldd	r30, Y+57	; 0x39
    5c6c:	ee 23       	and	r30, r30
    5c6e:	51 f7       	brne	.-44     	; 0x5c44 <Task_LCD+0x14a>
			u8 string3[]={"Secured   "};
    5c70:	ce 01       	movw	r24, r28
    5c72:	4b 96       	adiw	r24, 0x1b	; 27
    5c74:	9b af       	std	Y+59, r25	; 0x3b
    5c76:	8a af       	std	Y+58, r24	; 0x3a
    5c78:	ec ea       	ldi	r30, 0xAC	; 172
    5c7a:	f0 e0       	ldi	r31, 0x00	; 0
    5c7c:	fd af       	std	Y+61, r31	; 0x3d
    5c7e:	ec af       	std	Y+60, r30	; 0x3c
    5c80:	fb e0       	ldi	r31, 0x0B	; 11
    5c82:	fe af       	std	Y+62, r31	; 0x3e
    5c84:	ec ad       	ldd	r30, Y+60	; 0x3c
    5c86:	fd ad       	ldd	r31, Y+61	; 0x3d
    5c88:	00 80       	ld	r0, Z
    5c8a:	8c ad       	ldd	r24, Y+60	; 0x3c
    5c8c:	9d ad       	ldd	r25, Y+61	; 0x3d
    5c8e:	01 96       	adiw	r24, 0x01	; 1
    5c90:	9d af       	std	Y+61, r25	; 0x3d
    5c92:	8c af       	std	Y+60, r24	; 0x3c
    5c94:	ea ad       	ldd	r30, Y+58	; 0x3a
    5c96:	fb ad       	ldd	r31, Y+59	; 0x3b
    5c98:	00 82       	st	Z, r0
    5c9a:	8a ad       	ldd	r24, Y+58	; 0x3a
    5c9c:	9b ad       	ldd	r25, Y+59	; 0x3b
    5c9e:	01 96       	adiw	r24, 0x01	; 1
    5ca0:	9b af       	std	Y+59, r25	; 0x3b
    5ca2:	8a af       	std	Y+58, r24	; 0x3a
    5ca4:	9e ad       	ldd	r25, Y+62	; 0x3e
    5ca6:	91 50       	subi	r25, 0x01	; 1
    5ca8:	9e af       	std	Y+62, r25	; 0x3e
    5caa:	ee ad       	ldd	r30, Y+62	; 0x3e
    5cac:	ee 23       	and	r30, r30
    5cae:	51 f7       	brne	.-44     	; 0x5c84 <Task_LCD+0x18a>
			u8 string4[]={"T="};
    5cb0:	ce 01       	movw	r24, r28
    5cb2:	86 96       	adiw	r24, 0x26	; 38
    5cb4:	21 96       	adiw	r28, 0x01	; 1
    5cb6:	9f af       	std	Y+63, r25	; 0x3f
    5cb8:	8e af       	std	Y+62, r24	; 0x3e
    5cba:	21 97       	sbiw	r28, 0x01	; 1
    5cbc:	e7 eb       	ldi	r30, 0xB7	; 183
    5cbe:	f0 e0       	ldi	r31, 0x00	; 0
    5cc0:	23 96       	adiw	r28, 0x03	; 3
    5cc2:	ff af       	std	Y+63, r31	; 0x3f
    5cc4:	ee af       	std	Y+62, r30	; 0x3e
    5cc6:	23 97       	sbiw	r28, 0x03	; 3
    5cc8:	f3 e0       	ldi	r31, 0x03	; 3
    5cca:	24 96       	adiw	r28, 0x04	; 4
    5ccc:	ff af       	std	Y+63, r31	; 0x3f
    5cce:	24 97       	sbiw	r28, 0x04	; 4
    5cd0:	23 96       	adiw	r28, 0x03	; 3
    5cd2:	ee ad       	ldd	r30, Y+62	; 0x3e
    5cd4:	ff ad       	ldd	r31, Y+63	; 0x3f
    5cd6:	23 97       	sbiw	r28, 0x03	; 3
    5cd8:	00 80       	ld	r0, Z
    5cda:	23 96       	adiw	r28, 0x03	; 3
    5cdc:	8e ad       	ldd	r24, Y+62	; 0x3e
    5cde:	9f ad       	ldd	r25, Y+63	; 0x3f
    5ce0:	23 97       	sbiw	r28, 0x03	; 3
    5ce2:	01 96       	adiw	r24, 0x01	; 1
    5ce4:	23 96       	adiw	r28, 0x03	; 3
    5ce6:	9f af       	std	Y+63, r25	; 0x3f
    5ce8:	8e af       	std	Y+62, r24	; 0x3e
    5cea:	23 97       	sbiw	r28, 0x03	; 3
    5cec:	21 96       	adiw	r28, 0x01	; 1
    5cee:	ee ad       	ldd	r30, Y+62	; 0x3e
    5cf0:	ff ad       	ldd	r31, Y+63	; 0x3f
    5cf2:	21 97       	sbiw	r28, 0x01	; 1
    5cf4:	00 82       	st	Z, r0
    5cf6:	21 96       	adiw	r28, 0x01	; 1
    5cf8:	8e ad       	ldd	r24, Y+62	; 0x3e
    5cfa:	9f ad       	ldd	r25, Y+63	; 0x3f
    5cfc:	21 97       	sbiw	r28, 0x01	; 1
    5cfe:	01 96       	adiw	r24, 0x01	; 1
    5d00:	21 96       	adiw	r28, 0x01	; 1
    5d02:	9f af       	std	Y+63, r25	; 0x3f
    5d04:	8e af       	std	Y+62, r24	; 0x3e
    5d06:	21 97       	sbiw	r28, 0x01	; 1
    5d08:	24 96       	adiw	r28, 0x04	; 4
    5d0a:	9f ad       	ldd	r25, Y+63	; 0x3f
    5d0c:	24 97       	sbiw	r28, 0x04	; 4
    5d0e:	91 50       	subi	r25, 0x01	; 1
    5d10:	24 96       	adiw	r28, 0x04	; 4
    5d12:	9f af       	std	Y+63, r25	; 0x3f
    5d14:	24 97       	sbiw	r28, 0x04	; 4
    5d16:	24 96       	adiw	r28, 0x04	; 4
    5d18:	ef ad       	ldd	r30, Y+63	; 0x3f
    5d1a:	24 97       	sbiw	r28, 0x04	; 4
    5d1c:	ee 23       	and	r30, r30
    5d1e:	c1 f6       	brne	.-80     	; 0x5cd0 <Task_LCD+0x1d6>

			HCLCD_VidSetPosition_4BitsMode(1, 0);
    5d20:	81 e0       	ldi	r24, 0x01	; 1
    5d22:	60 e0       	ldi	r22, 0x00	; 0
    5d24:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits(string1);
    5d28:	ce 01       	movw	r24, r28
    5d2a:	40 96       	adiw	r24, 0x10	; 16
    5d2c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>

			HCLCD_VidSetPosition_4BitsMode(1, 8);
    5d30:	81 e0       	ldi	r24, 0x01	; 1
    5d32:	68 e0       	ldi	r22, 0x08	; 8
    5d34:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits(string2);
    5d38:	ce 01       	movw	r24, r28
    5d3a:	48 96       	adiw	r24, 0x18	; 24
    5d3c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>

			HCLCD_VidSetPosition_4BitsMode(1,15);
    5d40:	81 e0       	ldi	r24, 0x01	; 1
    5d42:	6f e0       	ldi	r22, 0x0F	; 15
    5d44:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits((u8*)"G");
    5d48:	87 e6       	ldi	r24, 0x67	; 103
    5d4a:	90 e0       	ldi	r25, 0x00	; 0
    5d4c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>

			HCLCD_VidSetPosition_4BitsMode(2, 0);
    5d50:	82 e0       	ldi	r24, 0x02	; 2
    5d52:	60 e0       	ldi	r22, 0x00	; 0
    5d54:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits(string3);
    5d58:	ce 01       	movw	r24, r28
    5d5a:	4b 96       	adiw	r24, 0x1b	; 27
    5d5c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>

			HCLCD_VidSetPosition_4BitsMode(2, 8);
    5d60:	82 e0       	ldi	r24, 0x02	; 2
    5d62:	68 e0       	ldi	r22, 0x08	; 8
    5d64:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits(string4);
    5d68:	ce 01       	movw	r24, r28
    5d6a:	86 96       	adiw	r24, 0x26	; 38
    5d6c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>

			HCLCD_VidSetPosition_4BitsMode(2,14);
    5d70:	82 e0       	ldi	r24, 0x02	; 2
    5d72:	6e e0       	ldi	r22, 0x0E	; 14
    5d74:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits((u8*)"C");
    5d78:	89 e6       	ldi	r24, 0x69	; 105
    5d7a:	90 e0       	ldi	r25, 0x00	; 0
    5d7c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>


			HCLCD_VidSetPosition_4BitsMode(1,10);
    5d80:	81 e0       	ldi	r24, 0x01	; 1
    5d82:	6a e0       	ldi	r22, 0x0A	; 10
    5d84:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits((u8*)"    ");
    5d88:	8b e6       	ldi	r24, 0x6B	; 107
    5d8a:	90 e0       	ldi	r25, 0x00	; 0
    5d8c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>
			HCLCD_VidSetPosition_4BitsMode(1,10);
    5d90:	81 e0       	ldi	r24, 0x01	; 1
    5d92:	6a e0       	ldi	r22, 0x0A	; 10
    5d94:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteNumber_4Bits(Analog1);
    5d98:	80 91 3d 07 	lds	r24, 0x073D
    5d9c:	90 91 3e 07 	lds	r25, 0x073E
    5da0:	a0 91 3f 07 	lds	r26, 0x073F
    5da4:	b0 91 40 07 	lds	r27, 0x0740
    5da8:	bc 01       	movw	r22, r24
    5daa:	cd 01       	movw	r24, r26
    5dac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5db0:	dc 01       	movw	r26, r24
    5db2:	cb 01       	movw	r24, r22
    5db4:	bc 01       	movw	r22, r24
    5db6:	cd 01       	movw	r24, r26
    5db8:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <HCLCD_VidWriteNumber_4Bits>


			HCLCD_VidSetPosition_4BitsMode(2,10);
    5dbc:	82 e0       	ldi	r24, 0x02	; 2
    5dbe:	6a e0       	ldi	r22, 0x0A	; 10
    5dc0:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits((u8*)"  ");
    5dc4:	80 e7       	ldi	r24, 0x70	; 112
    5dc6:	90 e0       	ldi	r25, 0x00	; 0
    5dc8:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>
			HCLCD_VidSetPosition_4BitsMode(2,10);
    5dcc:	82 e0       	ldi	r24, 0x02	; 2
    5dce:	6a e0       	ldi	r22, 0x0A	; 10
    5dd0:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteNumber_4Bits(Temp);
    5dd4:	80 91 45 07 	lds	r24, 0x0745
    5dd8:	90 91 46 07 	lds	r25, 0x0746
    5ddc:	a0 91 47 07 	lds	r26, 0x0747
    5de0:	b0 91 48 07 	lds	r27, 0x0748
    5de4:	bc 01       	movw	r22, r24
    5de6:	cd 01       	movw	r24, r26
    5de8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5dec:	dc 01       	movw	r26, r24
    5dee:	cb 01       	movw	r24, r22
    5df0:	bc 01       	movw	r22, r24
    5df2:	cd 01       	movw	r24, r26
    5df4:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <HCLCD_VidWriteNumber_4Bits>

			vTaskDelay(50);
    5df8:	82 e3       	ldi	r24, 0x32	; 50
    5dfa:	90 e0       	ldi	r25, 0x00	; 0
    5dfc:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
		}

		if  (Flag == 2)
    5e00:	80 91 51 07 	lds	r24, 0x0751
    5e04:	82 30       	cpi	r24, 0x02	; 2
    5e06:	09 f0       	breq	.+2      	; 0x5e0a <Task_LCD+0x310>
    5e08:	48 c0       	rjmp	.+144    	; 0x5e9a <Task_LCD+0x3a0>
		{
			if ( Clear == 0 )
    5e0a:	80 91 52 07 	lds	r24, 0x0752
    5e0e:	88 23       	and	r24, r24
    5e10:	31 f4       	brne	.+12     	; 0x5e1e <Task_LCD+0x324>
			{HCLCD_VidWriteCommand_4Bits(0x01>>4);
    5e12:	80 e0       	ldi	r24, 0x00	; 0
    5e14:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
			HCLCD_VidWriteCommand_4Bits(0x01);}
    5e18:	81 e0       	ldi	r24, 0x01	; 1
    5e1a:	0e 94 0c 13 	call	0x2618	; 0x2618 <HCLCD_VidWriteCommand_4Bits>
			Clear = 1;
    5e1e:	81 e0       	ldi	r24, 0x01	; 1
    5e20:	80 93 52 07 	sts	0x0752, r24

			if(wrongInputRemain > 0)
    5e24:	80 91 c4 01 	lds	r24, 0x01C4
    5e28:	88 23       	and	r24, r24
    5e2a:	f1 f0       	breq	.+60     	; 0x5e68 <Task_LCD+0x36e>
			{
			HCLCD_VidSetPosition_4BitsMode(2, 6);
    5e2c:	82 e0       	ldi	r24, 0x02	; 2
    5e2e:	66 e0       	ldi	r22, 0x06	; 6
    5e30:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteNumber_4Bits(wrongInputRemain);
    5e34:	80 91 c4 01 	lds	r24, 0x01C4
    5e38:	88 2f       	mov	r24, r24
    5e3a:	90 e0       	ldi	r25, 0x00	; 0
    5e3c:	a0 e0       	ldi	r26, 0x00	; 0
    5e3e:	b0 e0       	ldi	r27, 0x00	; 0
    5e40:	bc 01       	movw	r22, r24
    5e42:	cd 01       	movw	r24, r26
    5e44:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <HCLCD_VidWriteNumber_4Bits>
			wrongInputRemain -- ;
    5e48:	80 91 c4 01 	lds	r24, 0x01C4
    5e4c:	81 50       	subi	r24, 0x01	; 1
    5e4e:	80 93 c4 01 	sts	0x01C4, r24
			HCLCD_VidSetPosition_4BitsMode(2, 8);
    5e52:	82 e0       	ldi	r24, 0x02	; 2
    5e54:	68 e0       	ldi	r22, 0x08	; 8
    5e56:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits((u8*)"Tries");
    5e5a:	83 e7       	ldi	r24, 0x73	; 115
    5e5c:	90 e0       	ldi	r25, 0x00	; 0
    5e5e:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>
			Flag = 0 ;
    5e62:	10 92 51 07 	sts	0x0751, r1
    5e66:	19 c0       	rjmp	.+50     	; 0x5e9a <Task_LCD+0x3a0>
			}
			else
			{
			HCLCD_VidSetPosition_4BitsMode(1, 0);
    5e68:	81 e0       	ldi	r24, 0x01	; 1
    5e6a:	60 e0       	ldi	r22, 0x00	; 0
    5e6c:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits((u8*)"Calling Police");
    5e70:	89 e7       	ldi	r24, 0x79	; 121
    5e72:	90 e0       	ldi	r25, 0x00	; 0
    5e74:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>
			HCLCD_VidSetPosition_4BitsMode(2, 4);
    5e78:	82 e0       	ldi	r24, 0x02	; 2
    5e7a:	64 e0       	ldi	r22, 0x04	; 4
    5e7c:	0e 94 11 17 	call	0x2e22	; 0x2e22 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits((u8*)"Unsecured");
    5e80:	88 e8       	ldi	r24, 0x88	; 136
    5e82:	90 e0       	ldi	r25, 0x00	; 0
    5e84:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <HCLCD_VidWriteString_4Bits>
			MDIO_Error_State_SetPinValue(PIN5,MDIO_PORTC,PIN_HIGH);
    5e88:	85 e0       	ldi	r24, 0x05	; 5
    5e8a:	62 e0       	ldi	r22, 0x02	; 2
    5e8c:	41 e0       	ldi	r20, 0x01	; 1
    5e8e:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
			vTaskDelay(50);
    5e92:	82 e3       	ldi	r24, 0x32	; 50
    5e94:	90 e0       	ldi	r25, 0x00	; 0
    5e96:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
			}
		}
		vTaskDelay(20);
    5e9a:	84 e1       	ldi	r24, 0x14	; 20
    5e9c:	90 e0       	ldi	r25, 0x00	; 0
    5e9e:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
    5ea2:	38 ce       	rjmp	.-912    	; 0x5b14 <Task_LCD+0x1a>

00005ea4 <taskADC_Read>:
/*****************************************************************
*  Task_ADC
* ADC take Reading and convert it to Digital for Temp and GAS Sensors
********************************************************************/
	void taskADC_Read(void *pv)
	{
    5ea4:	0f 93       	push	r16
    5ea6:	1f 93       	push	r17
    5ea8:	df 93       	push	r29
    5eaa:	cf 93       	push	r28
    5eac:	00 d0       	rcall	.+0      	; 0x5eae <taskADC_Read+0xa>
    5eae:	0f 92       	push	r0
    5eb0:	cd b7       	in	r28, 0x3d	; 61
    5eb2:	de b7       	in	r29, 0x3e	; 62
    5eb4:	9b 83       	std	Y+3, r25	; 0x03
    5eb6:	8a 83       	std	Y+2, r24	; 0x02
		u8 counter = 0 ;
    5eb8:	19 82       	std	Y+1, r1	; 0x01
		while(1)
		{
			if( Flag == 1 )
    5eba:	80 91 51 07 	lds	r24, 0x0751
    5ebe:	81 30       	cpi	r24, 0x01	; 1
    5ec0:	39 f5       	brne	.+78     	; 0x5f10 <taskADC_Read+0x6c>
			{
					/* Read the Digital (0 - 1024) */
					Digital[counter] = MADC_u16ADCRead();
    5ec2:	89 81       	ldd	r24, Y+1	; 0x01
    5ec4:	08 2f       	mov	r16, r24
    5ec6:	10 e0       	ldi	r17, 0x00	; 0
    5ec8:	0e 94 b1 0c 	call	0x1962	; 0x1962 <MADC_u16ADCRead>
    5ecc:	9c 01       	movw	r18, r24
    5ece:	c8 01       	movw	r24, r16
    5ed0:	88 0f       	add	r24, r24
    5ed2:	99 1f       	adc	r25, r25
    5ed4:	fc 01       	movw	r30, r24
    5ed6:	e7 5c       	subi	r30, 0xC7	; 199
    5ed8:	f8 4f       	sbci	r31, 0xF8	; 248
    5eda:	31 83       	std	Z+1, r19	; 0x01
    5edc:	20 83       	st	Z, r18
					if(CHANNEL_Num == 7 )
    5ede:	80 91 49 07 	lds	r24, 0x0749
    5ee2:	87 30       	cpi	r24, 0x07	; 7
    5ee4:	19 f4       	brne	.+6      	; 0x5eec <taskADC_Read+0x48>
					{
						CHANNEL_Num = 0;
    5ee6:	10 92 49 07 	sts	0x0749, r1
    5eea:	07 c0       	rjmp	.+14     	; 0x5efa <taskADC_Read+0x56>
					}
					else if (CHANNEL_Num == 0)
    5eec:	80 91 49 07 	lds	r24, 0x0749
    5ef0:	88 23       	and	r24, r24
    5ef2:	19 f4       	brne	.+6      	; 0x5efa <taskADC_Read+0x56>
					{
						CHANNEL_Num = 7 ;
    5ef4:	87 e0       	ldi	r24, 0x07	; 7
    5ef6:	80 93 49 07 	sts	0x0749, r24
					}
					MADC_u16ADC_StartConversion_With_Interrupt(CHANNEL_Num); //new conversion After Reading the Last conversion
    5efa:	80 91 49 07 	lds	r24, 0x0749
    5efe:	0e 94 8e 0c 	call	0x191c	; 0x191c <MADC_u16ADC_StartConversion_With_Interrupt>
					counter ++ ;
    5f02:	89 81       	ldd	r24, Y+1	; 0x01
    5f04:	8f 5f       	subi	r24, 0xFF	; 255
    5f06:	89 83       	std	Y+1, r24	; 0x01
					if(counter == 2)
    5f08:	89 81       	ldd	r24, Y+1	; 0x01
    5f0a:	82 30       	cpi	r24, 0x02	; 2
    5f0c:	09 f4       	brne	.+2      	; 0x5f10 <taskADC_Read+0x6c>
					{
						counter = 0;
    5f0e:	19 82       	std	Y+1, r1	; 0x01
					}
			}
			vTaskDelay(10);
    5f10:	8a e0       	ldi	r24, 0x0A	; 10
    5f12:	90 e0       	ldi	r25, 0x00	; 0
    5f14:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
    5f18:	d0 cf       	rjmp	.-96     	; 0x5eba <taskADC_Read+0x16>

00005f1a <task_PotCal>:
* Task_Gas Sensor
* IF Gas Reading  > 2500 ---> Buzzer ON , Window Open (MOTOR ON)
* IF Gas Reading < 2500 ---> Buzzer OFF , Window Close (MOTOR OFF)
* ***************************************************************/
	void task_PotCal(void *pv)
	{
    5f1a:	df 93       	push	r29
    5f1c:	cf 93       	push	r28
    5f1e:	00 d0       	rcall	.+0      	; 0x5f20 <task_PotCal+0x6>
    5f20:	0f 92       	push	r0
    5f22:	cd b7       	in	r28, 0x3d	; 61
    5f24:	de b7       	in	r29, 0x3e	; 62
    5f26:	9a 83       	std	Y+2, r25	; 0x02
    5f28:	89 83       	std	Y+1, r24	; 0x01
		static u8 FLAG = 0;
		while(1)
		{
			Analog1 = (Digital[0]*5000UL) / 1024 ;
    5f2a:	80 91 39 07 	lds	r24, 0x0739
    5f2e:	90 91 3a 07 	lds	r25, 0x073A
    5f32:	cc 01       	movw	r24, r24
    5f34:	a0 e0       	ldi	r26, 0x00	; 0
    5f36:	b0 e0       	ldi	r27, 0x00	; 0
    5f38:	28 e8       	ldi	r18, 0x88	; 136
    5f3a:	33 e1       	ldi	r19, 0x13	; 19
    5f3c:	40 e0       	ldi	r20, 0x00	; 0
    5f3e:	50 e0       	ldi	r21, 0x00	; 0
    5f40:	bc 01       	movw	r22, r24
    5f42:	cd 01       	movw	r24, r26
    5f44:	0e 94 c8 30 	call	0x6190	; 0x6190 <__mulsi3>
    5f48:	dc 01       	movw	r26, r24
    5f4a:	cb 01       	movw	r24, r22
    5f4c:	07 2e       	mov	r0, r23
    5f4e:	7a e0       	ldi	r23, 0x0A	; 10
    5f50:	b6 95       	lsr	r27
    5f52:	a7 95       	ror	r26
    5f54:	97 95       	ror	r25
    5f56:	87 95       	ror	r24
    5f58:	7a 95       	dec	r23
    5f5a:	d1 f7       	brne	.-12     	; 0x5f50 <task_PotCal+0x36>
    5f5c:	70 2d       	mov	r23, r0
    5f5e:	bc 01       	movw	r22, r24
    5f60:	cd 01       	movw	r24, r26
    5f62:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <__floatunsisf>
    5f66:	dc 01       	movw	r26, r24
    5f68:	cb 01       	movw	r24, r22
    5f6a:	80 93 3d 07 	sts	0x073D, r24
    5f6e:	90 93 3e 07 	sts	0x073E, r25
    5f72:	a0 93 3f 07 	sts	0x073F, r26
    5f76:	b0 93 40 07 	sts	0x0740, r27
			vTaskDelay(15);
    5f7a:	8f e0       	ldi	r24, 0x0F	; 15
    5f7c:	90 e0       	ldi	r25, 0x00	; 0
    5f7e:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
			if((Analog1<=2500)&&(FLAG == 1))
    5f82:	80 91 3d 07 	lds	r24, 0x073D
    5f86:	90 91 3e 07 	lds	r25, 0x073E
    5f8a:	a0 91 3f 07 	lds	r26, 0x073F
    5f8e:	b0 91 40 07 	lds	r27, 0x0740
    5f92:	1b 82       	std	Y+3, r1	; 0x03
    5f94:	bc 01       	movw	r22, r24
    5f96:	cd 01       	movw	r24, r26
    5f98:	20 e0       	ldi	r18, 0x00	; 0
    5f9a:	30 e4       	ldi	r19, 0x40	; 64
    5f9c:	4c e1       	ldi	r20, 0x1C	; 28
    5f9e:	55 e4       	ldi	r21, 0x45	; 69
    5fa0:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    5fa4:	18 16       	cp	r1, r24
    5fa6:	14 f0       	brlt	.+4      	; 0x5fac <task_PotCal+0x92>
    5fa8:	81 e0       	ldi	r24, 0x01	; 1
    5faa:	8b 83       	std	Y+3, r24	; 0x03
    5fac:	81 e0       	ldi	r24, 0x01	; 1
    5fae:	9b 81       	ldd	r25, Y+3	; 0x03
    5fb0:	89 27       	eor	r24, r25
    5fb2:	88 23       	and	r24, r24
    5fb4:	21 f5       	brne	.+72     	; 0x5ffe <task_PotCal+0xe4>
    5fb6:	80 91 54 07 	lds	r24, 0x0754
    5fba:	81 30       	cpi	r24, 0x01	; 1
    5fbc:	01 f5       	brne	.+64     	; 0x5ffe <task_PotCal+0xe4>
			{
				FLAG = 0;
    5fbe:	10 92 54 07 	sts	0x0754, r1
				MDIO_Error_State_SetPinValue(PIN5,MDIO_PORTC,PIN_LOW);///gaz BUZZER
    5fc2:	85 e0       	ldi	r24, 0x05	; 5
    5fc4:	62 e0       	ldi	r22, 0x02	; 2
    5fc6:	40 e0       	ldi	r20, 0x00	; 0
    5fc8:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN2,MDIO_PORTC,PIN_HIGH);//led
    5fcc:	82 e0       	ldi	r24, 0x02	; 2
    5fce:	62 e0       	ldi	r22, 0x02	; 2
    5fd0:	41 e0       	ldi	r20, 0x01	; 1
    5fd2:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN7,MDIO_PORTD,PIN_HIGH);//MOTOR CLOSE WINDO
    5fd6:	87 e0       	ldi	r24, 0x07	; 7
    5fd8:	63 e0       	ldi	r22, 0x03	; 3
    5fda:	41 e0       	ldi	r20, 0x01	; 1
    5fdc:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				vTaskDelay(600);
    5fe0:	88 e5       	ldi	r24, 0x58	; 88
    5fe2:	92 e0       	ldi	r25, 0x02	; 2
    5fe4:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
				MDIO_Error_State_SetPinValue(PIN7,MDIO_PORTD,PIN_LOW);//STOP MOTOR
    5fe8:	87 e0       	ldi	r24, 0x07	; 7
    5fea:	63 e0       	ldi	r22, 0x03	; 3
    5fec:	40 e0       	ldi	r20, 0x00	; 0
    5fee:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN2,MDIO_PORTC,PIN_LOW);//led
    5ff2:	82 e0       	ldi	r24, 0x02	; 2
    5ff4:	62 e0       	ldi	r22, 0x02	; 2
    5ff6:	40 e0       	ldi	r20, 0x00	; 0
    5ff8:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
    5ffc:	36 c0       	rjmp	.+108    	; 0x606a <task_PotCal+0x150>
			}
			else if((Analog1>2500)&&(FLAG == 0))
    5ffe:	80 91 3d 07 	lds	r24, 0x073D
    6002:	90 91 3e 07 	lds	r25, 0x073E
    6006:	a0 91 3f 07 	lds	r26, 0x073F
    600a:	b0 91 40 07 	lds	r27, 0x0740
    600e:	bc 01       	movw	r22, r24
    6010:	cd 01       	movw	r24, r26
    6012:	20 e0       	ldi	r18, 0x00	; 0
    6014:	30 e4       	ldi	r19, 0x40	; 64
    6016:	4c e1       	ldi	r20, 0x1C	; 28
    6018:	55 e4       	ldi	r21, 0x45	; 69
    601a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    601e:	18 16       	cp	r1, r24
    6020:	24 f5       	brge	.+72     	; 0x606a <task_PotCal+0x150>
    6022:	80 91 54 07 	lds	r24, 0x0754
    6026:	88 23       	and	r24, r24
    6028:	01 f5       	brne	.+64     	; 0x606a <task_PotCal+0x150>
				{
				FLAG = 1;
    602a:	81 e0       	ldi	r24, 0x01	; 1
    602c:	80 93 54 07 	sts	0x0754, r24
				MDIO_Error_State_SetPinValue(PIN5,MDIO_PORTC,PIN_HIGH);///gaz BUZZER
    6030:	85 e0       	ldi	r24, 0x05	; 5
    6032:	62 e0       	ldi	r22, 0x02	; 2
    6034:	41 e0       	ldi	r20, 0x01	; 1
    6036:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN2,MDIO_PORTC,PIN_HIGH);//led
    603a:	82 e0       	ldi	r24, 0x02	; 2
    603c:	62 e0       	ldi	r22, 0x02	; 2
    603e:	41 e0       	ldi	r20, 0x01	; 1
    6040:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN6,MDIO_PORTD,PIN_HIGH);//MOTOR OPEN WINDO
    6044:	86 e0       	ldi	r24, 0x06	; 6
    6046:	63 e0       	ldi	r22, 0x03	; 3
    6048:	41 e0       	ldi	r20, 0x01	; 1
    604a:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				vTaskDelay(600);
    604e:	88 e5       	ldi	r24, 0x58	; 88
    6050:	92 e0       	ldi	r25, 0x02	; 2
    6052:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
				MDIO_Error_State_SetPinValue(PIN6,MDIO_PORTD,PIN_LOW);//STOP MOTOR
    6056:	86 e0       	ldi	r24, 0x06	; 6
    6058:	63 e0       	ldi	r22, 0x03	; 3
    605a:	40 e0       	ldi	r20, 0x00	; 0
    605c:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN2,MDIO_PORTC,PIN_LOW);//led
    6060:	82 e0       	ldi	r24, 0x02	; 2
    6062:	62 e0       	ldi	r22, 0x02	; 2
    6064:	40 e0       	ldi	r20, 0x00	; 0
    6066:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
			}
			vTaskDelay(15);
    606a:	8f e0       	ldi	r24, 0x0F	; 15
    606c:	90 e0       	ldi	r25, 0x00	; 0
    606e:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
    6072:	5b cf       	rjmp	.-330    	; 0x5f2a <task_PotCal+0x10>

00006074 <task_TempCal>:
 *
 * IF Temp Reading  > 30 ---> FAN ON (MOTOR ON) and Led ON
 * IF Temp Reading < 30 ----> FAN Off (MOTOR OFF) and Led Off
 * **********************************************************/
	void task_TempCal(void *pv)
	{
    6074:	df 93       	push	r29
    6076:	cf 93       	push	r28
    6078:	00 d0       	rcall	.+0      	; 0x607a <task_TempCal+0x6>
    607a:	cd b7       	in	r28, 0x3d	; 61
    607c:	de b7       	in	r29, 0x3e	; 62
    607e:	9a 83       	std	Y+2, r25	; 0x02
    6080:	89 83       	std	Y+1, r24	; 0x01
		while(1)
		{
			Analog2 = ((float)Digital[1]*5000.0) / 1024.0 ;
    6082:	80 91 3b 07 	lds	r24, 0x073B
    6086:	90 91 3c 07 	lds	r25, 0x073C
    608a:	cc 01       	movw	r24, r24
    608c:	a0 e0       	ldi	r26, 0x00	; 0
    608e:	b0 e0       	ldi	r27, 0x00	; 0
    6090:	bc 01       	movw	r22, r24
    6092:	cd 01       	movw	r24, r26
    6094:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <__floatunsisf>
    6098:	dc 01       	movw	r26, r24
    609a:	cb 01       	movw	r24, r22
    609c:	bc 01       	movw	r22, r24
    609e:	cd 01       	movw	r24, r26
    60a0:	20 e0       	ldi	r18, 0x00	; 0
    60a2:	30 e4       	ldi	r19, 0x40	; 64
    60a4:	4c e9       	ldi	r20, 0x9C	; 156
    60a6:	55 e4       	ldi	r21, 0x45	; 69
    60a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    60ac:	dc 01       	movw	r26, r24
    60ae:	cb 01       	movw	r24, r22
    60b0:	bc 01       	movw	r22, r24
    60b2:	cd 01       	movw	r24, r26
    60b4:	20 e0       	ldi	r18, 0x00	; 0
    60b6:	30 e0       	ldi	r19, 0x00	; 0
    60b8:	40 e8       	ldi	r20, 0x80	; 128
    60ba:	54 e4       	ldi	r21, 0x44	; 68
    60bc:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    60c0:	dc 01       	movw	r26, r24
    60c2:	cb 01       	movw	r24, r22
    60c4:	80 93 41 07 	sts	0x0741, r24
    60c8:	90 93 42 07 	sts	0x0742, r25
    60cc:	a0 93 43 07 	sts	0x0743, r26
    60d0:	b0 93 44 07 	sts	0x0744, r27
			Temp = round (Analog2 / 10 );
    60d4:	80 91 41 07 	lds	r24, 0x0741
    60d8:	90 91 42 07 	lds	r25, 0x0742
    60dc:	a0 91 43 07 	lds	r26, 0x0743
    60e0:	b0 91 44 07 	lds	r27, 0x0744
    60e4:	bc 01       	movw	r22, r24
    60e6:	cd 01       	movw	r24, r26
    60e8:	20 e0       	ldi	r18, 0x00	; 0
    60ea:	30 e0       	ldi	r19, 0x00	; 0
    60ec:	40 e2       	ldi	r20, 0x20	; 32
    60ee:	51 e4       	ldi	r21, 0x41	; 65
    60f0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    60f4:	dc 01       	movw	r26, r24
    60f6:	cb 01       	movw	r24, r22
    60f8:	bc 01       	movw	r22, r24
    60fa:	cd 01       	movw	r24, r26
    60fc:	0e 94 5f 31 	call	0x62be	; 0x62be <round>
    6100:	dc 01       	movw	r26, r24
    6102:	cb 01       	movw	r24, r22
    6104:	80 93 45 07 	sts	0x0745, r24
    6108:	90 93 46 07 	sts	0x0746, r25
    610c:	a0 93 47 07 	sts	0x0747, r26
    6110:	b0 93 48 07 	sts	0x0748, r27
			if(Temp<=30)
    6114:	80 91 45 07 	lds	r24, 0x0745
    6118:	90 91 46 07 	lds	r25, 0x0746
    611c:	a0 91 47 07 	lds	r26, 0x0747
    6120:	b0 91 48 07 	lds	r27, 0x0748
    6124:	bc 01       	movw	r22, r24
    6126:	cd 01       	movw	r24, r26
    6128:	20 e0       	ldi	r18, 0x00	; 0
    612a:	30 e0       	ldi	r19, 0x00	; 0
    612c:	40 ef       	ldi	r20, 0xF0	; 240
    612e:	51 e4       	ldi	r21, 0x41	; 65
    6130:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    6134:	18 16       	cp	r1, r24
    6136:	5c f0       	brlt	.+22     	; 0x614e <task_TempCal+0xda>
			{
				MDIO_Error_State_SetPinValue(PIN1,MDIO_PORTC,PIN_LOW);//LED
    6138:	81 e0       	ldi	r24, 0x01	; 1
    613a:	62 e0       	ldi	r22, 0x02	; 2
    613c:	40 e0       	ldi	r20, 0x00	; 0
    613e:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTD,PIN_LOW);//STOP MOTOR
    6142:	80 e0       	ldi	r24, 0x00	; 0
    6144:	63 e0       	ldi	r22, 0x03	; 3
    6146:	40 e0       	ldi	r20, 0x00	; 0
    6148:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
    614c:	1c c0       	rjmp	.+56     	; 0x6186 <task_TempCal+0x112>
			}
			else if(Temp>30)
    614e:	80 91 45 07 	lds	r24, 0x0745
    6152:	90 91 46 07 	lds	r25, 0x0746
    6156:	a0 91 47 07 	lds	r26, 0x0747
    615a:	b0 91 48 07 	lds	r27, 0x0748
    615e:	bc 01       	movw	r22, r24
    6160:	cd 01       	movw	r24, r26
    6162:	20 e0       	ldi	r18, 0x00	; 0
    6164:	30 e0       	ldi	r19, 0x00	; 0
    6166:	40 ef       	ldi	r20, 0xF0	; 240
    6168:	51 e4       	ldi	r21, 0x41	; 65
    616a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    616e:	18 16       	cp	r1, r24
    6170:	54 f4       	brge	.+20     	; 0x6186 <task_TempCal+0x112>
			{
				MDIO_Error_State_SetPinValue(PIN1,MDIO_PORTC,PIN_HIGH);//LED
    6172:	81 e0       	ldi	r24, 0x01	; 1
    6174:	62 e0       	ldi	r22, 0x02	; 2
    6176:	41 e0       	ldi	r20, 0x01	; 1
    6178:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
				MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTD,PIN_HIGH);//MOTOR on
    617c:	80 e0       	ldi	r24, 0x00	; 0
    617e:	63 e0       	ldi	r22, 0x03	; 3
    6180:	41 e0       	ldi	r20, 0x01	; 1
    6182:	0e 94 88 09 	call	0x1310	; 0x1310 <MDIO_Error_State_SetPinValue>
			}
			vTaskDelay(15);
    6186:	8f e0       	ldi	r24, 0x0F	; 15
    6188:	90 e0       	ldi	r25, 0x00	; 0
    618a:	0e 94 fa 25 	call	0x4bf4	; 0x4bf4 <vTaskDelay>
    618e:	79 cf       	rjmp	.-270    	; 0x6082 <task_TempCal+0xe>

00006190 <__mulsi3>:
    6190:	62 9f       	mul	r22, r18
    6192:	d0 01       	movw	r26, r0
    6194:	73 9f       	mul	r23, r19
    6196:	f0 01       	movw	r30, r0
    6198:	82 9f       	mul	r24, r18
    619a:	e0 0d       	add	r30, r0
    619c:	f1 1d       	adc	r31, r1
    619e:	64 9f       	mul	r22, r20
    61a0:	e0 0d       	add	r30, r0
    61a2:	f1 1d       	adc	r31, r1
    61a4:	92 9f       	mul	r25, r18
    61a6:	f0 0d       	add	r31, r0
    61a8:	83 9f       	mul	r24, r19
    61aa:	f0 0d       	add	r31, r0
    61ac:	74 9f       	mul	r23, r20
    61ae:	f0 0d       	add	r31, r0
    61b0:	65 9f       	mul	r22, r21
    61b2:	f0 0d       	add	r31, r0
    61b4:	99 27       	eor	r25, r25
    61b6:	72 9f       	mul	r23, r18
    61b8:	b0 0d       	add	r27, r0
    61ba:	e1 1d       	adc	r30, r1
    61bc:	f9 1f       	adc	r31, r25
    61be:	63 9f       	mul	r22, r19
    61c0:	b0 0d       	add	r27, r0
    61c2:	e1 1d       	adc	r30, r1
    61c4:	f9 1f       	adc	r31, r25
    61c6:	bd 01       	movw	r22, r26
    61c8:	cf 01       	movw	r24, r30
    61ca:	11 24       	eor	r1, r1
    61cc:	08 95       	ret

000061ce <__udivmodsi4>:
    61ce:	a1 e2       	ldi	r26, 0x21	; 33
    61d0:	1a 2e       	mov	r1, r26
    61d2:	aa 1b       	sub	r26, r26
    61d4:	bb 1b       	sub	r27, r27
    61d6:	fd 01       	movw	r30, r26
    61d8:	0d c0       	rjmp	.+26     	; 0x61f4 <__udivmodsi4_ep>

000061da <__udivmodsi4_loop>:
    61da:	aa 1f       	adc	r26, r26
    61dc:	bb 1f       	adc	r27, r27
    61de:	ee 1f       	adc	r30, r30
    61e0:	ff 1f       	adc	r31, r31
    61e2:	a2 17       	cp	r26, r18
    61e4:	b3 07       	cpc	r27, r19
    61e6:	e4 07       	cpc	r30, r20
    61e8:	f5 07       	cpc	r31, r21
    61ea:	20 f0       	brcs	.+8      	; 0x61f4 <__udivmodsi4_ep>
    61ec:	a2 1b       	sub	r26, r18
    61ee:	b3 0b       	sbc	r27, r19
    61f0:	e4 0b       	sbc	r30, r20
    61f2:	f5 0b       	sbc	r31, r21

000061f4 <__udivmodsi4_ep>:
    61f4:	66 1f       	adc	r22, r22
    61f6:	77 1f       	adc	r23, r23
    61f8:	88 1f       	adc	r24, r24
    61fa:	99 1f       	adc	r25, r25
    61fc:	1a 94       	dec	r1
    61fe:	69 f7       	brne	.-38     	; 0x61da <__udivmodsi4_loop>
    6200:	60 95       	com	r22
    6202:	70 95       	com	r23
    6204:	80 95       	com	r24
    6206:	90 95       	com	r25
    6208:	9b 01       	movw	r18, r22
    620a:	ac 01       	movw	r20, r24
    620c:	bd 01       	movw	r22, r26
    620e:	cf 01       	movw	r24, r30
    6210:	08 95       	ret

00006212 <__prologue_saves__>:
    6212:	2f 92       	push	r2
    6214:	3f 92       	push	r3
    6216:	4f 92       	push	r4
    6218:	5f 92       	push	r5
    621a:	6f 92       	push	r6
    621c:	7f 92       	push	r7
    621e:	8f 92       	push	r8
    6220:	9f 92       	push	r9
    6222:	af 92       	push	r10
    6224:	bf 92       	push	r11
    6226:	cf 92       	push	r12
    6228:	df 92       	push	r13
    622a:	ef 92       	push	r14
    622c:	ff 92       	push	r15
    622e:	0f 93       	push	r16
    6230:	1f 93       	push	r17
    6232:	cf 93       	push	r28
    6234:	df 93       	push	r29
    6236:	cd b7       	in	r28, 0x3d	; 61
    6238:	de b7       	in	r29, 0x3e	; 62
    623a:	ca 1b       	sub	r28, r26
    623c:	db 0b       	sbc	r29, r27
    623e:	0f b6       	in	r0, 0x3f	; 63
    6240:	f8 94       	cli
    6242:	de bf       	out	0x3e, r29	; 62
    6244:	0f be       	out	0x3f, r0	; 63
    6246:	cd bf       	out	0x3d, r28	; 61
    6248:	09 94       	ijmp

0000624a <__epilogue_restores__>:
    624a:	2a 88       	ldd	r2, Y+18	; 0x12
    624c:	39 88       	ldd	r3, Y+17	; 0x11
    624e:	48 88       	ldd	r4, Y+16	; 0x10
    6250:	5f 84       	ldd	r5, Y+15	; 0x0f
    6252:	6e 84       	ldd	r6, Y+14	; 0x0e
    6254:	7d 84       	ldd	r7, Y+13	; 0x0d
    6256:	8c 84       	ldd	r8, Y+12	; 0x0c
    6258:	9b 84       	ldd	r9, Y+11	; 0x0b
    625a:	aa 84       	ldd	r10, Y+10	; 0x0a
    625c:	b9 84       	ldd	r11, Y+9	; 0x09
    625e:	c8 84       	ldd	r12, Y+8	; 0x08
    6260:	df 80       	ldd	r13, Y+7	; 0x07
    6262:	ee 80       	ldd	r14, Y+6	; 0x06
    6264:	fd 80       	ldd	r15, Y+5	; 0x05
    6266:	0c 81       	ldd	r16, Y+4	; 0x04
    6268:	1b 81       	ldd	r17, Y+3	; 0x03
    626a:	aa 81       	ldd	r26, Y+2	; 0x02
    626c:	b9 81       	ldd	r27, Y+1	; 0x01
    626e:	ce 0f       	add	r28, r30
    6270:	d1 1d       	adc	r29, r1
    6272:	0f b6       	in	r0, 0x3f	; 63
    6274:	f8 94       	cli
    6276:	de bf       	out	0x3e, r29	; 62
    6278:	0f be       	out	0x3f, r0	; 63
    627a:	cd bf       	out	0x3d, r28	; 61
    627c:	ed 01       	movw	r28, r26
    627e:	08 95       	ret

00006280 <memcpy>:
    6280:	fb 01       	movw	r30, r22
    6282:	dc 01       	movw	r26, r24
    6284:	02 c0       	rjmp	.+4      	; 0x628a <memcpy+0xa>
    6286:	01 90       	ld	r0, Z+
    6288:	0d 92       	st	X+, r0
    628a:	41 50       	subi	r20, 0x01	; 1
    628c:	50 40       	sbci	r21, 0x00	; 0
    628e:	d8 f7       	brcc	.-10     	; 0x6286 <memcpy+0x6>
    6290:	08 95       	ret

00006292 <memset>:
    6292:	dc 01       	movw	r26, r24
    6294:	01 c0       	rjmp	.+2      	; 0x6298 <memset+0x6>
    6296:	6d 93       	st	X+, r22
    6298:	41 50       	subi	r20, 0x01	; 1
    629a:	50 40       	sbci	r21, 0x00	; 0
    629c:	e0 f7       	brcc	.-8      	; 0x6296 <memset+0x4>
    629e:	08 95       	ret

000062a0 <strncpy>:
    62a0:	fb 01       	movw	r30, r22
    62a2:	dc 01       	movw	r26, r24
    62a4:	41 50       	subi	r20, 0x01	; 1
    62a6:	50 40       	sbci	r21, 0x00	; 0
    62a8:	48 f0       	brcs	.+18     	; 0x62bc <strncpy+0x1c>
    62aa:	01 90       	ld	r0, Z+
    62ac:	0d 92       	st	X+, r0
    62ae:	00 20       	and	r0, r0
    62b0:	c9 f7       	brne	.-14     	; 0x62a4 <strncpy+0x4>
    62b2:	01 c0       	rjmp	.+2      	; 0x62b6 <strncpy+0x16>
    62b4:	1d 92       	st	X+, r1
    62b6:	41 50       	subi	r20, 0x01	; 1
    62b8:	50 40       	sbci	r21, 0x00	; 0
    62ba:	e0 f7       	brcc	.-8      	; 0x62b4 <strncpy+0x14>
    62bc:	08 95       	ret

000062be <round>:
    62be:	50 d0       	rcall	.+160    	; 0x6360 <__fp_splitA>
    62c0:	e0 f0       	brcs	.+56     	; 0x62fa <round+0x3c>
    62c2:	9e 37       	cpi	r25, 0x7E	; 126
    62c4:	d8 f0       	brcs	.+54     	; 0x62fc <round+0x3e>
    62c6:	96 39       	cpi	r25, 0x96	; 150
    62c8:	b8 f4       	brcc	.+46     	; 0x62f8 <round+0x3a>
    62ca:	9e 38       	cpi	r25, 0x8E	; 142
    62cc:	48 f4       	brcc	.+18     	; 0x62e0 <round+0x22>
    62ce:	67 2f       	mov	r22, r23
    62d0:	78 2f       	mov	r23, r24
    62d2:	88 27       	eor	r24, r24
    62d4:	98 5f       	subi	r25, 0xF8	; 248
    62d6:	f9 cf       	rjmp	.-14     	; 0x62ca <round+0xc>
    62d8:	86 95       	lsr	r24
    62da:	77 95       	ror	r23
    62dc:	67 95       	ror	r22
    62de:	93 95       	inc	r25
    62e0:	95 39       	cpi	r25, 0x95	; 149
    62e2:	d0 f3       	brcs	.-12     	; 0x62d8 <round+0x1a>
    62e4:	b6 2f       	mov	r27, r22
    62e6:	b1 70       	andi	r27, 0x01	; 1
    62e8:	6b 0f       	add	r22, r27
    62ea:	71 1d       	adc	r23, r1
    62ec:	81 1d       	adc	r24, r1
    62ee:	20 f4       	brcc	.+8      	; 0x62f8 <round+0x3a>
    62f0:	87 95       	ror	r24
    62f2:	77 95       	ror	r23
    62f4:	67 95       	ror	r22
    62f6:	93 95       	inc	r25
    62f8:	02 c0       	rjmp	.+4      	; 0x62fe <__fp_mintl>
    62fa:	1c c0       	rjmp	.+56     	; 0x6334 <__fp_mpack>
    62fc:	4c c0       	rjmp	.+152    	; 0x6396 <__fp_szero>

000062fe <__fp_mintl>:
    62fe:	88 23       	and	r24, r24
    6300:	71 f4       	brne	.+28     	; 0x631e <__fp_mintl+0x20>
    6302:	77 23       	and	r23, r23
    6304:	21 f0       	breq	.+8      	; 0x630e <__fp_mintl+0x10>
    6306:	98 50       	subi	r25, 0x08	; 8
    6308:	87 2b       	or	r24, r23
    630a:	76 2f       	mov	r23, r22
    630c:	07 c0       	rjmp	.+14     	; 0x631c <__fp_mintl+0x1e>
    630e:	66 23       	and	r22, r22
    6310:	11 f4       	brne	.+4      	; 0x6316 <__fp_mintl+0x18>
    6312:	99 27       	eor	r25, r25
    6314:	0d c0       	rjmp	.+26     	; 0x6330 <__fp_mintl+0x32>
    6316:	90 51       	subi	r25, 0x10	; 16
    6318:	86 2b       	or	r24, r22
    631a:	70 e0       	ldi	r23, 0x00	; 0
    631c:	60 e0       	ldi	r22, 0x00	; 0
    631e:	2a f0       	brmi	.+10     	; 0x632a <__fp_mintl+0x2c>
    6320:	9a 95       	dec	r25
    6322:	66 0f       	add	r22, r22
    6324:	77 1f       	adc	r23, r23
    6326:	88 1f       	adc	r24, r24
    6328:	da f7       	brpl	.-10     	; 0x6320 <__fp_mintl+0x22>
    632a:	88 0f       	add	r24, r24
    632c:	96 95       	lsr	r25
    632e:	87 95       	ror	r24
    6330:	97 f9       	bld	r25, 7
    6332:	08 95       	ret

00006334 <__fp_mpack>:
    6334:	9f 3f       	cpi	r25, 0xFF	; 255
    6336:	31 f0       	breq	.+12     	; 0x6344 <__fp_mpack_finite+0xc>

00006338 <__fp_mpack_finite>:
    6338:	91 50       	subi	r25, 0x01	; 1
    633a:	20 f4       	brcc	.+8      	; 0x6344 <__fp_mpack_finite+0xc>
    633c:	87 95       	ror	r24
    633e:	77 95       	ror	r23
    6340:	67 95       	ror	r22
    6342:	b7 95       	ror	r27
    6344:	88 0f       	add	r24, r24
    6346:	91 1d       	adc	r25, r1
    6348:	96 95       	lsr	r25
    634a:	87 95       	ror	r24
    634c:	97 f9       	bld	r25, 7
    634e:	08 95       	ret

00006350 <__fp_split3>:
    6350:	57 fd       	sbrc	r21, 7
    6352:	90 58       	subi	r25, 0x80	; 128
    6354:	44 0f       	add	r20, r20
    6356:	55 1f       	adc	r21, r21
    6358:	59 f0       	breq	.+22     	; 0x6370 <__fp_splitA+0x10>
    635a:	5f 3f       	cpi	r21, 0xFF	; 255
    635c:	71 f0       	breq	.+28     	; 0x637a <__fp_splitA+0x1a>
    635e:	47 95       	ror	r20

00006360 <__fp_splitA>:
    6360:	88 0f       	add	r24, r24
    6362:	97 fb       	bst	r25, 7
    6364:	99 1f       	adc	r25, r25
    6366:	61 f0       	breq	.+24     	; 0x6380 <__fp_splitA+0x20>
    6368:	9f 3f       	cpi	r25, 0xFF	; 255
    636a:	79 f0       	breq	.+30     	; 0x638a <__fp_splitA+0x2a>
    636c:	87 95       	ror	r24
    636e:	08 95       	ret
    6370:	12 16       	cp	r1, r18
    6372:	13 06       	cpc	r1, r19
    6374:	14 06       	cpc	r1, r20
    6376:	55 1f       	adc	r21, r21
    6378:	f2 cf       	rjmp	.-28     	; 0x635e <__fp_split3+0xe>
    637a:	46 95       	lsr	r20
    637c:	f1 df       	rcall	.-30     	; 0x6360 <__fp_splitA>
    637e:	08 c0       	rjmp	.+16     	; 0x6390 <__fp_splitA+0x30>
    6380:	16 16       	cp	r1, r22
    6382:	17 06       	cpc	r1, r23
    6384:	18 06       	cpc	r1, r24
    6386:	99 1f       	adc	r25, r25
    6388:	f1 cf       	rjmp	.-30     	; 0x636c <__fp_splitA+0xc>
    638a:	86 95       	lsr	r24
    638c:	71 05       	cpc	r23, r1
    638e:	61 05       	cpc	r22, r1
    6390:	08 94       	sec
    6392:	08 95       	ret

00006394 <__fp_zero>:
    6394:	e8 94       	clt

00006396 <__fp_szero>:
    6396:	bb 27       	eor	r27, r27
    6398:	66 27       	eor	r22, r22
    639a:	77 27       	eor	r23, r23
    639c:	cb 01       	movw	r24, r22
    639e:	97 f9       	bld	r25, 7
    63a0:	08 95       	ret

000063a2 <_exit>:
    63a2:	f8 94       	cli

000063a4 <__stop_program>:
    63a4:	ff cf       	rjmp	.-2      	; 0x63a4 <__stop_program>
